{"remainingRequest":"/Users/chanderprall/projects/eui/node_modules/babel-loader/lib/index.js!/Users/chanderprall/projects/eui/src/components/context_menu/context_menu_panel.tsx","dependencies":[{"path":"/Users/chanderprall/projects/eui/src/components/context_menu/context_menu_panel.tsx","mtime":1567626462142},{"path":"/Users/chanderprall/projects/eui/.babelrc.js","mtime":1565204168946},{"path":"/Users/chanderprall/projects/eui/node_modules/cache-loader/dist/cjs.js","mtime":1555436064329},{"path":"/Users/chanderprall/projects/eui/node_modules/babel-loader/lib/index.js","mtime":1543517280769}],"contextDependencies":[],"result":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.EuiContextMenuPanel = void 0;\n\nrequire(\"core-js/modules/es7.symbol.async-iterator\");\n\nrequire(\"core-js/modules/es6.symbol\");\n\nrequire(\"core-js/modules/es6.object.assign\");\n\nrequire(\"core-js/modules/es6.array.iterator\");\n\nrequire(\"core-js/modules/es6.object.keys\");\n\nrequire(\"core-js/modules/es6.object.set-prototype-of\");\n\nrequire(\"core-js/modules/web.dom.iterable\");\n\nvar _react = _interopRequireWildcard(require(\"react\"));\n\nvar _propTypes = _interopRequireDefault(require(\"prop-types\"));\n\nvar _classnames = _interopRequireDefault(require(\"classnames\"));\n\nvar _tabbable = _interopRequireDefault(require(\"tabbable\"));\n\nvar _icon = require(\"../icon\");\n\nvar _popover = require(\"../popover\");\n\nvar _resize_observer = require(\"../observer/resize_observer\");\n\nvar _services = require(\"../../services\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }\n\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nvar transitionDirectionAndTypeToClassNameMap = {\n  next: {\n    in: 'euiContextMenuPanel-txInLeft',\n    out: 'euiContextMenuPanel-txOutLeft'\n  },\n  previous: {\n    in: 'euiContextMenuPanel-txInRight',\n    out: 'euiContextMenuPanel-txOutRight'\n  }\n};\n\nvar EuiContextMenuPanel =\n/*#__PURE__*/\nfunction (_Component) {\n  _inherits(EuiContextMenuPanel, _Component);\n\n  function EuiContextMenuPanel(props) {\n    var _this;\n\n    _classCallCheck(this, EuiContextMenuPanel);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(EuiContextMenuPanel).call(this, props));\n\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"_isMounted\", false);\n\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"backButton\", null);\n\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"content\", null);\n\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"panel\", null);\n\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"incrementFocusedItemIndex\", function (amount) {\n      var nextFocusedItemIndex;\n\n      if (_this.state.focusedItemIndex === undefined) {\n        // If this is the beginning of the user's keyboard navigation of the menu, then we'll focus\n        // either the first or last item.\n        nextFocusedItemIndex = amount < 0 ? _this.state.menuItems.length - 1 : 0;\n      } else {\n        nextFocusedItemIndex = _this.state.focusedItemIndex + amount;\n\n        if (nextFocusedItemIndex < 0) {\n          nextFocusedItemIndex = _this.state.menuItems.length - 1;\n        } else if (nextFocusedItemIndex === _this.state.menuItems.length) {\n          nextFocusedItemIndex = 0;\n        }\n      }\n\n      _this.setState({\n        focusedItemIndex: nextFocusedItemIndex\n      });\n    });\n\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"onKeyDown\", function (e) {\n      // If this panel contains items you can use the left arrow key to go back at any time.\n      // But if it doesn't contain items, then you have to focus on the back button specifically,\n      // since there could be content inside the panel which requires use of the left arrow key,\n      // e.g. text inputs.\n      var _this$props = _this.props,\n          items = _this$props.items,\n          showPreviousPanel = _this$props.showPreviousPanel;\n\n      if (items && items.length || document.activeElement === _this.backButton || document.activeElement === _this.panel) {\n        if (e.keyCode === _services.cascadingMenuKeyCodes.LEFT) {\n          if (showPreviousPanel) {\n            e.preventDefault();\n            e.stopPropagation();\n            showPreviousPanel();\n\n            if (_this.props.onUseKeyboardToNavigate) {\n              _this.props.onUseKeyboardToNavigate();\n            }\n          }\n        }\n      }\n\n      if (_this.props.items && _this.props.items.length) {\n        switch (e.keyCode) {\n          case _services.cascadingMenuKeyCodes.TAB:\n            // We need to sync up with the user if s/he is tabbing through the items.\n            var _focusedItemIndex = _this.state.menuItems.indexOf(document.activeElement);\n\n            _this.setState({\n              focusedItemIndex: _focusedItemIndex >= 0 && _focusedItemIndex < _this.state.menuItems.length ? _focusedItemIndex : undefined\n            });\n\n            break;\n\n          case _services.cascadingMenuKeyCodes.UP:\n            e.preventDefault();\n\n            _this.incrementFocusedItemIndex(-1);\n\n            if (_this.props.onUseKeyboardToNavigate) {\n              _this.props.onUseKeyboardToNavigate();\n            }\n\n            break;\n\n          case _services.cascadingMenuKeyCodes.DOWN:\n            e.preventDefault();\n\n            _this.incrementFocusedItemIndex(1);\n\n            if (_this.props.onUseKeyboardToNavigate) {\n              _this.props.onUseKeyboardToNavigate();\n            }\n\n            break;\n\n          case _services.cascadingMenuKeyCodes.RIGHT:\n            if (_this.props.showNextPanel) {\n              e.preventDefault();\n\n              _this.props.showNextPanel(_this.state.focusedItemIndex);\n\n              if (_this.props.onUseKeyboardToNavigate) {\n                _this.props.onUseKeyboardToNavigate();\n              }\n            }\n\n            break;\n\n          default:\n            break;\n        }\n      }\n    });\n\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"onTransitionComplete\", function () {\n      _this.setState({\n        isTransitioning: false\n      });\n\n      if (_this.props.onTransitionComplete) {\n        _this.props.onTransitionComplete();\n      }\n    });\n\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"menuItemRef\", function (index, node) {\n      // There's a weird bug where if you navigate to a panel without items, then this callback\n      // is still invoked, so we have to do a truthiness check.\n      if (node) {\n        // Store all menu items.\n        _this.state.menuItems[index] = node;\n      }\n    });\n\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"panelRef\", function (node) {\n      _this.panel = node;\n\n      _this.updateHeight();\n    });\n\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"contentRef\", function (node) {\n      _this.content = node;\n    });\n\n    _this.state = {\n      prevProps: {\n        items: _this.props.items\n      },\n      menuItems: [],\n      isTransitioning: Boolean(props.transitionType),\n      focusedItemIndex: props.initialFocusedItemIndex,\n      currentHeight: undefined\n    };\n    return _this;\n  }\n\n  _createClass(EuiContextMenuPanel, [{\n    key: \"updateFocus\",\n    value: function updateFocus() {\n      var _this2 = this;\n\n      // Give positioning time to render before focus is applied. Otherwise page jumps.\n      requestAnimationFrame(function () {\n        if (!_this2._isMounted) {\n          return;\n        } // If this panel has lost focus, then none of its content should be focused.\n\n\n        if (!_this2.props.hasFocus) {\n          if (_this2.panel && _this2.panel.contains(document.activeElement)) {\n            document.activeElement.blur();\n          }\n\n          return;\n        } // Setting focus while transitioning causes the animation to glitch, so we have to wait\n        // until it's finished before we focus anything.\n\n\n        if (_this2.state.isTransitioning) {\n          return;\n        } // If there aren't any items then this is probably a form or something.\n\n\n        if (!_this2.state.menuItems.length) {\n          // If we've already focused on something inside the panel, everything's fine.\n          if (_this2.panel && _this2.panel.contains(document.activeElement)) {\n            return;\n          } // Otherwise let's focus the first tabbable item and expedite input from the user.\n\n\n          if (_this2.content) {\n            var tabbableItems = (0, _tabbable.default)(_this2.content);\n\n            if (tabbableItems.length) {\n              tabbableItems[0].focus();\n            }\n          }\n\n          return;\n        } // If an item is focused, focus it.\n\n\n        if (_this2.state.focusedItemIndex !== undefined) {\n          _this2.state.menuItems[_this2.state.focusedItemIndex].focus();\n\n          return;\n        } // Focus on the panel as a last resort.\n\n\n        if (_this2.panel && !_this2.panel.contains(document.activeElement)) {\n          _this2.panel.focus();\n        }\n      });\n    }\n  }, {\n    key: \"componentDidMount\",\n    value: function componentDidMount() {\n      this.updateFocus();\n      this._isMounted = true;\n    }\n  }, {\n    key: \"componentWillUnmount\",\n    value: function componentWillUnmount() {\n      this._isMounted = false;\n    }\n  }, {\n    key: \"getWatchedPropsForItems\",\n    value: function getWatchedPropsForItems(items) {\n      // This lets us compare prevProps and nextProps among items so we can re-render if our items\n      // have changed.\n      var watchedItemProps = this.props.watchedItemProps; // Create fingerprint of all item's watched properties\n\n      if (items.length && watchedItemProps && watchedItemProps.length) {\n        return JSON.stringify(items.map(function (item) {\n          // Create object of item properties and values\n          var props = {\n            key: item.key\n          };\n          watchedItemProps.forEach(function (prop) {\n            props[prop] = item.props[prop];\n          });\n          return props;\n        }));\n      }\n\n      return null;\n    }\n  }, {\n    key: \"didItemsChange\",\n    value: function didItemsChange(prevItems, nextItems) {\n      // If the count of items has changed then update\n      if (prevItems.length !== nextItems.length) {\n        return true;\n      } // Check if any watched item properties changed by quick string comparison\n\n\n      if (this.getWatchedPropsForItems(nextItems) !== this.getWatchedPropsForItems(prevItems)) {\n        return true;\n      }\n    }\n  }, {\n    key: \"shouldComponentUpdate\",\n    value: function shouldComponentUpdate(nextProps, nextState) {\n      // Prevent calling `this.updateFocus()` below if we don't have to.\n      if (nextProps.hasFocus !== this.props.hasFocus) {\n        return true;\n      }\n\n      if (nextState.isTransitioning !== this.state.isTransitioning) {\n        return true;\n      }\n\n      if (nextState.focusedItemIndex !== this.state.focusedItemIndex) {\n        return true;\n      } // **\n      // this component should have either items or children,\n      // if there are items we can determine via `watchedItemProps` if we should update\n      // if there are children we can't know if they have changed so return true\n      // **\n\n\n      if (this.props.items && this.props.items.length > 0 || nextProps.items && nextProps.items.length > 0) {\n        if (this.didItemsChange(this.props.items, nextProps.items)) {\n          return true;\n        }\n      } // it's not possible (in any good way) to know if `children` has changed, assume they might have\n\n\n      if (this.props.children != null) {\n        return true;\n      }\n\n      return false;\n    }\n  }, {\n    key: \"updateHeight\",\n    value: function updateHeight() {\n      var currentHeight = this.panel ? this.panel.clientHeight : 0;\n\n      if (this.state.height !== currentHeight) {\n        if (this.props.onHeightChange) {\n          this.props.onHeightChange(currentHeight);\n          this.setState({\n            height: currentHeight\n          });\n        }\n      }\n    }\n  }, {\n    key: \"componentDidUpdate\",\n    value: function componentDidUpdate() {\n      this.updateFocus();\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      var _this3 = this;\n\n      var _this$props2 = this.props,\n          children = _this$props2.children,\n          className = _this$props2.className,\n          onClose = _this$props2.onClose,\n          title = _this$props2.title,\n          onHeightChange = _this$props2.onHeightChange,\n          transitionType = _this$props2.transitionType,\n          transitionDirection = _this$props2.transitionDirection,\n          onTransitionComplete = _this$props2.onTransitionComplete,\n          onUseKeyboardToNavigate = _this$props2.onUseKeyboardToNavigate,\n          hasFocus = _this$props2.hasFocus,\n          items = _this$props2.items,\n          watchedItemProps = _this$props2.watchedItemProps,\n          initialFocusedItemIndex = _this$props2.initialFocusedItemIndex,\n          showNextPanel = _this$props2.showNextPanel,\n          showPreviousPanel = _this$props2.showPreviousPanel,\n          rest = _objectWithoutProperties(_this$props2, [\"children\", \"className\", \"onClose\", \"title\", \"onHeightChange\", \"transitionType\", \"transitionDirection\", \"onTransitionComplete\", \"onUseKeyboardToNavigate\", \"hasFocus\", \"items\", \"watchedItemProps\", \"initialFocusedItemIndex\", \"showNextPanel\", \"showPreviousPanel\"]);\n\n      var panelTitle;\n\n      if (title) {\n        if (Boolean(onClose)) {\n          panelTitle = _react.default.createElement(\"button\", {\n            className: \"euiContextMenuPanelTitle\",\n            type: \"button\",\n            onClick: onClose,\n            ref: function ref(node) {\n              _this3.backButton = node;\n            },\n            \"data-test-subj\": \"contextMenuPanelTitleButton\"\n          }, _react.default.createElement(\"span\", {\n            className: \"euiContextMenu__itemLayout\"\n          }, _react.default.createElement(_icon.EuiIcon, {\n            type: \"arrowLeft\",\n            size: \"m\",\n            className: \"euiContextMenu__icon\"\n          }), _react.default.createElement(\"span\", {\n            className: \"euiContextMenu__text\"\n          }, title)));\n        } else {\n          panelTitle = _react.default.createElement(_popover.EuiPopoverTitle, null, _react.default.createElement(\"span\", {\n            className: \"euiContextMenu__itemLayout\"\n          }, title));\n        }\n      }\n\n      var classes = (0, _classnames.default)('euiContextMenuPanel', className, this.state.isTransitioning && transitionDirection && transitionType && transitionDirectionAndTypeToClassNameMap[transitionDirection] ? transitionDirectionAndTypeToClassNameMap[transitionDirection][transitionType] : undefined);\n      var content = items && items.length ? items.map(function (MenuItem, index) {\n        return (0, _react.cloneElement)(MenuItem, {\n          buttonRef: _this3.menuItemRef.bind(_this3, index)\n        });\n      }) : children;\n      return _react.default.createElement(\"div\", _extends({\n        ref: this.panelRef,\n        className: classes,\n        onKeyDown: this.onKeyDown,\n        tabIndex: 0,\n        onAnimationEnd: this.onTransitionComplete\n      }, rest), panelTitle, _react.default.createElement(\"div\", {\n        ref: this.contentRef\n      }, _react.default.createElement(_resize_observer.EuiResizeObserver, {\n        onResize: function onResize() {\n          return _this3.updateHeight();\n        }\n      }, function (resizeRef) {\n        return _react.default.createElement(\"div\", {\n          ref: resizeRef\n        }, content);\n      })));\n    }\n  }], [{\n    key: \"getDerivedStateFromProps\",\n    value: function getDerivedStateFromProps(nextProps, prevState) {\n      var needsUpdate = false;\n      var nextState = {}; // Clear refs to menuItems if we're getting new ones.\n\n      if (nextProps.items !== prevState.prevProps.items) {\n        needsUpdate = true;\n        nextState.menuItems = [];\n        nextState.prevProps = {\n          items: nextProps.items\n        };\n      }\n\n      if (nextProps.transitionType) {\n        needsUpdate = true;\n        nextState.isTransitioning = true;\n      }\n\n      if (needsUpdate) {\n        return nextState;\n      }\n\n      return null;\n    }\n  }]);\n\n  return EuiContextMenuPanel;\n}(_react.Component);\n\nexports.EuiContextMenuPanel = EuiContextMenuPanel;\n\n_defineProperty(EuiContextMenuPanel, \"defaultProps\", {\n  hasFocus: true,\n  items: []\n});\n\nEuiContextMenuPanel.propTypes = {\n  className: _propTypes.default.string,\n  \"aria-label\": _propTypes.default.string,\n  \"data-test-subj\": _propTypes.default.string,\n  hasFocus: _propTypes.default.bool,\n  initialFocusedItemIndex: _propTypes.default.number,\n  items: _propTypes.default.arrayOf(_propTypes.default.element.isRequired),\n  onClose: _propTypes.default.any,\n  onHeightChange: _propTypes.default.func,\n  onTransitionComplete: _propTypes.default.any,\n  onUseKeyboardToNavigate: _propTypes.default.any,\n  showNextPanel: _propTypes.default.func,\n  showPreviousPanel: _propTypes.default.any,\n  title: _propTypes.default.node,\n  transitionDirection: _propTypes.default.oneOf([\"next\", \"previous\"]),\n  transitionType: _propTypes.default.oneOf([\"in\", \"out\"]),\n  watchedItemProps: _propTypes.default.arrayOf(_propTypes.default.string.isRequired)\n};\nEuiContextMenuPanel.__docgenInfo = {\n  \"description\": \"\",\n  \"methods\": [{\n    \"name\": \"incrementFocusedItemIndex\",\n    \"docblock\": null,\n    \"modifiers\": [],\n    \"params\": [{\n      \"name\": \"amount\",\n      \"type\": null\n    }],\n    \"returns\": null\n  }, {\n    \"name\": \"onKeyDown\",\n    \"docblock\": null,\n    \"modifiers\": [],\n    \"params\": [{\n      \"name\": \"e\",\n      \"type\": null\n    }],\n    \"returns\": null\n  }, {\n    \"name\": \"updateFocus\",\n    \"docblock\": null,\n    \"modifiers\": [],\n    \"params\": [],\n    \"returns\": null\n  }, {\n    \"name\": \"onTransitionComplete\",\n    \"docblock\": null,\n    \"modifiers\": [],\n    \"params\": [],\n    \"returns\": null\n  }, {\n    \"name\": \"getDerivedStateFromProps\",\n    \"docblock\": null,\n    \"modifiers\": [\"static\"],\n    \"params\": [{\n      \"name\": \"nextProps\",\n      \"type\": null\n    }, {\n      \"name\": \"prevState\",\n      \"type\": null\n    }],\n    \"returns\": null\n  }, {\n    \"name\": \"getWatchedPropsForItems\",\n    \"docblock\": null,\n    \"modifiers\": [],\n    \"params\": [{\n      \"name\": \"items\",\n      \"type\": null\n    }],\n    \"returns\": null\n  }, {\n    \"name\": \"didItemsChange\",\n    \"docblock\": null,\n    \"modifiers\": [],\n    \"params\": [{\n      \"name\": \"prevItems\",\n      \"type\": null\n    }, {\n      \"name\": \"nextItems\",\n      \"type\": null\n    }],\n    \"returns\": null\n  }, {\n    \"name\": \"updateHeight\",\n    \"docblock\": null,\n    \"modifiers\": [],\n    \"params\": [],\n    \"returns\": null\n  }, {\n    \"name\": \"menuItemRef\",\n    \"docblock\": null,\n    \"modifiers\": [],\n    \"params\": [{\n      \"name\": \"index\",\n      \"type\": null\n    }, {\n      \"name\": \"node\",\n      \"type\": null\n    }],\n    \"returns\": null\n  }, {\n    \"name\": \"panelRef\",\n    \"docblock\": null,\n    \"modifiers\": [],\n    \"params\": [{\n      \"name\": \"node\",\n      \"type\": null\n    }],\n    \"returns\": null\n  }, {\n    \"name\": \"contentRef\",\n    \"docblock\": null,\n    \"modifiers\": [],\n    \"params\": [{\n      \"name\": \"node\",\n      \"type\": null\n    }],\n    \"returns\": null\n  }],\n  \"displayName\": \"EuiContextMenuPanel\",\n  \"props\": {\n    \"hasFocus\": {\n      \"defaultValue\": {\n        \"value\": \"true\",\n        \"computed\": false\n      },\n      \"type\": {\n        \"name\": \"bool\"\n      },\n      \"required\": false,\n      \"description\": \"\"\n    },\n    \"items\": {\n      \"defaultValue\": {\n        \"value\": \"[]\",\n        \"computed\": false\n      },\n      \"type\": {\n        \"name\": \"arrayOf\",\n        \"value\": {\n          \"name\": \"element\"\n        }\n      },\n      \"required\": false,\n      \"description\": \"\"\n    },\n    \"className\": {\n      \"type\": {\n        \"name\": \"custom\",\n        \"raw\": \"_propTypes.default.string\"\n      },\n      \"required\": false,\n      \"description\": \"\"\n    },\n    \"aria-label\": {\n      \"type\": {\n        \"name\": \"custom\",\n        \"raw\": \"_propTypes.default.string\"\n      },\n      \"required\": false,\n      \"description\": \"\"\n    },\n    \"data-test-subj\": {\n      \"type\": {\n        \"name\": \"custom\",\n        \"raw\": \"_propTypes.default.string\"\n      },\n      \"required\": false,\n      \"description\": \"\"\n    },\n    \"initialFocusedItemIndex\": {\n      \"type\": {\n        \"name\": \"number\"\n      },\n      \"required\": false,\n      \"description\": \"\"\n    },\n    \"onClose\": {\n      \"type\": {\n        \"name\": \"any\"\n      },\n      \"required\": false,\n      \"description\": \"\"\n    },\n    \"onHeightChange\": {\n      \"type\": {\n        \"name\": \"func\"\n      },\n      \"required\": false,\n      \"description\": \"\"\n    },\n    \"onTransitionComplete\": {\n      \"type\": {\n        \"name\": \"any\"\n      },\n      \"required\": false,\n      \"description\": \"\"\n    },\n    \"onUseKeyboardToNavigate\": {\n      \"type\": {\n        \"name\": \"any\"\n      },\n      \"required\": false,\n      \"description\": \"\"\n    },\n    \"showNextPanel\": {\n      \"type\": {\n        \"name\": \"func\"\n      },\n      \"required\": false,\n      \"description\": \"\"\n    },\n    \"showPreviousPanel\": {\n      \"type\": {\n        \"name\": \"any\"\n      },\n      \"required\": false,\n      \"description\": \"\"\n    },\n    \"title\": {\n      \"type\": {\n        \"name\": \"node\"\n      },\n      \"required\": false,\n      \"description\": \"\"\n    },\n    \"transitionDirection\": {\n      \"type\": {\n        \"name\": \"enum\",\n        \"value\": [{\n          \"value\": \"\\\"next\\\"\",\n          \"computed\": false\n        }, {\n          \"value\": \"\\\"previous\\\"\",\n          \"computed\": false\n        }]\n      },\n      \"required\": false,\n      \"description\": \"\"\n    },\n    \"transitionType\": {\n      \"type\": {\n        \"name\": \"enum\",\n        \"value\": [{\n          \"value\": \"\\\"in\\\"\",\n          \"computed\": false\n        }, {\n          \"value\": \"\\\"out\\\"\",\n          \"computed\": false\n        }]\n      },\n      \"required\": false,\n      \"description\": \"\"\n    },\n    \"watchedItemProps\": {\n      \"type\": {\n        \"name\": \"arrayOf\",\n        \"value\": {\n          \"name\": \"string\"\n        }\n      },\n      \"required\": false,\n      \"description\": \"\"\n    }\n  }\n};",{"version":3,"sources":["/Users/chanderprall/projects/eui/src/components/context_menu/context_menu_panel.tsx"],"names":["transitionDirectionAndTypeToClassNameMap","next","in","out","previous","EuiContextMenuPanel","props","amount","nextFocusedItemIndex","state","focusedItemIndex","undefined","menuItems","length","setState","e","items","showPreviousPanel","document","activeElement","backButton","panel","keyCode","cascadingMenuKeyCodes","LEFT","preventDefault","stopPropagation","onUseKeyboardToNavigate","TAB","indexOf","UP","incrementFocusedItemIndex","DOWN","RIGHT","showNextPanel","isTransitioning","onTransitionComplete","index","node","updateHeight","content","prevProps","Boolean","transitionType","initialFocusedItemIndex","currentHeight","requestAnimationFrame","_isMounted","hasFocus","contains","blur","tabbableItems","focus","updateFocus","watchedItemProps","JSON","stringify","map","item","key","forEach","prop","prevItems","nextItems","getWatchedPropsForItems","nextProps","nextState","didItemsChange","children","clientHeight","height","onHeightChange","className","onClose","title","transitionDirection","rest","panelTitle","classes","MenuItem","buttonRef","menuItemRef","bind","panelRef","onKeyDown","contentRef","resizeRef","prevState","needsUpdate","Component"],"mappings":"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","sourcesContent":["import React, { cloneElement, Component } from 'react';\nimport PropTypes from \"prop-types\";\nimport classNames from 'classnames';\nimport tabbable from 'tabbable';\nimport { EuiIcon } from '../icon';\nimport { EuiPopoverTitle } from '../popover';\nimport { EuiResizeObserver } from '../observer/resize_observer';\nimport { cascadingMenuKeyCodes } from '../../services';\nvar transitionDirectionAndTypeToClassNameMap = {\n  next: {\n    in: 'euiContextMenuPanel-txInLeft',\n    out: 'euiContextMenuPanel-txOutLeft'\n  },\n  previous: {\n    in: 'euiContextMenuPanel-txInRight',\n    out: 'euiContextMenuPanel-txOutRight'\n  }\n};\nexport class EuiContextMenuPanel extends Component {\n  static defaultProps = {\n    hasFocus: true,\n    items: []\n  };\n  _isMounted = false;\n  backButton = null;\n  content = null;\n  panel = null;\n\n  constructor(props) {\n    super(props);\n    this.state = {\n      prevProps: {\n        items: this.props.items\n      },\n      menuItems: [],\n      isTransitioning: Boolean(props.transitionType),\n      focusedItemIndex: props.initialFocusedItemIndex,\n      currentHeight: undefined\n    };\n  }\n\n  incrementFocusedItemIndex = amount => {\n    let nextFocusedItemIndex;\n\n    if (this.state.focusedItemIndex === undefined) {\n      // If this is the beginning of the user's keyboard navigation of the menu, then we'll focus\n      // either the first or last item.\n      nextFocusedItemIndex = amount < 0 ? this.state.menuItems.length - 1 : 0;\n    } else {\n      nextFocusedItemIndex = this.state.focusedItemIndex + amount;\n\n      if (nextFocusedItemIndex < 0) {\n        nextFocusedItemIndex = this.state.menuItems.length - 1;\n      } else if (nextFocusedItemIndex === this.state.menuItems.length) {\n        nextFocusedItemIndex = 0;\n      }\n    }\n\n    this.setState({\n      focusedItemIndex: nextFocusedItemIndex\n    });\n  };\n  onKeyDown = e => {\n    // If this panel contains items you can use the left arrow key to go back at any time.\n    // But if it doesn't contain items, then you have to focus on the back button specifically,\n    // since there could be content inside the panel which requires use of the left arrow key,\n    // e.g. text inputs.\n    const {\n      items,\n      showPreviousPanel\n    } = this.props;\n\n    if (items && items.length || document.activeElement === this.backButton || document.activeElement === this.panel) {\n      if (e.keyCode === cascadingMenuKeyCodes.LEFT) {\n        if (showPreviousPanel) {\n          e.preventDefault();\n          e.stopPropagation();\n          showPreviousPanel();\n\n          if (this.props.onUseKeyboardToNavigate) {\n            this.props.onUseKeyboardToNavigate();\n          }\n        }\n      }\n    }\n\n    if (this.props.items && this.props.items.length) {\n      switch (e.keyCode) {\n        case cascadingMenuKeyCodes.TAB:\n          // We need to sync up with the user if s/he is tabbing through the items.\n          const focusedItemIndex = this.state.menuItems.indexOf(document.activeElement);\n          this.setState({\n            focusedItemIndex: focusedItemIndex >= 0 && focusedItemIndex < this.state.menuItems.length ? focusedItemIndex : undefined\n          });\n          break;\n\n        case cascadingMenuKeyCodes.UP:\n          e.preventDefault();\n          this.incrementFocusedItemIndex(-1);\n\n          if (this.props.onUseKeyboardToNavigate) {\n            this.props.onUseKeyboardToNavigate();\n          }\n\n          break;\n\n        case cascadingMenuKeyCodes.DOWN:\n          e.preventDefault();\n          this.incrementFocusedItemIndex(1);\n\n          if (this.props.onUseKeyboardToNavigate) {\n            this.props.onUseKeyboardToNavigate();\n          }\n\n          break;\n\n        case cascadingMenuKeyCodes.RIGHT:\n          if (this.props.showNextPanel) {\n            e.preventDefault();\n            this.props.showNextPanel(this.state.focusedItemIndex);\n\n            if (this.props.onUseKeyboardToNavigate) {\n              this.props.onUseKeyboardToNavigate();\n            }\n          }\n\n          break;\n\n        default:\n          break;\n      }\n    }\n  };\n\n  updateFocus() {\n    // Give positioning time to render before focus is applied. Otherwise page jumps.\n    requestAnimationFrame(() => {\n      if (!this._isMounted) {\n        return;\n      } // If this panel has lost focus, then none of its content should be focused.\n\n\n      if (!this.props.hasFocus) {\n        if (this.panel && this.panel.contains(document.activeElement)) {\n          document.activeElement.blur();\n        }\n\n        return;\n      } // Setting focus while transitioning causes the animation to glitch, so we have to wait\n      // until it's finished before we focus anything.\n\n\n      if (this.state.isTransitioning) {\n        return;\n      } // If there aren't any items then this is probably a form or something.\n\n\n      if (!this.state.menuItems.length) {\n        // If we've already focused on something inside the panel, everything's fine.\n        if (this.panel && this.panel.contains(document.activeElement)) {\n          return;\n        } // Otherwise let's focus the first tabbable item and expedite input from the user.\n\n\n        if (this.content) {\n          const tabbableItems = tabbable(this.content);\n\n          if (tabbableItems.length) {\n            tabbableItems[0].focus();\n          }\n        }\n\n        return;\n      } // If an item is focused, focus it.\n\n\n      if (this.state.focusedItemIndex !== undefined) {\n        this.state.menuItems[this.state.focusedItemIndex].focus();\n        return;\n      } // Focus on the panel as a last resort.\n\n\n      if (this.panel && !this.panel.contains(document.activeElement)) {\n        this.panel.focus();\n      }\n    });\n  }\n\n  onTransitionComplete = () => {\n    this.setState({\n      isTransitioning: false\n    });\n\n    if (this.props.onTransitionComplete) {\n      this.props.onTransitionComplete();\n    }\n  };\n\n  componentDidMount() {\n    this.updateFocus();\n    this._isMounted = true;\n  }\n\n  componentWillUnmount() {\n    this._isMounted = false;\n  }\n\n  static getDerivedStateFromProps(nextProps, prevState) {\n    let needsUpdate = false;\n    const nextState = {}; // Clear refs to menuItems if we're getting new ones.\n\n    if (nextProps.items !== prevState.prevProps.items) {\n      needsUpdate = true;\n      nextState.menuItems = [];\n      nextState.prevProps = {\n        items: nextProps.items\n      };\n    }\n\n    if (nextProps.transitionType) {\n      needsUpdate = true;\n      nextState.isTransitioning = true;\n    }\n\n    if (needsUpdate) {\n      return nextState;\n    }\n\n    return null;\n  }\n\n  getWatchedPropsForItems(items) {\n    // This lets us compare prevProps and nextProps among items so we can re-render if our items\n    // have changed.\n    const {\n      watchedItemProps\n    } = this.props; // Create fingerprint of all item's watched properties\n\n    if (items.length && watchedItemProps && watchedItemProps.length) {\n      return JSON.stringify(items.map(item => {\n        // Create object of item properties and values\n        const props = {\n          key: item.key\n        };\n        watchedItemProps.forEach(prop => {\n          props[prop] = item.props[prop];\n        });\n        return props;\n      }));\n    }\n\n    return null;\n  }\n\n  didItemsChange(prevItems, nextItems) {\n    // If the count of items has changed then update\n    if (prevItems.length !== nextItems.length) {\n      return true;\n    } // Check if any watched item properties changed by quick string comparison\n\n\n    if (this.getWatchedPropsForItems(nextItems) !== this.getWatchedPropsForItems(prevItems)) {\n      return true;\n    }\n  }\n\n  shouldComponentUpdate(nextProps, nextState) {\n    // Prevent calling `this.updateFocus()` below if we don't have to.\n    if (nextProps.hasFocus !== this.props.hasFocus) {\n      return true;\n    }\n\n    if (nextState.isTransitioning !== this.state.isTransitioning) {\n      return true;\n    }\n\n    if (nextState.focusedItemIndex !== this.state.focusedItemIndex) {\n      return true;\n    } // **\n    // this component should have either items or children,\n    // if there are items we can determine via `watchedItemProps` if we should update\n    // if there are children we can't know if they have changed so return true\n    // **\n\n\n    if (this.props.items && this.props.items.length > 0 || nextProps.items && nextProps.items.length > 0) {\n      if (this.didItemsChange(this.props.items, nextProps.items)) {\n        return true;\n      }\n    } // it's not possible (in any good way) to know if `children` has changed, assume they might have\n\n\n    if (this.props.children != null) {\n      return true;\n    }\n\n    return false;\n  }\n\n  updateHeight() {\n    const currentHeight = this.panel ? this.panel.clientHeight : 0;\n\n    if (this.state.height !== currentHeight) {\n      if (this.props.onHeightChange) {\n        this.props.onHeightChange(currentHeight);\n        this.setState({\n          height: currentHeight\n        });\n      }\n    }\n  }\n\n  componentDidUpdate() {\n    this.updateFocus();\n  }\n\n  menuItemRef = (index, node) => {\n    // There's a weird bug where if you navigate to a panel without items, then this callback\n    // is still invoked, so we have to do a truthiness check.\n    if (node) {\n      // Store all menu items.\n      this.state.menuItems[index] = node;\n    }\n  };\n  panelRef = node => {\n    this.panel = node;\n    this.updateHeight();\n  };\n  contentRef = node => {\n    this.content = node;\n  };\n\n  render() {\n    const {\n      children,\n      className,\n      onClose,\n      title,\n      onHeightChange,\n      transitionType,\n      transitionDirection,\n      onTransitionComplete,\n      onUseKeyboardToNavigate,\n      hasFocus,\n      items,\n      watchedItemProps,\n      initialFocusedItemIndex,\n      showNextPanel,\n      showPreviousPanel,\n      ...rest\n    } = this.props;\n    let panelTitle;\n\n    if (title) {\n      if (Boolean(onClose)) {\n        panelTitle = <button className=\"euiContextMenuPanelTitle\" type=\"button\" onClick={onClose} ref={node => {\n          this.backButton = node;\n        }} data-test-subj=\"contextMenuPanelTitleButton\">\n            <span className=\"euiContextMenu__itemLayout\">\n              <EuiIcon type=\"arrowLeft\" size=\"m\" className=\"euiContextMenu__icon\" />\n\n              <span className=\"euiContextMenu__text\">{title}</span>\n            </span>\n          </button>;\n      } else {\n        panelTitle = <EuiPopoverTitle>\n            <span className=\"euiContextMenu__itemLayout\">{title}</span>\n          </EuiPopoverTitle>;\n      }\n    }\n\n    const classes = classNames('euiContextMenuPanel', className, this.state.isTransitioning && transitionDirection && transitionType && transitionDirectionAndTypeToClassNameMap[transitionDirection] ? transitionDirectionAndTypeToClassNameMap[transitionDirection][transitionType] : undefined);\n    const content = items && items.length ? items.map((MenuItem, index) => cloneElement(MenuItem, {\n      buttonRef: this.menuItemRef.bind(this, index)\n    })) : children;\n    return <div ref={this.panelRef} className={classes} onKeyDown={this.onKeyDown} tabIndex={0} onAnimationEnd={this.onTransitionComplete} {...rest}>\n        {panelTitle}\n\n        <div ref={this.contentRef}>\n          <EuiResizeObserver onResize={() => this.updateHeight()}>\n            {resizeRef => <div ref={resizeRef}>{content}</div>}\n          </EuiResizeObserver>\n        </div>\n      </div>;\n  }\n\n}\nEuiContextMenuPanel.propTypes = {\n  className: _propTypes.default.string,\n  \"aria-label\": _propTypes.default.string,\n  \"data-test-subj\": _propTypes.default.string,\n  hasFocus: PropTypes.bool,\n  initialFocusedItemIndex: PropTypes.number,\n  items: PropTypes.arrayOf(PropTypes.element.isRequired),\n  onClose: PropTypes.any,\n  onHeightChange: PropTypes.func,\n  onTransitionComplete: PropTypes.any,\n  onUseKeyboardToNavigate: PropTypes.any,\n  showNextPanel: PropTypes.func,\n  showPreviousPanel: PropTypes.any,\n  title: PropTypes.node,\n  transitionDirection: PropTypes.oneOf([\"next\", \"previous\"]),\n  transitionType: PropTypes.oneOf([\"in\", \"out\"]),\n  watchedItemProps: PropTypes.arrayOf(PropTypes.string.isRequired)\n};"]}]}