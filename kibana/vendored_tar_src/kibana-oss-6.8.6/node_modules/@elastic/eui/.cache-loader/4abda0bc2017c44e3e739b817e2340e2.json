{"remainingRequest":"/Users/chanderprall/projects/eui/node_modules/babel-loader/lib/index.js!/Users/chanderprall/projects/eui/src/components/search_bar/query/ast.js","dependencies":[{"path":"/Users/chanderprall/projects/eui/src/components/search_bar/query/ast.js","mtime":1566846257328},{"path":"/Users/chanderprall/projects/eui/.babelrc.js","mtime":1565204168946},{"path":"/Users/chanderprall/projects/eui/node_modules/cache-loader/dist/cjs.js","mtime":1555436064329},{"path":"/Users/chanderprall/projects/eui/node_modules/babel-loader/lib/index.js","mtime":1543517280769}],"contextDependencies":[],"result":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.AST = exports._AST = exports.Operator = exports.Match = void 0;\n\nrequire(\"core-js/modules/es6.string.iterator\");\n\nrequire(\"core-js/modules/es6.array.from\");\n\nrequire(\"core-js/modules/es6.regexp.to-string\");\n\nrequire(\"core-js/modules/es7.symbol.async-iterator\");\n\nrequire(\"core-js/modules/es6.symbol\");\n\nrequire(\"core-js/modules/es7.object.values\");\n\nrequire(\"core-js/modules/web.dom.iterable\");\n\nrequire(\"core-js/modules/es6.array.iterator\");\n\nrequire(\"core-js/modules/es6.object.keys\");\n\nrequire(\"core-js/modules/es6.array.find\");\n\nrequire(\"core-js/modules/es6.regexp.match\");\n\nrequire(\"core-js/modules/es6.object.freeze\");\n\nvar _predicate = require(\"../../../services/predicate\");\n\nvar _date_value = require(\"./date_value\");\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }\n\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance\"); }\n\nfunction _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === \"[object Arguments]\") return Array.from(iter); }\n\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nvar Match = Object.freeze({\n  MUST: 'must',\n  MUST_NOT: 'must_not',\n  isMust: function isMust(match) {\n    return match === Match.MUST;\n  },\n  isMustClause: function isMustClause(clause) {\n    return Match.isMust(clause.match);\n  }\n});\nexports.Match = Match;\nvar Operator = Object.freeze({\n  EQ: 'eq',\n  EXACT: 'exact',\n  GT: 'gt',\n  GTE: 'gte',\n  LT: 'lt',\n  LTE: 'lte',\n  isEQ: function isEQ(match) {\n    return match === Operator.EQ;\n  },\n  isEQClause: function isEQClause(clause) {\n    return Operator.isEQ(clause.operator);\n  },\n  isEXACT: function isEXACT(match) {\n    return match === Operator.EXACT;\n  },\n  isEXACTClause: function isEXACTClause(clause) {\n    return Operator.isEXACT(clause.operator);\n  },\n  isRange: function isRange(match) {\n    return Operator.isGT(match) || Operator.isGTE(match) || Operator.isLT(match) || Operator.isLTE(match);\n  },\n  isRangeClause: function isRangeClause(clause) {\n    return Operator.isRange(clause.operator);\n  },\n  isGT: function isGT(match) {\n    return match === Operator.GT;\n  },\n  isGTClause: function isGTClause(clause) {\n    return Operator.isGT(clause.operator);\n  },\n  isGTE: function isGTE(match) {\n    return match === Operator.GTE;\n  },\n  isGTEClause: function isGTEClause(clause) {\n    return Operator.isGTE(clause.operator);\n  },\n  isLT: function isLT(match) {\n    return match === Operator.LT;\n  },\n  isLTClause: function isLTClause(clause) {\n    return Operator.isLT(clause.operator);\n  },\n  isLTE: function isLTE(match) {\n    return match === Operator.LTE;\n  },\n  isLTEClause: function isLTEClause(clause) {\n    return Operator.isLTE(clause.operator);\n  }\n});\nexports.Operator = Operator;\nvar Term = Object.freeze({\n  TYPE: 'term',\n  isInstance: function isInstance(clause) {\n    return clause.type === Term.TYPE;\n  },\n  must: function must(value) {\n    return {\n      type: Term.TYPE,\n      value: value,\n      match: Match.MUST\n    };\n  },\n  mustNot: function mustNot(value) {\n    return {\n      type: Term.TYPE,\n      value: value,\n      match: Match.MUST_NOT\n    };\n  }\n});\nvar Group = Object.freeze({\n  TYPE: 'group',\n  isInstance: function isInstance(clause) {\n    return clause.type === Group.TYPE;\n  },\n  must: function must(value) {\n    return {\n      type: Group.TYPE,\n      value: value,\n      match: Match.MUST\n    };\n  },\n  mustNot: function mustNot(value) {\n    return {\n      type: Group.TYPE,\n      value: value,\n      match: Match.MUST_NOT\n    };\n  }\n});\nvar Field = Object.freeze({\n  TYPE: 'field',\n  isInstance: function isInstance(clause) {\n    return clause.type === Field.TYPE;\n  },\n  must: {\n    eq: function eq(field, value) {\n      return {\n        type: Field.TYPE,\n        field: field,\n        value: value,\n        match: Match.MUST,\n        operator: Operator.EQ\n      };\n    },\n    exact: function exact(field, value) {\n      return {\n        type: Field.TYPE,\n        field: field,\n        value: value,\n        match: Match.MUST,\n        operator: Operator.EXACT\n      };\n    },\n    gt: function gt(field, value) {\n      return {\n        type: Field.TYPE,\n        field: field,\n        value: value,\n        match: Match.MUST,\n        operator: Operator.GT\n      };\n    },\n    gte: function gte(field, value) {\n      return {\n        type: Field.TYPE,\n        field: field,\n        value: value,\n        match: Match.MUST,\n        operator: Operator.GTE\n      };\n    },\n    lt: function lt(field, value) {\n      return {\n        type: Field.TYPE,\n        field: field,\n        value: value,\n        match: Match.MUST,\n        operator: Operator.LT\n      };\n    },\n    lte: function lte(field, value) {\n      return {\n        type: Field.TYPE,\n        field: field,\n        value: value,\n        match: Match.MUST,\n        operator: Operator.LTE\n      };\n    }\n  },\n  mustNot: {\n    eq: function eq(field, value) {\n      return {\n        type: Field.TYPE,\n        field: field,\n        value: value,\n        match: Match.MUST_NOT,\n        operator: Operator.EQ\n      };\n    },\n    exact: function exact(field, value) {\n      return {\n        type: Field.TYPE,\n        field: field,\n        value: value,\n        match: Match.MUST_NOT,\n        operator: Operator.EXACT\n      };\n    },\n    gt: function gt(field, value) {\n      return {\n        type: Field.TYPE,\n        field: field,\n        value: value,\n        match: Match.MUST_NOT,\n        operator: Operator.GT\n      };\n    },\n    gte: function gte(field, value) {\n      return {\n        type: Field.TYPE,\n        field: field,\n        value: value,\n        match: Match.MUST_NOT,\n        operator: Operator.GTE\n      };\n    },\n    lt: function lt(field, value) {\n      return {\n        type: Field.TYPE,\n        field: field,\n        value: value,\n        match: Match.MUST_NOT,\n        operator: Operator.LT\n      };\n    },\n    lte: function lte(field, value) {\n      return {\n        type: Field.TYPE,\n        field: field,\n        value: value,\n        match: Match.MUST_NOT,\n        operator: Operator.LTE\n      };\n    }\n  }\n});\nvar Is = Object.freeze({\n  TYPE: 'is',\n  isInstance: function isInstance(clause) {\n    return clause.type === Is.TYPE;\n  },\n  must: function must(flag) {\n    return {\n      type: Is.TYPE,\n      flag: flag,\n      match: Match.MUST\n    };\n  },\n  mustNot: function mustNot(flag) {\n    return {\n      type: Is.TYPE,\n      flag: flag,\n      match: Match.MUST_NOT\n    };\n  }\n});\n\nvar valuesEqual = function valuesEqual(v1, v2) {\n  if ((0, _date_value.isDateValue)(v1)) {\n    return (0, _date_value.dateValuesEqual)(v1, v2);\n  }\n\n  return v1 === v2;\n};\n\nvar arrayIncludesValue = function arrayIncludesValue(array, value) {\n  return array.some(function (item) {\n    return valuesEqual(item, value);\n  });\n};\n/**\n * The AST structure is an array of clauses. There are 3 types of clauses that are supported:\n *\n * :term:\n * Holds a VALUE and an OCCUR. The OCCUR indicates whether the value must match or must not match. Default\n * clauses are not associated with any specific field - when executing the search, one can specify what are\n * the default fields that the default clauses will be matched against.\n *\n * :field:\n * Like the `term` clause, holds a VALUE and an MATCH, but this clause also specifies the field that the\n * value will be matched against.\n *\n * :is:\n * Holds a FLAG and indicates whether this flag must be applied or must not be applied. Typically this clause\n * matches against boolean values of a record (e.g. \"is:online\", \"is:internal\", \"is:on\", etc..)\n *\n * This AST is immutable - every \"mutating\" operation returns a newly mutated AST.\n */\n\n\nvar _AST =\n/*#__PURE__*/\nfunction () {\n  _createClass(_AST, null, [{\n    key: \"create\",\n    value: function create(clauses) {\n      return new _AST(clauses);\n    }\n  }]);\n\n  function _AST() {\n    var clauses = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n\n    _classCallCheck(this, _AST);\n\n    this._clauses = clauses;\n    this._indexedClauses = clauses.reduce(function (map, clause) {\n      switch (clause.type) {\n        case Field.TYPE:\n          if (!map.field[clause.field]) {\n            map.field[clause.field] = [];\n          }\n\n          map.field[clause.field].push(clause);\n          return map;\n\n        case Is.TYPE:\n          map.is[clause.flag] = clause;\n          return map;\n\n        case Term.TYPE:\n          map.term.push(clause);\n          return map;\n\n        case Group.TYPE:\n          map.group.push(clause);\n          return map;\n\n        default:\n          throw new Error(\"Unknown query clause type [\".concat(clause.type, \"]\"));\n      }\n    }, {\n      field: {},\n      is: {},\n      term: [],\n      group: []\n    });\n  }\n\n  _createClass(_AST, [{\n    key: \"getTermClauses\",\n    value: function getTermClauses() {\n      return this._indexedClauses.term;\n    }\n  }, {\n    key: \"getTermClause\",\n    value: function getTermClause(value) {\n      var clauses = this.getTermClauses();\n      return clauses.find(function (clause) {\n        return valuesEqual(clause.value, value);\n      });\n    }\n  }, {\n    key: \"getFieldNames\",\n    value: function getFieldNames() {\n      return Object.keys(this._indexedClauses.field);\n    }\n  }, {\n    key: \"getFieldClauses\",\n    value: function getFieldClauses() {\n      var field = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : undefined;\n      return field ? this._indexedClauses.field[field] : this._clauses.filter(Field.isInstance);\n    }\n  }, {\n    key: \"getFieldClause\",\n    value: function getFieldClause(field, predicate) {\n      var clauses = this.getFieldClauses(field);\n\n      if (clauses) {\n        return clauses.find(predicate);\n      }\n    }\n  }, {\n    key: \"hasOrFieldClause\",\n    value: function hasOrFieldClause(field) {\n      var value = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;\n      var clauses = this.getFieldClause(field, function (clause) {\n        return (0, _predicate.isArray)(clause.value);\n      });\n\n      if (!clauses) {\n        return false;\n      }\n\n      return (0, _predicate.isNil)(value) || clauses.some(function (clause) {\n        return arrayIncludesValue(clause.value, value);\n      });\n    }\n  }, {\n    key: \"getOrFieldClause\",\n    value: function getOrFieldClause(field) {\n      var value = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;\n      return this.getFieldClause(field, function (clause) {\n        return (0, _predicate.isArray)(clause.value) && ((0, _predicate.isNil)(value) || arrayIncludesValue(clause.value, value));\n      });\n    }\n  }, {\n    key: \"addOrFieldValue\",\n    value: function addOrFieldValue(field, value) {\n      var must = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n      var operator = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : Operator.EQ;\n      var existingClause = this.getOrFieldClause(field);\n\n      if (!existingClause) {\n        var newClause = must ? Field.must[operator](field, [value]) : Field.mustNot[operator](field, [value]);\n        return new _AST(_toConsumableArray(this._clauses).concat([newClause]));\n      }\n\n      var clauses = this._clauses.map(function (clause) {\n        if (clause === existingClause) {\n          clause.value.push(value);\n        }\n\n        return clause;\n      });\n\n      return new _AST(clauses);\n    }\n  }, {\n    key: \"removeOrFieldValue\",\n    value: function removeOrFieldValue(field, value) {\n      var existingClause = this.getOrFieldClause(field, value);\n\n      if (!existingClause) {\n        return new _AST(_toConsumableArray(this._clauses));\n      }\n\n      var clauses = this._clauses.reduce(function (clauses, clause) {\n        if (clause !== existingClause) {\n          clauses.push(clause);\n          return clauses;\n        }\n\n        var filteredValue = clause.value.filter(function (val) {\n          return !valuesEqual(val, value);\n        });\n\n        if (filteredValue.length === 0) {\n          return clauses;\n        }\n\n        clauses.push(_objectSpread({}, clause, {\n          value: filteredValue\n        }));\n        return clauses;\n      }, []);\n\n      return new _AST(clauses);\n    }\n  }, {\n    key: \"removeOrFieldClauses\",\n    value: function removeOrFieldClauses(field) {\n      var clauses = this._clauses.filter(function (clause) {\n        return !Field.isInstance(clause) || clause.field !== field || !(0, _predicate.isArray)(clause.value);\n      });\n\n      return new _AST(clauses);\n    }\n  }, {\n    key: \"hasSimpleFieldClause\",\n    value: function hasSimpleFieldClause(field) {\n      var value = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;\n      var clauses = this.getFieldClause(field, function (clause) {\n        return !(0, _predicate.isArray)(clause.value);\n      });\n\n      if (!clauses) {\n        return false;\n      }\n\n      return (0, _predicate.isNil)(value) || clauses.some(function (clause) {\n        return valuesEqual(clause.value, value);\n      });\n    }\n  }, {\n    key: \"getSimpleFieldClause\",\n    value: function getSimpleFieldClause(field) {\n      var value = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;\n      return this.getFieldClause(field, function (clause) {\n        return !(0, _predicate.isArray)(clause.value) && ((0, _predicate.isNil)(value) || valuesEqual(clause.value, value));\n      });\n    }\n  }, {\n    key: \"addSimpleFieldValue\",\n    value: function addSimpleFieldValue(field, value) {\n      var must = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n      var operator = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : Operator.EQ;\n      var clause = must ? Field.must[operator](field, value) : Field.mustNot[operator](field, value);\n      return this.addClause(clause);\n    }\n  }, {\n    key: \"removeSimpleFieldValue\",\n    value: function removeSimpleFieldValue(field, value) {\n      var existingClause = this.getSimpleFieldClause(field, value);\n\n      if (!existingClause) {\n        return new _AST(_toConsumableArray(this._clauses));\n      }\n\n      var clauses = this._clauses.filter(function (clause) {\n        return clause !== existingClause;\n      });\n\n      return new _AST(clauses);\n    }\n  }, {\n    key: \"removeSimpleFieldClauses\",\n    value: function removeSimpleFieldClauses(field) {\n      var clauses = this._clauses.filter(function (clause) {\n        return !Field.isInstance(clause) || clause.field !== field || (0, _predicate.isArray)(clause.value);\n      });\n\n      return new _AST(clauses);\n    }\n  }, {\n    key: \"getIsClauses\",\n    value: function getIsClauses() {\n      return Object.values(this._indexedClauses.is);\n    }\n  }, {\n    key: \"getIsClause\",\n    value: function getIsClause(flag) {\n      return this._indexedClauses.is[flag];\n    }\n  }, {\n    key: \"removeIsClause\",\n    value: function removeIsClause(flag) {\n      return new _AST(this._clauses.filter(function (clause) {\n        return !Is.isInstance(clause) || clause.flag !== flag;\n      }));\n    }\n  }, {\n    key: \"getGroupClauses\",\n    value: function getGroupClauses() {\n      return Object.values(this._indexedClauses.group);\n    }\n    /**\n     * Creates and returns a new AST with the given clause added to the current clauses. If\n     * the current clauses already include a similar clause, it will be (in-place) replaced by\n     * the given clause. Whether a clause is similar to the given one depends on the type of the clause.\n     * Two clauses are similar if:\n     *\n     * - they are both of the same type\n     * - if they are `default` clauses, they must have the same value\n     * - if they are `term` clauses, they must have the same fields and values\n     * - if they are `is` clauses, they must have the same flags\n     *\n     * The reasoning behind not including the `match` attributes of the clauses in the rules above, stems\n     * in the fact that the AST clauses are ANDed, and having two similar clauses with two different\n     * match attributes creates a logically contradicted AST (e.g. what does it mean to\n     * \"(must have x) AND (must not have x)\"?)\n     *\n     * note:  in-place replacement means the given clause will be placed in the same position as the one it\n     *        replaced\n     */\n\n  }, {\n    key: \"addClause\",\n    value: function addClause(newClause) {\n      var added = false;\n\n      var newClauses = this._clauses.reduce(function (clauses, clause) {\n        if (newClause.type !== clause.type) {\n          clauses.push(clause);\n          return clauses;\n        }\n\n        switch (newClause.type) {\n          case Term.TYPE:\n            if (newClause.value !== clause.value) {\n              clauses.push(clause);\n              return clauses;\n            }\n\n            break;\n\n          case Field.TYPE:\n            if (newClause.field !== clause.field || newClause.value !== clause.value) {\n              clauses.push(clause);\n              return clauses;\n            }\n\n            break;\n\n          case Is.TYPE:\n            if (newClause.flag !== clause.flag) {\n              clauses.push(clause);\n              return clauses;\n            }\n\n            break;\n\n          default:\n            throw new Error(\"unknown clause type [\".concat(newClause.type, \"]\"));\n        }\n\n        added = true;\n        clauses.push(newClause);\n        return clauses;\n      }, []);\n\n      if (!added) {\n        newClauses.push(newClause);\n      }\n\n      return new _AST(newClauses);\n    }\n  }, {\n    key: \"clauses\",\n    get: function get() {\n      return this._clauses;\n    }\n  }]);\n\n  return _AST;\n}();\n\nexports._AST = _AST;\nvar AST = Object.freeze({\n  Match: Match,\n  Operator: Operator,\n  Term: Term,\n  Group: Group,\n  Field: Field,\n  Is: Is,\n  create: function create(clauses) {\n    return new _AST(clauses);\n  }\n});\nexports.AST = AST;",{"version":3,"sources":["/Users/chanderprall/projects/eui/src/components/search_bar/query/ast.js"],"names":["Match","Object","freeze","MUST","MUST_NOT","isMust","match","isMustClause","clause","Operator","EQ","EXACT","GT","GTE","LT","LTE","isEQ","isEQClause","operator","isEXACT","isEXACTClause","isRange","isGT","isGTE","isLT","isLTE","isRangeClause","isGTClause","isGTEClause","isLTClause","isLTEClause","Term","TYPE","isInstance","type","must","value","mustNot","Group","Field","eq","field","exact","gt","gte","lt","lte","Is","flag","valuesEqual","v1","v2","arrayIncludesValue","array","some","item","_AST","clauses","_clauses","_indexedClauses","reduce","map","push","is","term","group","Error","getTermClauses","find","keys","undefined","filter","predicate","getFieldClauses","getFieldClause","existingClause","getOrFieldClause","newClause","filteredValue","val","length","addClause","getSimpleFieldClause","values","added","newClauses","AST","create"],"mappings":"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","sourcesContent":["import { isArray, isNil } from '../../../services/predicate';\nimport { isDateValue, dateValuesEqual } from './date_value';\n\nexport const Match = Object.freeze({\n  MUST: 'must',\n  MUST_NOT: 'must_not',\n  isMust(match) {\n    return match === Match.MUST;\n  },\n  isMustClause(clause) {\n    return Match.isMust(clause.match);\n  },\n});\n\nexport const Operator = Object.freeze({\n  EQ: 'eq',\n  EXACT: 'exact',\n  GT: 'gt',\n  GTE: 'gte',\n  LT: 'lt',\n  LTE: 'lte',\n  isEQ(match) {\n    return match === Operator.EQ;\n  },\n  isEQClause(clause) {\n    return Operator.isEQ(clause.operator);\n  },\n  isEXACT(match) {\n    return match === Operator.EXACT;\n  },\n  isEXACTClause(clause) {\n    return Operator.isEXACT(clause.operator);\n  },\n  isRange(match) {\n    return (\n      Operator.isGT(match) ||\n      Operator.isGTE(match) ||\n      Operator.isLT(match) ||\n      Operator.isLTE(match)\n    );\n  },\n  isRangeClause(clause) {\n    return Operator.isRange(clause.operator);\n  },\n  isGT(match) {\n    return match === Operator.GT;\n  },\n  isGTClause(clause) {\n    return Operator.isGT(clause.operator);\n  },\n  isGTE(match) {\n    return match === Operator.GTE;\n  },\n  isGTEClause(clause) {\n    return Operator.isGTE(clause.operator);\n  },\n  isLT(match) {\n    return match === Operator.LT;\n  },\n  isLTClause(clause) {\n    return Operator.isLT(clause.operator);\n  },\n  isLTE(match) {\n    return match === Operator.LTE;\n  },\n  isLTEClause(clause) {\n    return Operator.isLTE(clause.operator);\n  },\n});\n\nconst Term = Object.freeze({\n  TYPE: 'term',\n  isInstance: clause => {\n    return clause.type === Term.TYPE;\n  },\n  must: value => {\n    return { type: Term.TYPE, value, match: Match.MUST };\n  },\n  mustNot: value => {\n    return { type: Term.TYPE, value, match: Match.MUST_NOT };\n  },\n});\n\nconst Group = Object.freeze({\n  TYPE: 'group',\n  isInstance: clause => {\n    return clause.type === Group.TYPE;\n  },\n  must: value => {\n    return { type: Group.TYPE, value, match: Match.MUST };\n  },\n  mustNot: value => {\n    return { type: Group.TYPE, value, match: Match.MUST_NOT };\n  },\n});\n\nconst Field = Object.freeze({\n  TYPE: 'field',\n  isInstance: clause => {\n    return clause.type === Field.TYPE;\n  },\n  must: {\n    eq: (field, value) => ({\n      type: Field.TYPE,\n      field,\n      value,\n      match: Match.MUST,\n      operator: Operator.EQ,\n    }),\n    exact: (field, value) => ({\n      type: Field.TYPE,\n      field,\n      value,\n      match: Match.MUST,\n      operator: Operator.EXACT,\n    }),\n    gt: (field, value) => ({\n      type: Field.TYPE,\n      field,\n      value,\n      match: Match.MUST,\n      operator: Operator.GT,\n    }),\n    gte: (field, value) => ({\n      type: Field.TYPE,\n      field,\n      value,\n      match: Match.MUST,\n      operator: Operator.GTE,\n    }),\n    lt: (field, value) => ({\n      type: Field.TYPE,\n      field,\n      value,\n      match: Match.MUST,\n      operator: Operator.LT,\n    }),\n    lte: (field, value) => ({\n      type: Field.TYPE,\n      field,\n      value,\n      match: Match.MUST,\n      operator: Operator.LTE,\n    }),\n  },\n  mustNot: {\n    eq: (field, value) => ({\n      type: Field.TYPE,\n      field,\n      value,\n      match: Match.MUST_NOT,\n      operator: Operator.EQ,\n    }),\n    exact: (field, value) => ({\n      type: Field.TYPE,\n      field,\n      value,\n      match: Match.MUST_NOT,\n      operator: Operator.EXACT,\n    }),\n    gt: (field, value) => ({\n      type: Field.TYPE,\n      field,\n      value,\n      match: Match.MUST_NOT,\n      operator: Operator.GT,\n    }),\n    gte: (field, value) => ({\n      type: Field.TYPE,\n      field,\n      value,\n      match: Match.MUST_NOT,\n      operator: Operator.GTE,\n    }),\n    lt: (field, value) => ({\n      type: Field.TYPE,\n      field,\n      value,\n      match: Match.MUST_NOT,\n      operator: Operator.LT,\n    }),\n    lte: (field, value) => ({\n      type: Field.TYPE,\n      field,\n      value,\n      match: Match.MUST_NOT,\n      operator: Operator.LTE,\n    }),\n  },\n});\n\nconst Is = Object.freeze({\n  TYPE: 'is',\n  isInstance: clause => {\n    return clause.type === Is.TYPE;\n  },\n  must: flag => {\n    return { type: Is.TYPE, flag, match: Match.MUST };\n  },\n  mustNot: flag => {\n    return { type: Is.TYPE, flag, match: Match.MUST_NOT };\n  },\n});\n\nconst valuesEqual = (v1, v2) => {\n  if (isDateValue(v1)) {\n    return dateValuesEqual(v1, v2);\n  }\n  return v1 === v2;\n};\n\nconst arrayIncludesValue = (array, value) => {\n  return array.some(item => valuesEqual(item, value));\n};\n\n/**\n * The AST structure is an array of clauses. There are 3 types of clauses that are supported:\n *\n * :term:\n * Holds a VALUE and an OCCUR. The OCCUR indicates whether the value must match or must not match. Default\n * clauses are not associated with any specific field - when executing the search, one can specify what are\n * the default fields that the default clauses will be matched against.\n *\n * :field:\n * Like the `term` clause, holds a VALUE and an MATCH, but this clause also specifies the field that the\n * value will be matched against.\n *\n * :is:\n * Holds a FLAG and indicates whether this flag must be applied or must not be applied. Typically this clause\n * matches against boolean values of a record (e.g. \"is:online\", \"is:internal\", \"is:on\", etc..)\n *\n * This AST is immutable - every \"mutating\" operation returns a newly mutated AST.\n */\nexport class _AST {\n  static create(clauses) {\n    return new _AST(clauses);\n  }\n\n  constructor(clauses = []) {\n    this._clauses = clauses;\n    this._indexedClauses = clauses.reduce(\n      (map, clause) => {\n        switch (clause.type) {\n          case Field.TYPE:\n            if (!map.field[clause.field]) {\n              map.field[clause.field] = [];\n            }\n            map.field[clause.field].push(clause);\n            return map;\n          case Is.TYPE:\n            map.is[clause.flag] = clause;\n            return map;\n          case Term.TYPE:\n            map.term.push(clause);\n            return map;\n          case Group.TYPE:\n            map.group.push(clause);\n            return map;\n          default:\n            throw new Error(`Unknown query clause type [${clause.type}]`);\n        }\n      },\n      { field: {}, is: {}, term: [], group: [] }\n    );\n  }\n\n  get clauses() {\n    return this._clauses;\n  }\n\n  getTermClauses() {\n    return this._indexedClauses.term;\n  }\n\n  getTermClause(value) {\n    const clauses = this.getTermClauses();\n    return clauses.find(clause => valuesEqual(clause.value, value));\n  }\n\n  getFieldNames() {\n    return Object.keys(this._indexedClauses.field);\n  }\n\n  getFieldClauses(field = undefined) {\n    return field\n      ? this._indexedClauses.field[field]\n      : this._clauses.filter(Field.isInstance);\n  }\n\n  getFieldClause(field, predicate) {\n    const clauses = this.getFieldClauses(field);\n    if (clauses) {\n      return clauses.find(predicate);\n    }\n  }\n\n  hasOrFieldClause(field, value = undefined) {\n    const clauses = this.getFieldClause(field, clause => isArray(clause.value));\n    if (!clauses) {\n      return false;\n    }\n    return (\n      isNil(value) ||\n      clauses.some(clause => arrayIncludesValue(clause.value, value))\n    );\n  }\n\n  getOrFieldClause(field, value = undefined) {\n    return this.getFieldClause(\n      field,\n      clause =>\n        isArray(clause.value) &&\n        (isNil(value) || arrayIncludesValue(clause.value, value))\n    );\n  }\n\n  addOrFieldValue(field, value, must = true, operator = Operator.EQ) {\n    const existingClause = this.getOrFieldClause(field);\n    if (!existingClause) {\n      const newClause = must\n        ? Field.must[operator](field, [value])\n        : Field.mustNot[operator](field, [value]);\n      return new _AST([...this._clauses, newClause]);\n    }\n    const clauses = this._clauses.map(clause => {\n      if (clause === existingClause) {\n        clause.value.push(value);\n      }\n      return clause;\n    });\n    return new _AST(clauses);\n  }\n\n  removeOrFieldValue(field, value) {\n    const existingClause = this.getOrFieldClause(field, value);\n    if (!existingClause) {\n      return new _AST([...this._clauses]);\n    }\n    const clauses = this._clauses.reduce((clauses, clause) => {\n      if (clause !== existingClause) {\n        clauses.push(clause);\n        return clauses;\n      }\n      const filteredValue = clause.value.filter(\n        val => !valuesEqual(val, value)\n      );\n      if (filteredValue.length === 0) {\n        return clauses;\n      }\n      clauses.push({ ...clause, value: filteredValue });\n      return clauses;\n    }, []);\n    return new _AST(clauses);\n  }\n\n  removeOrFieldClauses(field) {\n    const clauses = this._clauses.filter(clause => {\n      return (\n        !Field.isInstance(clause) ||\n        clause.field !== field ||\n        !isArray(clause.value)\n      );\n    });\n    return new _AST(clauses);\n  }\n\n  hasSimpleFieldClause(field, value = undefined) {\n    const clauses = this.getFieldClause(\n      field,\n      clause => !isArray(clause.value)\n    );\n    if (!clauses) {\n      return false;\n    }\n    return (\n      isNil(value) || clauses.some(clause => valuesEqual(clause.value, value))\n    );\n  }\n\n  getSimpleFieldClause(field, value = undefined) {\n    return this.getFieldClause(\n      field,\n      clause =>\n        !isArray(clause.value) &&\n        (isNil(value) || valuesEqual(clause.value, value))\n    );\n  }\n\n  addSimpleFieldValue(field, value, must = true, operator = Operator.EQ) {\n    const clause = must\n      ? Field.must[operator](field, value)\n      : Field.mustNot[operator](field, value);\n    return this.addClause(clause);\n  }\n\n  removeSimpleFieldValue(field, value) {\n    const existingClause = this.getSimpleFieldClause(field, value);\n    if (!existingClause) {\n      return new _AST([...this._clauses]);\n    }\n    const clauses = this._clauses.filter(clause => clause !== existingClause);\n    return new _AST(clauses);\n  }\n\n  removeSimpleFieldClauses(field) {\n    const clauses = this._clauses.filter(clause => {\n      return (\n        !Field.isInstance(clause) ||\n        clause.field !== field ||\n        isArray(clause.value)\n      );\n    });\n    return new _AST(clauses);\n  }\n\n  getIsClauses() {\n    return Object.values(this._indexedClauses.is);\n  }\n\n  getIsClause(flag) {\n    return this._indexedClauses.is[flag];\n  }\n\n  removeIsClause(flag) {\n    return new _AST(\n      this._clauses.filter(\n        clause => !Is.isInstance(clause) || clause.flag !== flag\n      )\n    );\n  }\n\n  getGroupClauses() {\n    return Object.values(this._indexedClauses.group);\n  }\n\n  /**\n   * Creates and returns a new AST with the given clause added to the current clauses. If\n   * the current clauses already include a similar clause, it will be (in-place) replaced by\n   * the given clause. Whether a clause is similar to the given one depends on the type of the clause.\n   * Two clauses are similar if:\n   *\n   * - they are both of the same type\n   * - if they are `default` clauses, they must have the same value\n   * - if they are `term` clauses, they must have the same fields and values\n   * - if they are `is` clauses, they must have the same flags\n   *\n   * The reasoning behind not including the `match` attributes of the clauses in the rules above, stems\n   * in the fact that the AST clauses are ANDed, and having two similar clauses with two different\n   * match attributes creates a logically contradicted AST (e.g. what does it mean to\n   * \"(must have x) AND (must not have x)\"?)\n   *\n   * note:  in-place replacement means the given clause will be placed in the same position as the one it\n   *        replaced\n   */\n  addClause(newClause) {\n    let added = false;\n    const newClauses = this._clauses.reduce((clauses, clause) => {\n      if (newClause.type !== clause.type) {\n        clauses.push(clause);\n        return clauses;\n      }\n      switch (newClause.type) {\n        case Term.TYPE:\n          if (newClause.value !== clause.value) {\n            clauses.push(clause);\n            return clauses;\n          }\n          break;\n        case Field.TYPE:\n          if (\n            newClause.field !== clause.field ||\n            newClause.value !== clause.value\n          ) {\n            clauses.push(clause);\n            return clauses;\n          }\n          break;\n        case Is.TYPE:\n          if (newClause.flag !== clause.flag) {\n            clauses.push(clause);\n            return clauses;\n          }\n          break;\n        default:\n          throw new Error(`unknown clause type [${newClause.type}]`);\n      }\n      added = true;\n      clauses.push(newClause);\n      return clauses;\n    }, []);\n    if (!added) {\n      newClauses.push(newClause);\n    }\n    return new _AST(newClauses);\n  }\n}\n\nexport const AST = Object.freeze({\n  Match,\n  Operator,\n  Term,\n  Group,\n  Field,\n  Is,\n  create: clauses => new _AST(clauses),\n});\n"]}]}