{"remainingRequest":"/Users/chanderprall/projects/eui/node_modules/babel-loader/lib/index.js!/Users/chanderprall/projects/eui/src/services/popover/popover_positioning.ts","dependencies":[{"path":"/Users/chanderprall/projects/eui/src/services/popover/popover_positioning.ts","mtime":1567626462195},{"path":"/Users/chanderprall/projects/eui/.babelrc.js","mtime":1565204168946},{"path":"/Users/chanderprall/projects/eui/node_modules/cache-loader/dist/cjs.js","mtime":1555436064329},{"path":"/Users/chanderprall/projects/eui/node_modules/babel-loader/lib/index.js","mtime":1543517280769}],"contextDependencies":[],"result":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.findPopoverPosition = findPopoverPosition;\nexports.getPopoverScreenCoordinates = getPopoverScreenCoordinates;\nexports.getElementBoundingBox = getElementBoundingBox;\nexports.getAvailableSpace = getAvailableSpace;\nexports.getVisibleFit = getVisibleFit;\nexports.intersectBoundingBoxes = intersectBoundingBoxes;\nexports.getElementZIndex = getElementZIndex;\nexports.POSITIONS = void 0;\n\nrequire(\"core-js/modules/es6.string.anchor\");\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nvar POSITIONS = ['top', 'right', 'bottom', 'left'];\nexports.POSITIONS = POSITIONS;\nvar relatedDimension = {\n  top: 'height',\n  right: 'width',\n  bottom: 'height',\n  left: 'width'\n};\nvar dimensionPositionAttribute = {\n  height: 'top',\n  width: 'left'\n};\nvar positionComplements = {\n  top: 'bottom',\n  right: 'left',\n  bottom: 'top',\n  left: 'right'\n}; // always resolving to top/left is taken advantage of by knowing they are the\n// minimum edges of the bounding box\n\nvar positionSubstitutes = {\n  top: 'left',\n  right: 'top',\n  bottom: 'left',\n  left: 'top'\n};\n\n/**\n * Calculates the absolute positioning (relative to document.body) to place a popover element\n *\n * @param anchor {HTMLElement} Element to anchor the popover to\n * @param popover {HTMLElement} Element containing the popover content\n * @param position {string} Position the user wants. One of [\"top\", \"right\", \"bottom\", \"left\"]\n * @param [forcePosition] {boolean} If true, use only the provided `position` value and don't try any other position\n * @param [align] {string} Cross-axis alignment. One of [\"top\", \"right\", \"bottom\", \"left\"]\n * @param [buffer=16] {number} Minimum distance between the popover and the bounding container\n * @param [offset=0] {number} Distance between the popover and the anchor\n * @param [allowCrossAxis=true] {boolean} Whether to allow the popover to be positioned on the cross-axis\n * @param [container] {HTMLElement} Element the popover must be constrained to fit within\n * @param [arrowConfig] {{arrowWidth: number, arrowBuffer: number}} If\n *  present, describes the size & constraints for an arrow element, and the\n *  function return value will include an `arrow` param with position details\n *\n * @returns {FindPopoverPositionResult} absolute page coordinates for the\n * popover, and the placements's relation to the anchor or undefined\n * there's no room.\n */\nfunction findPopoverPosition(_ref) {\n  var anchor = _ref.anchor,\n      popover = _ref.popover,\n      align = _ref.align,\n      position = _ref.position,\n      forcePosition = _ref.forcePosition,\n      _ref$buffer = _ref.buffer,\n      buffer = _ref$buffer === void 0 ? 16 : _ref$buffer,\n      _ref$offset = _ref.offset,\n      offset = _ref$offset === void 0 ? 0 : _ref$offset,\n      _ref$allowCrossAxis = _ref.allowCrossAxis,\n      allowCrossAxis = _ref$allowCrossAxis === void 0 ? true : _ref$allowCrossAxis,\n      container = _ref.container,\n      arrowConfig = _ref.arrowConfig,\n      returnBoundingBox = _ref.returnBoundingBox;\n  // find the screen-relative bounding boxes of the anchor, popover, and container\n  var anchorBoundingBox = getElementBoundingBox(anchor);\n  var popoverBoundingBox = getElementBoundingBox(popover); // calculate the window's bounds\n  // window.(innerWidth|innerHeight) do not account for scrollbars\n  // so prefer the clientWidth/clientHeight of the DOM if available\n\n  var documentWidth = document.documentElement.clientWidth || window.innerWidth;\n  var documentHeight = document.documentElement.clientHeight || window.innerHeight;\n  var windowBoundingBox = {\n    top: 0,\n    right: documentWidth,\n    bottom: documentHeight,\n    left: 0,\n    height: documentHeight,\n    width: documentWidth\n  }; // if no container element is given fall back to using the window viewport\n\n  var containerBoundingBox = container ? getElementBoundingBox(container) : windowBoundingBox;\n  /**\n   * `position` was specified by the function caller and is a strong hint\n   * as to the preferred location of the popover relative to the anchor.\n   * However, we strongly prefer showing all of the popover content within\n   * the window+container boundary and will iterate over the four\n   * possible sides until a perfect fit is located. If none of the locations\n   * fully contain popover, the location with the best fit is selected.\n   *\n   * This approach first checks the preferred `position`, then its opposite\n   * along the same axis, next a location on the cross-axis, and finally it\n   * tests the remaining position.\n   *\n   * e.g.\n   * if position = \"top\" the order is top, bottom, left right\n   * if position = \"right\" the order is right, left, top, bottom\n   */\n  // Try the user-desired position first.\n\n  var iterationPositions = [position]; // keep user-defined alignment in the original positions.\n\n  var iterationAlignments = [align];\n\n  if (forcePosition !== true) {\n    iterationPositions.push(positionComplements[position]); // Try the complementary position.\n\n    iterationAlignments.push(align); // keep user-defined alignment in the complementary position.\n\n    if (allowCrossAxis) {\n      iterationPositions.push(positionSubstitutes[position], // Switch to the cross axis.\n      positionComplements[positionSubstitutes[position]] // Try the complementary position on the cross axis.\n      );\n      iterationAlignments.push(undefined, undefined); // discard desired alignment on cross-axis\n    }\n  } else {\n    // position is forced, if it conficts with the alignment then reset align to `null`\n    // e.g. original placement request for `downLeft` is moved to the `left` side, future calls\n    // will position and align `left`, and `leftLeft` is not a valid placement\n    if (position === align || align !== undefined && position === positionComplements[align]) {\n      iterationAlignments[0] = undefined;\n    }\n  }\n\n  var bestFit = -Infinity;\n  var bestPosition = null;\n\n  for (var idx = 0; idx < iterationPositions.length; idx++) {\n    var iterationPosition = iterationPositions[idx]; // See if we can find a position with a better fit than we've found so far.\n\n    var screenCoordinates = getPopoverScreenCoordinates({\n      position: iterationPosition,\n      align: iterationAlignments[idx],\n      anchorBoundingBox: anchorBoundingBox,\n      popoverBoundingBox: popoverBoundingBox,\n      windowBoundingBox: windowBoundingBox,\n      containerBoundingBox: containerBoundingBox,\n      offset: offset,\n      buffer: buffer,\n      arrowConfig: arrowConfig\n    });\n\n    if (screenCoordinates.fit > bestFit) {\n      bestFit = screenCoordinates.fit;\n      bestPosition = {\n        fit: screenCoordinates.fit,\n        position: iterationPosition,\n        top: screenCoordinates.top + window.pageYOffset,\n        left: screenCoordinates.left + window.pageXOffset,\n        arrow: screenCoordinates.arrow\n      }; // If we've already found the ideal fit, use that position.\n\n      if (bestFit === 1) {\n        break;\n      }\n    } // If we haven't improved the fit, then continue on and try a new position.\n\n  }\n\n  if (bestPosition == null) {\n    throw new Error('Failed to calculate bestPosition');\n  }\n\n  if (returnBoundingBox) {\n    bestPosition.anchorBoundingBox = anchorBoundingBox;\n  }\n\n  return bestPosition;\n}\n\n/**\n * Given a target position and the popover's surrounding context, returns either an\n * object with {top, left} screen coordinates or `null` if it's not possible to show\n * content in the target position\n * @param position {string} the target position, one of [\"top\", \"right\", \"bottom\", \"left\"]\n * @param align {string} target alignment on the cross-axis, one of [\"top\", \"right\", \"bottom\", \"left\"]\n * @param anchorBoundingBox {Object} bounding box of the anchor element\n * @param popoverBoundingBox {Object} bounding box of the popover element\n * @param windowBoundingBox {Object} bounding box of the window\n * @param containerBoundingBox {Object} bounding box of the container\n * @param [arrowConfig] {{arrowWidth: number, arrowBuffer: number}} If present, describes the size &\n *  constraints for an arrow element, and the function return value will include an `arrow` param\n *  with position details\n * @param [offset=0] {number} Distance between the popover and the anchor\n * @param [buffer=0] {number} Minimum distance between the popover's\n *  placement and the container edge\n *\n * @returns {GetPopoverScreenCoordinatesResult}\n *  object with top/left coordinates, the popover's relative position to the anchor, and how well the\n *  popover fits in the location (0.0 -> 1.0) coordinates and the popover's relative position, if\n *  there is no room in this placement then null\n */\nfunction getPopoverScreenCoordinates(_ref2) {\n  var _popoverPlacement, _ref3;\n\n  var position = _ref2.position,\n      align = _ref2.align,\n      anchorBoundingBox = _ref2.anchorBoundingBox,\n      popoverBoundingBox = _ref2.popoverBoundingBox,\n      windowBoundingBox = _ref2.windowBoundingBox,\n      containerBoundingBox = _ref2.containerBoundingBox,\n      arrowConfig = _ref2.arrowConfig,\n      _ref2$offset = _ref2.offset,\n      offset = _ref2$offset === void 0 ? 0 : _ref2$offset,\n      _ref2$buffer = _ref2.buffer,\n      buffer = _ref2$buffer === void 0 ? 0 : _ref2$buffer;\n\n  /**\n   * The goal is to find the best way to align the popover content\n   * on the given side of the anchor element. The popover prefers\n   * centering on the anchor but can shift along the cross-axis as needed.\n   *\n   * We return the top/left coordinates that best fit the popover inside\n   * the given boundaries, and also return the `fit` value which indicates\n   * what percentage of the popover is within the bounds.\n   *\n   * e.g. finding a location when position=top\n   * the preferred location is directly over the anchor\n   *\n   *        +----------------------+\n   *        |       popover        |\n   *        +----------------------+\n   *                   v\n   *            +--------------+\n   *            |    anchor    |\n   *            +--------------+\n   *\n   * but if anchor doesn't have much (or any) room on its ride side\n   * the popover will shift to the left\n   *\n   *    +----------------------+\n   *    |       popover        |\n   *    +----------------------+\n   *                   v\n   *            +--------------+\n   *            |    anchor    |\n   *            +--------------+\n   *\n   */\n  var crossAxisFirstSide = positionSubstitutes[position]; // \"top\" -> \"left\"\n\n  var crossAxisSecondSide = positionComplements[crossAxisFirstSide]; // \"left\" -> \"right\"\n\n  var crossAxisDimension = relatedDimension[crossAxisFirstSide]; // \"left\" -> \"width\"\n\n  var _getCrossAxisPosition = getCrossAxisPosition({\n    crossAxisFirstSide: crossAxisFirstSide,\n    crossAxisSecondSide: crossAxisSecondSide,\n    crossAxisDimension: crossAxisDimension,\n    position: position,\n    align: align,\n    buffer: buffer,\n    offset: offset,\n    windowBoundingBox: windowBoundingBox,\n    containerBoundingBox: containerBoundingBox,\n    popoverBoundingBox: popoverBoundingBox,\n    anchorBoundingBox: anchorBoundingBox,\n    arrowConfig: arrowConfig\n  }),\n      crossAxisPosition = _getCrossAxisPosition.crossAxisPosition,\n      crossAxisArrowPosition = _getCrossAxisPosition.crossAxisArrowPosition;\n\n  var primaryAxisDimension = relatedDimension[position]; // \"top\" -> \"height\"\n\n  var primaryAxisPositionName = dimensionPositionAttribute[primaryAxisDimension]; // \"height\" -> \"top\"\n\n  var _getPrimaryAxisPositi = getPrimaryAxisPosition({\n    position: position,\n    offset: offset,\n    popoverBoundingBox: popoverBoundingBox,\n    anchorBoundingBox: anchorBoundingBox,\n    arrowConfig: arrowConfig\n  }),\n      primaryAxisPosition = _getPrimaryAxisPositi.primaryAxisPosition,\n      primaryAxisArrowPosition = _getPrimaryAxisPositi.primaryAxisArrowPosition;\n\n  var popoverPlacement = (_popoverPlacement = {}, _defineProperty(_popoverPlacement, crossAxisFirstSide, crossAxisPosition), _defineProperty(_popoverPlacement, primaryAxisPositionName, primaryAxisPosition), _popoverPlacement); // calculate the fit of the popover in this location\n  // fit is in range 0.0 -> 1.0 and is the percentage of the popover which is visible in this location\n\n  var combinedBoundingBox = intersectBoundingBoxes(windowBoundingBox, containerBoundingBox); // shrink the visible bounding box by `buffer`\n  // to compute a fit value\n\n  combinedBoundingBox.top += buffer;\n  combinedBoundingBox.right -= buffer;\n  combinedBoundingBox.bottom -= buffer;\n  combinedBoundingBox.left += buffer;\n  var fit = getVisibleFit({\n    top: popoverPlacement.top,\n    right: popoverPlacement.left + popoverBoundingBox.width,\n    bottom: popoverPlacement.top + popoverBoundingBox.height,\n    left: popoverPlacement.left,\n    width: popoverBoundingBox.width,\n    height: popoverBoundingBox.height\n  }, combinedBoundingBox);\n  var arrow = arrowConfig ? (_ref3 = {}, _defineProperty(_ref3, crossAxisFirstSide, crossAxisArrowPosition - popoverPlacement[crossAxisFirstSide]), _defineProperty(_ref3, primaryAxisPositionName, primaryAxisArrowPosition), _ref3) : undefined;\n  return {\n    fit: fit,\n    top: popoverPlacement.top,\n    left: popoverPlacement.left,\n    arrow: arrow ? {\n      left: arrow.left,\n      top: arrow.top\n    } : undefined\n  };\n}\n\nfunction getCrossAxisPosition(_ref4) {\n  var crossAxisFirstSide = _ref4.crossAxisFirstSide,\n      crossAxisSecondSide = _ref4.crossAxisSecondSide,\n      crossAxisDimension = _ref4.crossAxisDimension,\n      position = _ref4.position,\n      align = _ref4.align,\n      buffer = _ref4.buffer,\n      offset = _ref4.offset,\n      windowBoundingBox = _ref4.windowBoundingBox,\n      containerBoundingBox = _ref4.containerBoundingBox,\n      popoverBoundingBox = _ref4.popoverBoundingBox,\n      anchorBoundingBox = _ref4.anchorBoundingBox,\n      arrowConfig = _ref4.arrowConfig;\n  // how much of the popover overflows past either side of the anchor if its centered\n  var popoverSizeOnCrossAxis = popoverBoundingBox[crossAxisDimension];\n  var anchorSizeOnCrossAxis = anchorBoundingBox[crossAxisDimension];\n  var anchorHalfSize = anchorSizeOnCrossAxis / 2; // the popover's original position on the cross-axis is determined by:\n\n  var crossAxisPositionOriginal = anchorBoundingBox[crossAxisFirstSide] + // where the anchor is located\n  anchorHalfSize - // plus half anchor dimension\n  popoverSizeOnCrossAxis / 2; // less half the popover dimension\n  // To fit the content within both the window and container,\n  // compute the smaller of the two spaces along each edge\n\n  var combinedBoundingBox = intersectBoundingBoxes(windowBoundingBox, containerBoundingBox);\n  var availableSpace = getAvailableSpace(anchorBoundingBox, combinedBoundingBox, buffer, offset, position);\n  var minimumSpace = arrowConfig ? arrowConfig.arrowBuffer : 0;\n  var contentOverflowSize = (popoverSizeOnCrossAxis - anchorSizeOnCrossAxis) / 2;\n  var alignAmount = 0;\n  var alignDirection = 1;\n  var amountOfShiftNeeded = 0;\n  var shiftDirection = 1;\n\n  if (align != null) {\n    // no alignment, find how much the container boundary requires the content to shift\n    alignDirection = align === 'top' || align === 'left' ? 1 : -1;\n    alignAmount = contentOverflowSize;\n    var alignedOverflowAmount = contentOverflowSize + alignAmount;\n    var needsShift = alignedOverflowAmount > availableSpace[positionComplements[align]];\n    amountOfShiftNeeded = needsShift ? alignedOverflowAmount - availableSpace[positionComplements[align]] : 0;\n    shiftDirection = -1 * alignDirection;\n  } else {\n    // shifting the popover to one side may yield a better fit\n    var spaceAvailableOnFirstSide = availableSpace[crossAxisFirstSide];\n    var spaceAvailableOnSecondSide = availableSpace[crossAxisSecondSide];\n    var isShiftTowardFirstSide = spaceAvailableOnFirstSide > spaceAvailableOnSecondSide;\n    shiftDirection = isShiftTowardFirstSide ? -1 : 1; // determine which direction has more room and the popover should shift to\n\n    var leastAvailableSpace = Math.min(spaceAvailableOnFirstSide, spaceAvailableOnSecondSide);\n\n    var _needsShift = contentOverflowSize > leastAvailableSpace;\n\n    amountOfShiftNeeded = _needsShift ? contentOverflowSize - leastAvailableSpace : 0;\n  } // shift over the popover if necessary\n\n\n  var shiftAmount = amountOfShiftNeeded * shiftDirection;\n  var crossAxisPosition = crossAxisPositionOriginal + shiftAmount + alignAmount * alignDirection; // if an `arrowConfig` is specified, find where to position the arrow\n\n  var crossAxisArrowPosition;\n\n  if (arrowConfig) {\n    var _arrowWidth = arrowConfig.arrowWidth;\n    crossAxisArrowPosition = anchorBoundingBox[crossAxisFirstSide] + anchorHalfSize - _arrowWidth / 2; // make sure there's enough buffer around the arrow\n    // by calculating how how much the arrow would need to move\n    // but instead of moving the arrow, shift the popover content\n\n    if (crossAxisArrowPosition < crossAxisPosition + minimumSpace) {\n      // arrow is too close to the minimum side\n      var difference = crossAxisPosition + minimumSpace - crossAxisArrowPosition;\n      crossAxisPosition -= difference;\n    } else if (crossAxisArrowPosition + minimumSpace + _arrowWidth > crossAxisPosition + popoverSizeOnCrossAxis) {\n      // arrow is too close to the maximum side\n      var edge = crossAxisPosition + popoverSizeOnCrossAxis;\n\n      var _difference = crossAxisArrowPosition - (edge - minimumSpace - _arrowWidth);\n\n      crossAxisPosition += _difference;\n    }\n  }\n\n  return {\n    crossAxisPosition: crossAxisPosition,\n    crossAxisArrowPosition: crossAxisArrowPosition\n  };\n}\n\nfunction getPrimaryAxisPosition(_ref5) {\n  var position = _ref5.position,\n      offset = _ref5.offset,\n      popoverBoundingBox = _ref5.popoverBoundingBox,\n      anchorBoundingBox = _ref5.anchorBoundingBox,\n      arrowConfig = _ref5.arrowConfig;\n  // if positioning to the top or left, the target position decreases\n  // from the anchor's top or left, otherwise the position adds to the anchor's\n  var isOffsetDecreasing = position === 'top' || position === 'left';\n  var primaryAxisDimension = relatedDimension[position]; // \"top\" -> \"height\"\n\n  var popoverSizeOnPrimaryAxis = popoverBoundingBox[primaryAxisDimension]; // start at the top or left edge of the anchor element\n\n  var primaryAxisPositionName = dimensionPositionAttribute[primaryAxisDimension]; // \"height\" -> \"top\"\n\n  var anchorEdgeOrigin = anchorBoundingBox[primaryAxisPositionName]; // find the popover position on the primary axis\n\n  var anchorSizeOnPrimaryAxis = anchorBoundingBox[primaryAxisDimension];\n  var primaryAxisOffset = isOffsetDecreasing ? popoverSizeOnPrimaryAxis : anchorSizeOnPrimaryAxis;\n  var contentOffset = (offset + primaryAxisOffset) * (isOffsetDecreasing ? -1 : 1);\n  var primaryAxisPosition = anchorEdgeOrigin + contentOffset;\n  var primaryAxisArrowPosition;\n\n  if (arrowConfig) {\n    primaryAxisArrowPosition = isOffsetDecreasing ? popoverSizeOnPrimaryAxis : 0;\n  }\n\n  return {\n    primaryAxisPosition: primaryAxisPosition,\n    primaryAxisArrowPosition: primaryAxisArrowPosition\n  };\n}\n/**\n * Finds the client pixel coordinate of each edge for the element's bounding box,\n * and the bounding box's width & height\n *\n * @param {HTMLElement} element\n * @returns {{top: number, right: number, bottom: number, left: number, height: number, width: number}}\n */\n\n\nfunction getElementBoundingBox(element) {\n  var rect = element.getBoundingClientRect();\n  return {\n    top: rect.top,\n    right: rect.right,\n    bottom: rect.bottom,\n    left: rect.left,\n    height: rect.height,\n    width: rect.width\n  };\n}\n/**\n * Calculates the available content space between anchor and container\n *\n * @param {Object} anchorBoundingBox Client bounding box of the anchor element\n * @param {Object} containerBoundingBox Client bounding box of the container element\n * @param {number} buffer Minimum distance between the popover and the bounding container\n * @param {number} offset Distance between the popover and the anchor\n * @param {string} offsetSide Side the offset needs to be applied to, one\n *  of [\"top\", \"right\", \"bottom\", \"left\"]\n * @returns {{top: number, right: number, bottom: number, left: number}}\n */\n\n\nfunction getAvailableSpace(anchorBoundingBox, containerBoundingBox, buffer, offset, offsetSide) {\n  return {\n    top: anchorBoundingBox.top - containerBoundingBox.top - buffer - (offsetSide === 'top' ? offset : 0),\n    right: containerBoundingBox.right - anchorBoundingBox.right - buffer - (offsetSide === 'right' ? offset : 0),\n    bottom: containerBoundingBox.bottom - anchorBoundingBox.bottom - buffer - (offsetSide === 'bottom' ? offset : 0),\n    left: anchorBoundingBox.left - containerBoundingBox.left - buffer - (offsetSide === 'left' ? offset : 0)\n  };\n}\n/**\n * Computes the fit (overlap) of the content within the container, fit is in range 0.0 => 1.0\n * @param contentBoundingBox bounding box of content to calculate fit for\n * @param containerBoundingBox bounding box of container\n * @returns {number}\n */\n\n\nfunction getVisibleFit(contentBoundingBox, containerBoundingBox) {\n  var intersection = intersectBoundingBoxes(contentBoundingBox, containerBoundingBox);\n\n  if (intersection.left > intersection.right || intersection.top > intersection.top) {\n    // there is no intersection, the boxes are completely separated on at least one axis\n    return 0;\n  }\n\n  var intersectionArea = (intersection.right - intersection.left) * (intersection.bottom - intersection.top);\n  var contentArea = (contentBoundingBox.right - contentBoundingBox.left) * (contentBoundingBox.bottom - contentBoundingBox.top);\n  return intersectionArea / contentArea;\n}\n/**\n * Calculates the intersection space between two bounding boxes\n *\n * @param firstBox\n * @param secondBox\n * @returns {EuiClientRect}\n */\n\n\nfunction intersectBoundingBoxes(firstBox, secondBox) {\n  var top = Math.max(firstBox.top, secondBox.top);\n  var right = Math.min(firstBox.right, secondBox.right);\n  var bottom = Math.min(firstBox.bottom, secondBox.bottom);\n  var left = Math.max(firstBox.left, secondBox.left);\n  var height = Math.max(bottom - top, 0);\n  var width = Math.max(right - left, 0);\n  return {\n    top: top,\n    right: right,\n    bottom: bottom,\n    left: left,\n    height: height,\n    width: width\n  };\n}\n/**\n * Returns the top-most defined z-index in the element's ancestor hierarchy\n * relative to the `target` element; if no z-index is defined, returns 0\n * @param element {HTMLElement}\n * @param cousin {HTMLElement}\n * @returns {number}\n */\n\n\nfunction getElementZIndex(element, cousin) {\n  /**\n   * finding the z-index of `element` is not the full story\n   * its the CSS stacking context that is important\n   * take this DOM for example:\n   * body\n   *   section[z-index: 1000]\n   *     p[z-index: 500]\n   *       button\n   *   div\n   *\n   * what z-index does the `div` need to display next to `button`?\n   * the `div` and `section` are where the stacking context splits\n   * so `div` needs to copy `section`'s z-index in order to\n   * appear next to / over `button`\n   *\n   * calculate this by starting at `button` and finding its offsetParents\n   * then walk the parents from top -> down until the stacking context\n   * split is found, or if there is no split then a specific z-index is unimportant\n   */\n  var nodesToInspect = [];\n\n  while (true) {\n    nodesToInspect.push(element); // AFAICT this is a valid cast - the libdefs appear wrong\n\n    element = element.offsetParent; // stop if there is no parent\n\n    if (element == null) {\n      break;\n    } // stop if the parent contains the related element\n    // as this is the z-index ancestor\n\n\n    if (element.contains(cousin)) {\n      break;\n    }\n  } // reverse the nodes to walk from top -> element\n\n\n  nodesToInspect.reverse();\n\n  for (var _i = 0; _i < nodesToInspect.length; _i++) {\n    var node = nodesToInspect[_i];\n    // get this node's z-index css value\n    var zIndex = window.document.defaultView.getComputedStyle(node).getPropertyValue('z-index'); // if the z-index is not a number (e.g. \"auto\") return null, else the value\n\n    var parsedZIndex = parseInt(zIndex, 10);\n\n    if (!isNaN(parsedZIndex)) {\n      return parsedZIndex;\n    }\n  }\n\n  return 0;\n}",{"version":3,"sources":["/Users/chanderprall/projects/eui/src/services/popover/popover_positioning.ts"],"names":["POSITIONS","relatedDimension","top","right","bottom","left","dimensionPositionAttribute","height","width","positionComplements","positionSubstitutes","findPopoverPosition","anchor","popover","align","position","forcePosition","buffer","offset","allowCrossAxis","container","arrowConfig","returnBoundingBox","anchorBoundingBox","getElementBoundingBox","popoverBoundingBox","documentWidth","document","documentElement","clientWidth","window","innerWidth","documentHeight","clientHeight","innerHeight","windowBoundingBox","containerBoundingBox","iterationPositions","iterationAlignments","push","undefined","bestFit","Infinity","bestPosition","idx","length","iterationPosition","screenCoordinates","getPopoverScreenCoordinates","fit","pageYOffset","pageXOffset","arrow","Error","crossAxisFirstSide","crossAxisSecondSide","crossAxisDimension","getCrossAxisPosition","crossAxisPosition","crossAxisArrowPosition","primaryAxisDimension","primaryAxisPositionName","getPrimaryAxisPosition","primaryAxisPosition","primaryAxisArrowPosition","popoverPlacement","combinedBoundingBox","intersectBoundingBoxes","getVisibleFit","popoverSizeOnCrossAxis","anchorSizeOnCrossAxis","anchorHalfSize","crossAxisPositionOriginal","availableSpace","getAvailableSpace","minimumSpace","arrowBuffer","contentOverflowSize","alignAmount","alignDirection","amountOfShiftNeeded","shiftDirection","alignedOverflowAmount","needsShift","spaceAvailableOnFirstSide","spaceAvailableOnSecondSide","isShiftTowardFirstSide","leastAvailableSpace","Math","min","shiftAmount","arrowWidth","difference","edge","isOffsetDecreasing","popoverSizeOnPrimaryAxis","anchorEdgeOrigin","anchorSizeOnPrimaryAxis","primaryAxisOffset","contentOffset","element","rect","getBoundingClientRect","offsetSide","contentBoundingBox","intersection","intersectionArea","contentArea","firstBox","secondBox","max","getElementZIndex","cousin","nodesToInspect","offsetParent","contains","reverse","node","zIndex","defaultView","getComputedStyle","getPropertyValue","parsedZIndex","parseInt","isNaN"],"mappings":"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","sourcesContent":["import { EuiPopoverPosition } from './types';\n\ntype Dimension = 'height' | 'width';\n\nexport const POSITIONS: EuiPopoverPosition[] = [\n  'top',\n  'right',\n  'bottom',\n  'left',\n];\n\ninterface BoundingBox {\n  [position: string]: number;\n  top: number;\n  right: number;\n  bottom: number;\n  left: number;\n}\n\nexport interface EuiClientRect extends BoundingBox {\n  height: number;\n  width: number;\n}\n\nconst relatedDimension: { [position in EuiPopoverPosition]: Dimension } = {\n  top: 'height',\n  right: 'width',\n  bottom: 'height',\n  left: 'width',\n};\n\nconst dimensionPositionAttribute: {\n  [dimension in Dimension]: 'top' | 'left'\n} = {\n  height: 'top',\n  width: 'left',\n};\n\nconst positionComplements: {\n  [position in EuiPopoverPosition]: EuiPopoverPosition\n} = {\n  top: 'bottom',\n  right: 'left',\n  bottom: 'top',\n  left: 'right',\n};\n\n// always resolving to top/left is taken advantage of by knowing they are the\n// minimum edges of the bounding box\nconst positionSubstitutes: {\n  [position in EuiPopoverPosition]: 'left' | 'top'\n} = {\n  top: 'left',\n  right: 'top',\n  bottom: 'left',\n  left: 'top',\n};\n\ninterface FindPopoverPositionArgs {\n  anchor: HTMLElement;\n  popover: HTMLElement;\n  align?: EuiPopoverPosition;\n  position: EuiPopoverPosition;\n  forcePosition?: boolean;\n  buffer?: number;\n  offset?: number;\n  allowCrossAxis?: boolean;\n  container?: HTMLElement;\n  arrowConfig?: { arrowWidth: number; arrowBuffer: number };\n  returnBoundingBox?: boolean;\n}\n\ninterface FindPopoverPositionResult {\n  top: number;\n  left: number;\n  position: 'top' | 'right' | 'bottom' | 'left';\n  fit: number;\n  arrow?: { left: number; top: number };\n  anchorBoundingBox?: EuiClientRect;\n}\n\n/**\n * Calculates the absolute positioning (relative to document.body) to place a popover element\n *\n * @param anchor {HTMLElement} Element to anchor the popover to\n * @param popover {HTMLElement} Element containing the popover content\n * @param position {string} Position the user wants. One of [\"top\", \"right\", \"bottom\", \"left\"]\n * @param [forcePosition] {boolean} If true, use only the provided `position` value and don't try any other position\n * @param [align] {string} Cross-axis alignment. One of [\"top\", \"right\", \"bottom\", \"left\"]\n * @param [buffer=16] {number} Minimum distance between the popover and the bounding container\n * @param [offset=0] {number} Distance between the popover and the anchor\n * @param [allowCrossAxis=true] {boolean} Whether to allow the popover to be positioned on the cross-axis\n * @param [container] {HTMLElement} Element the popover must be constrained to fit within\n * @param [arrowConfig] {{arrowWidth: number, arrowBuffer: number}} If\n *  present, describes the size & constraints for an arrow element, and the\n *  function return value will include an `arrow` param with position details\n *\n * @returns {FindPopoverPositionResult} absolute page coordinates for the\n * popover, and the placements's relation to the anchor or undefined\n * there's no room.\n */\nexport function findPopoverPosition({\n  anchor,\n  popover,\n  align,\n  position,\n  forcePosition,\n  buffer = 16,\n  offset = 0,\n  allowCrossAxis = true,\n  container,\n  arrowConfig,\n  returnBoundingBox,\n}: FindPopoverPositionArgs): FindPopoverPositionResult {\n  // find the screen-relative bounding boxes of the anchor, popover, and container\n  const anchorBoundingBox = getElementBoundingBox(anchor);\n  const popoverBoundingBox = getElementBoundingBox(popover);\n\n  // calculate the window's bounds\n  // window.(innerWidth|innerHeight) do not account for scrollbars\n  // so prefer the clientWidth/clientHeight of the DOM if available\n  const documentWidth =\n    document.documentElement.clientWidth || window.innerWidth;\n  const documentHeight =\n    document.documentElement.clientHeight || window.innerHeight;\n  const windowBoundingBox: EuiClientRect = {\n    top: 0,\n    right: documentWidth,\n    bottom: documentHeight,\n    left: 0,\n    height: documentHeight,\n    width: documentWidth,\n  };\n\n  // if no container element is given fall back to using the window viewport\n  const containerBoundingBox = container\n    ? getElementBoundingBox(container)\n    : windowBoundingBox;\n\n  /**\n   * `position` was specified by the function caller and is a strong hint\n   * as to the preferred location of the popover relative to the anchor.\n   * However, we strongly prefer showing all of the popover content within\n   * the window+container boundary and will iterate over the four\n   * possible sides until a perfect fit is located. If none of the locations\n   * fully contain popover, the location with the best fit is selected.\n   *\n   * This approach first checks the preferred `position`, then its opposite\n   * along the same axis, next a location on the cross-axis, and finally it\n   * tests the remaining position.\n   *\n   * e.g.\n   * if position = \"top\" the order is top, bottom, left right\n   * if position = \"right\" the order is right, left, top, bottom\n   */\n\n  // Try the user-desired position first.\n  const iterationPositions = [position];\n  // keep user-defined alignment in the original positions.\n  const iterationAlignments: Array<undefined | EuiPopoverPosition> = [align];\n\n  if (forcePosition !== true) {\n    iterationPositions.push(positionComplements[position]); // Try the complementary position.\n    iterationAlignments.push(align); // keep user-defined alignment in the complementary position.\n\n    if (allowCrossAxis) {\n      iterationPositions.push(\n        positionSubstitutes[position], // Switch to the cross axis.\n        positionComplements[positionSubstitutes[position]] // Try the complementary position on the cross axis.\n      );\n      iterationAlignments.push(undefined, undefined); // discard desired alignment on cross-axis\n    }\n  } else {\n    // position is forced, if it conficts with the alignment then reset align to `null`\n    // e.g. original placement request for `downLeft` is moved to the `left` side, future calls\n    // will position and align `left`, and `leftLeft` is not a valid placement\n    if (\n      position === align ||\n      (align !== undefined && position === positionComplements[align])\n    ) {\n      iterationAlignments[0] = undefined;\n    }\n  }\n\n  let bestFit = -Infinity;\n  let bestPosition: FindPopoverPositionResult | null = null;\n\n  for (let idx = 0; idx < iterationPositions.length; idx++) {\n    const iterationPosition = iterationPositions[idx];\n\n    // See if we can find a position with a better fit than we've found so far.\n    const screenCoordinates = getPopoverScreenCoordinates({\n      position: iterationPosition,\n      align: iterationAlignments[idx],\n      anchorBoundingBox,\n      popoverBoundingBox,\n      windowBoundingBox,\n      containerBoundingBox,\n      offset,\n      buffer,\n      arrowConfig,\n    });\n\n    if (screenCoordinates.fit > bestFit) {\n      bestFit = screenCoordinates.fit;\n      bestPosition = {\n        fit: screenCoordinates.fit,\n        position: iterationPosition,\n        top: screenCoordinates.top + window.pageYOffset,\n        left: screenCoordinates.left + window.pageXOffset,\n        arrow: screenCoordinates.arrow,\n      };\n\n      // If we've already found the ideal fit, use that position.\n      if (bestFit === 1) {\n        break;\n      }\n    }\n\n    // If we haven't improved the fit, then continue on and try a new position.\n  }\n\n  if (bestPosition == null) {\n    throw new Error('Failed to calculate bestPosition');\n  }\n\n  if (returnBoundingBox) {\n    bestPosition.anchorBoundingBox = anchorBoundingBox;\n  }\n\n  return bestPosition;\n}\n\ninterface GetPopoverScreenCoordinatesArgs {\n  position: EuiPopoverPosition;\n  align?: EuiPopoverPosition;\n  anchorBoundingBox: EuiClientRect;\n  popoverBoundingBox: EuiClientRect;\n  windowBoundingBox: EuiClientRect;\n  containerBoundingBox: EuiClientRect;\n  arrowConfig?: { arrowWidth: number; arrowBuffer: number };\n  offset?: number;\n  buffer?: number;\n}\n\ninterface GetPopoverScreenCoordinatesResult {\n  top: number;\n  left: number;\n  fit: number;\n  arrow: { top: number; left: number } | undefined;\n}\n\n/**\n * Given a target position and the popover's surrounding context, returns either an\n * object with {top, left} screen coordinates or `null` if it's not possible to show\n * content in the target position\n * @param position {string} the target position, one of [\"top\", \"right\", \"bottom\", \"left\"]\n * @param align {string} target alignment on the cross-axis, one of [\"top\", \"right\", \"bottom\", \"left\"]\n * @param anchorBoundingBox {Object} bounding box of the anchor element\n * @param popoverBoundingBox {Object} bounding box of the popover element\n * @param windowBoundingBox {Object} bounding box of the window\n * @param containerBoundingBox {Object} bounding box of the container\n * @param [arrowConfig] {{arrowWidth: number, arrowBuffer: number}} If present, describes the size &\n *  constraints for an arrow element, and the function return value will include an `arrow` param\n *  with position details\n * @param [offset=0] {number} Distance between the popover and the anchor\n * @param [buffer=0] {number} Minimum distance between the popover's\n *  placement and the container edge\n *\n * @returns {GetPopoverScreenCoordinatesResult}\n *  object with top/left coordinates, the popover's relative position to the anchor, and how well the\n *  popover fits in the location (0.0 -> 1.0) coordinates and the popover's relative position, if\n *  there is no room in this placement then null\n */\nexport function getPopoverScreenCoordinates({\n  position,\n  align,\n  anchorBoundingBox,\n  popoverBoundingBox,\n  windowBoundingBox,\n  containerBoundingBox,\n  arrowConfig,\n  offset = 0,\n  buffer = 0,\n}: GetPopoverScreenCoordinatesArgs): GetPopoverScreenCoordinatesResult {\n  /**\n   * The goal is to find the best way to align the popover content\n   * on the given side of the anchor element. The popover prefers\n   * centering on the anchor but can shift along the cross-axis as needed.\n   *\n   * We return the top/left coordinates that best fit the popover inside\n   * the given boundaries, and also return the `fit` value which indicates\n   * what percentage of the popover is within the bounds.\n   *\n   * e.g. finding a location when position=top\n   * the preferred location is directly over the anchor\n   *\n   *        +----------------------+\n   *        |       popover        |\n   *        +----------------------+\n   *                   v\n   *            +--------------+\n   *            |    anchor    |\n   *            +--------------+\n   *\n   * but if anchor doesn't have much (or any) room on its ride side\n   * the popover will shift to the left\n   *\n   *    +----------------------+\n   *    |       popover        |\n   *    +----------------------+\n   *                   v\n   *            +--------------+\n   *            |    anchor    |\n   *            +--------------+\n   *\n   */\n\n  const crossAxisFirstSide = positionSubstitutes[position]; // \"top\" -> \"left\"\n  const crossAxisSecondSide = positionComplements[crossAxisFirstSide]; // \"left\" -> \"right\"\n  const crossAxisDimension = relatedDimension[crossAxisFirstSide]; // \"left\" -> \"width\"\n\n  const { crossAxisPosition, crossAxisArrowPosition } = getCrossAxisPosition({\n    crossAxisFirstSide,\n    crossAxisSecondSide,\n    crossAxisDimension,\n    position,\n    align,\n    buffer,\n    offset,\n    windowBoundingBox,\n    containerBoundingBox,\n    popoverBoundingBox,\n    anchorBoundingBox,\n    arrowConfig,\n  });\n\n  const primaryAxisDimension = relatedDimension[position]; // \"top\" -> \"height\"\n  const primaryAxisPositionName =\n    dimensionPositionAttribute[primaryAxisDimension]; // \"height\" -> \"top\"\n\n  const {\n    primaryAxisPosition,\n    primaryAxisArrowPosition,\n  } = getPrimaryAxisPosition({\n    position,\n    offset,\n    popoverBoundingBox,\n    anchorBoundingBox,\n    arrowConfig,\n  });\n\n  const popoverPlacement = {\n    [crossAxisFirstSide]: crossAxisPosition,\n    [primaryAxisPositionName]: primaryAxisPosition,\n  };\n\n  // calculate the fit of the popover in this location\n  // fit is in range 0.0 -> 1.0 and is the percentage of the popover which is visible in this location\n  const combinedBoundingBox = intersectBoundingBoxes(\n    windowBoundingBox,\n    containerBoundingBox\n  );\n\n  // shrink the visible bounding box by `buffer`\n  // to compute a fit value\n  combinedBoundingBox.top += buffer;\n  combinedBoundingBox.right -= buffer;\n  combinedBoundingBox.bottom -= buffer;\n  combinedBoundingBox.left += buffer;\n\n  const fit = getVisibleFit(\n    {\n      top: popoverPlacement.top,\n      right: popoverPlacement.left + popoverBoundingBox.width,\n      bottom: popoverPlacement.top + popoverBoundingBox.height,\n      left: popoverPlacement.left,\n      width: popoverBoundingBox.width,\n      height: popoverBoundingBox.height,\n    },\n    combinedBoundingBox\n  );\n\n  const arrow = arrowConfig\n    ? {\n        [crossAxisFirstSide]:\n          crossAxisArrowPosition! - popoverPlacement[crossAxisFirstSide],\n        [primaryAxisPositionName]: primaryAxisArrowPosition,\n      }\n    : undefined;\n\n  return {\n    fit,\n    top: popoverPlacement.top,\n    left: popoverPlacement.left,\n    arrow: arrow ? { left: arrow.left!, top: arrow.top! } : undefined,\n  };\n}\n\ninterface GetCrossAxisPositionArgs {\n  crossAxisFirstSide: EuiPopoverPosition;\n  crossAxisSecondSide: EuiPopoverPosition;\n  crossAxisDimension: Dimension;\n  position: EuiPopoverPosition;\n  align?: EuiPopoverPosition;\n  buffer: number;\n  offset: number;\n  windowBoundingBox: EuiClientRect;\n  containerBoundingBox: EuiClientRect;\n  popoverBoundingBox: EuiClientRect;\n  anchorBoundingBox: EuiClientRect;\n  arrowConfig?: { arrowWidth: number; arrowBuffer: number };\n}\n\ninterface CrossAxisPosition {\n  crossAxisPosition: number;\n  crossAxisArrowPosition: number | undefined;\n}\n\nfunction getCrossAxisPosition({\n  crossAxisFirstSide,\n  crossAxisSecondSide,\n  crossAxisDimension,\n  position,\n  align,\n  buffer,\n  offset,\n  windowBoundingBox,\n  containerBoundingBox,\n  popoverBoundingBox,\n  anchorBoundingBox,\n  arrowConfig,\n}: GetCrossAxisPositionArgs): CrossAxisPosition {\n  // how much of the popover overflows past either side of the anchor if its centered\n  const popoverSizeOnCrossAxis = popoverBoundingBox[crossAxisDimension];\n  const anchorSizeOnCrossAxis = anchorBoundingBox[crossAxisDimension];\n  const anchorHalfSize = anchorSizeOnCrossAxis / 2;\n\n  // the popover's original position on the cross-axis is determined by:\n  const crossAxisPositionOriginal =\n    anchorBoundingBox[crossAxisFirstSide] + // where the anchor is located\n    anchorHalfSize - // plus half anchor dimension\n    popoverSizeOnCrossAxis / 2; // less half the popover dimension\n\n  // To fit the content within both the window and container,\n  // compute the smaller of the two spaces along each edge\n  const combinedBoundingBox = intersectBoundingBoxes(\n    windowBoundingBox,\n    containerBoundingBox\n  );\n  const availableSpace = getAvailableSpace(\n    anchorBoundingBox,\n    combinedBoundingBox,\n    buffer,\n    offset,\n    position\n  );\n  const minimumSpace = arrowConfig ? arrowConfig.arrowBuffer : 0;\n\n  const contentOverflowSize =\n    (popoverSizeOnCrossAxis - anchorSizeOnCrossAxis) / 2;\n\n  let alignAmount = 0;\n  let alignDirection = 1;\n  let amountOfShiftNeeded = 0;\n  let shiftDirection = 1;\n\n  if (align != null) {\n    // no alignment, find how much the container boundary requires the content to shift\n    alignDirection = align === 'top' || align === 'left' ? 1 : -1;\n    alignAmount = contentOverflowSize;\n\n    const alignedOverflowAmount = contentOverflowSize + alignAmount;\n    const needsShift =\n      alignedOverflowAmount > availableSpace[positionComplements[align]];\n    amountOfShiftNeeded = needsShift\n      ? alignedOverflowAmount - availableSpace[positionComplements[align]]\n      : 0;\n    shiftDirection = -1 * alignDirection;\n  } else {\n    // shifting the popover to one side may yield a better fit\n    const spaceAvailableOnFirstSide = availableSpace[crossAxisFirstSide];\n    const spaceAvailableOnSecondSide = availableSpace[crossAxisSecondSide];\n\n    const isShiftTowardFirstSide =\n      spaceAvailableOnFirstSide > spaceAvailableOnSecondSide;\n    shiftDirection = isShiftTowardFirstSide ? -1 : 1;\n\n    // determine which direction has more room and the popover should shift to\n    const leastAvailableSpace = Math.min(\n      spaceAvailableOnFirstSide,\n      spaceAvailableOnSecondSide\n    );\n\n    const needsShift = contentOverflowSize > leastAvailableSpace;\n    amountOfShiftNeeded = needsShift\n      ? contentOverflowSize - leastAvailableSpace\n      : 0;\n  }\n\n  // shift over the popover if necessary\n  const shiftAmount = amountOfShiftNeeded * shiftDirection;\n  let crossAxisPosition =\n    crossAxisPositionOriginal + shiftAmount + alignAmount * alignDirection;\n\n  // if an `arrowConfig` is specified, find where to position the arrow\n  let crossAxisArrowPosition;\n  if (arrowConfig) {\n    const { arrowWidth } = arrowConfig;\n    crossAxisArrowPosition =\n      anchorBoundingBox[crossAxisFirstSide] + anchorHalfSize - arrowWidth / 2;\n\n    // make sure there's enough buffer around the arrow\n    // by calculating how how much the arrow would need to move\n    // but instead of moving the arrow, shift the popover content\n    if (crossAxisArrowPosition < crossAxisPosition + minimumSpace) {\n      // arrow is too close to the minimum side\n      const difference =\n        crossAxisPosition + minimumSpace - crossAxisArrowPosition;\n      crossAxisPosition -= difference;\n    } else if (\n      crossAxisArrowPosition + minimumSpace + arrowWidth >\n      crossAxisPosition + popoverSizeOnCrossAxis\n    ) {\n      // arrow is too close to the maximum side\n      const edge = crossAxisPosition + popoverSizeOnCrossAxis;\n      const difference =\n        crossAxisArrowPosition - (edge - minimumSpace - arrowWidth);\n      crossAxisPosition += difference;\n    }\n  }\n\n  return {\n    crossAxisPosition,\n    crossAxisArrowPosition,\n  };\n}\n\ninterface GetPrimaryAxisPositionArgs {\n  position: EuiPopoverPosition;\n  offset: number;\n  popoverBoundingBox: BoundingBox;\n  anchorBoundingBox: BoundingBox;\n  arrowConfig?: { arrowWidth: number; arrowBuffer: number };\n}\n\nfunction getPrimaryAxisPosition({\n  position,\n  offset,\n  popoverBoundingBox,\n  anchorBoundingBox,\n  arrowConfig,\n}: GetPrimaryAxisPositionArgs) {\n  // if positioning to the top or left, the target position decreases\n  // from the anchor's top or left, otherwise the position adds to the anchor's\n  const isOffsetDecreasing = position === 'top' || position === 'left';\n\n  const primaryAxisDimension = relatedDimension[position]; // \"top\" -> \"height\"\n  const popoverSizeOnPrimaryAxis = popoverBoundingBox[primaryAxisDimension];\n\n  // start at the top or left edge of the anchor element\n  const primaryAxisPositionName =\n    dimensionPositionAttribute[primaryAxisDimension]; // \"height\" -> \"top\"\n  const anchorEdgeOrigin = anchorBoundingBox[primaryAxisPositionName];\n\n  // find the popover position on the primary axis\n  const anchorSizeOnPrimaryAxis = anchorBoundingBox[primaryAxisDimension];\n  const primaryAxisOffset = isOffsetDecreasing\n    ? popoverSizeOnPrimaryAxis\n    : anchorSizeOnPrimaryAxis;\n  const contentOffset =\n    (offset + primaryAxisOffset!) * (isOffsetDecreasing ? -1 : 1);\n  const primaryAxisPosition = anchorEdgeOrigin + contentOffset;\n\n  let primaryAxisArrowPosition;\n\n  if (arrowConfig) {\n    primaryAxisArrowPosition = isOffsetDecreasing\n      ? popoverSizeOnPrimaryAxis\n      : 0;\n  }\n\n  return {\n    primaryAxisPosition,\n    primaryAxisArrowPosition,\n  };\n}\n\n/**\n * Finds the client pixel coordinate of each edge for the element's bounding box,\n * and the bounding box's width & height\n *\n * @param {HTMLElement} element\n * @returns {{top: number, right: number, bottom: number, left: number, height: number, width: number}}\n */\nexport function getElementBoundingBox(element: HTMLElement): EuiClientRect {\n  const rect = element.getBoundingClientRect();\n  return {\n    top: rect.top,\n    right: rect.right,\n    bottom: rect.bottom,\n    left: rect.left,\n    height: rect.height,\n    width: rect.width,\n  };\n}\n\n/**\n * Calculates the available content space between anchor and container\n *\n * @param {Object} anchorBoundingBox Client bounding box of the anchor element\n * @param {Object} containerBoundingBox Client bounding box of the container element\n * @param {number} buffer Minimum distance between the popover and the bounding container\n * @param {number} offset Distance between the popover and the anchor\n * @param {string} offsetSide Side the offset needs to be applied to, one\n *  of [\"top\", \"right\", \"bottom\", \"left\"]\n * @returns {{top: number, right: number, bottom: number, left: number}}\n */\nexport function getAvailableSpace(\n  anchorBoundingBox: BoundingBox,\n  containerBoundingBox: BoundingBox,\n  buffer: number,\n  offset: number,\n  offsetSide: EuiPopoverPosition\n): BoundingBox {\n  return {\n    top:\n      anchorBoundingBox.top -\n      containerBoundingBox.top -\n      buffer -\n      (offsetSide === 'top' ? offset : 0),\n    right:\n      containerBoundingBox.right -\n      anchorBoundingBox.right -\n      buffer -\n      (offsetSide === 'right' ? offset : 0),\n    bottom:\n      containerBoundingBox.bottom -\n      anchorBoundingBox.bottom -\n      buffer -\n      (offsetSide === 'bottom' ? offset : 0),\n    left:\n      anchorBoundingBox.left -\n      containerBoundingBox.left -\n      buffer -\n      (offsetSide === 'left' ? offset : 0),\n  };\n}\n\n/**\n * Computes the fit (overlap) of the content within the container, fit is in range 0.0 => 1.0\n * @param contentBoundingBox bounding box of content to calculate fit for\n * @param containerBoundingBox bounding box of container\n * @returns {number}\n */\nexport function getVisibleFit(\n  contentBoundingBox: BoundingBox,\n  containerBoundingBox: BoundingBox\n): number {\n  const intersection = intersectBoundingBoxes(\n    contentBoundingBox,\n    containerBoundingBox\n  );\n\n  if (\n    intersection.left > intersection.right ||\n    intersection.top > intersection.top\n  ) {\n    // there is no intersection, the boxes are completely separated on at least one axis\n    return 0;\n  }\n\n  const intersectionArea =\n    (intersection.right - intersection.left) *\n    (intersection.bottom - intersection.top);\n  const contentArea =\n    (contentBoundingBox.right - contentBoundingBox.left) *\n    (contentBoundingBox.bottom - contentBoundingBox.top);\n\n  return intersectionArea / contentArea;\n}\n\n/**\n * Calculates the intersection space between two bounding boxes\n *\n * @param firstBox\n * @param secondBox\n * @returns {EuiClientRect}\n */\nexport function intersectBoundingBoxes(\n  firstBox: BoundingBox,\n  secondBox: BoundingBox\n): EuiClientRect {\n  const top = Math.max(firstBox.top, secondBox.top);\n  const right = Math.min(firstBox.right, secondBox.right);\n  const bottom = Math.min(firstBox.bottom, secondBox.bottom);\n  const left = Math.max(firstBox.left, secondBox.left);\n  const height = Math.max(bottom - top, 0);\n  const width = Math.max(right - left, 0);\n\n  return {\n    top,\n    right,\n    bottom,\n    left,\n    height,\n    width,\n  };\n}\n\n/**\n * Returns the top-most defined z-index in the element's ancestor hierarchy\n * relative to the `target` element; if no z-index is defined, returns 0\n * @param element {HTMLElement}\n * @param cousin {HTMLElement}\n * @returns {number}\n */\nexport function getElementZIndex(\n  element: HTMLElement,\n  cousin: HTMLElement\n): number {\n  /**\n   * finding the z-index of `element` is not the full story\n   * its the CSS stacking context that is important\n   * take this DOM for example:\n   * body\n   *   section[z-index: 1000]\n   *     p[z-index: 500]\n   *       button\n   *   div\n   *\n   * what z-index does the `div` need to display next to `button`?\n   * the `div` and `section` are where the stacking context splits\n   * so `div` needs to copy `section`'s z-index in order to\n   * appear next to / over `button`\n   *\n   * calculate this by starting at `button` and finding its offsetParents\n   * then walk the parents from top -> down until the stacking context\n   * split is found, or if there is no split then a specific z-index is unimportant\n   */\n\n  // build the array of the element + its offset parents\n  const nodesToInspect: HTMLElement[] = [];\n  while (true) {\n    nodesToInspect.push(element);\n\n    // AFAICT this is a valid cast - the libdefs appear wrong\n    element = element.offsetParent as HTMLElement;\n\n    // stop if there is no parent\n    if (element == null) {\n      break;\n    }\n\n    // stop if the parent contains the related element\n    // as this is the z-index ancestor\n    if (element.contains(cousin)) {\n      break;\n    }\n  }\n\n  // reverse the nodes to walk from top -> element\n  nodesToInspect.reverse();\n\n  for (const node of nodesToInspect) {\n    // get this node's z-index css value\n    const zIndex = window.document\n      .defaultView!.getComputedStyle(node)\n      .getPropertyValue('z-index');\n\n    // if the z-index is not a number (e.g. \"auto\") return null, else the value\n    const parsedZIndex = parseInt(zIndex, 10);\n    if (!isNaN(parsedZIndex)) {\n      return parsedZIndex;\n    }\n  }\n\n  return 0;\n}\n"]}]}