{"remainingRequest":"/Users/chanderprall/projects/eui/node_modules/babel-loader/lib/index.js!/Users/chanderprall/projects/eui/src/services/sort/comparators.ts","dependencies":[{"path":"/Users/chanderprall/projects/eui/src/services/sort/comparators.ts","mtime":1565204170075},{"path":"/Users/chanderprall/projects/eui/.babelrc.js","mtime":1565204168946},{"path":"/Users/chanderprall/projects/eui/node_modules/cache-loader/dist/cjs.js","mtime":1555436064329},{"path":"/Users/chanderprall/projects/eui/node_modules/babel-loader/lib/index.js","mtime":1543517280769}],"contextDependencies":[],"result":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Comparators = void 0;\n\nrequire(\"core-js/modules/es6.object.freeze\");\n\nvar _sort_direction = require(\"./sort_direction\");\n\nvar _objects = require(\"../objects\");\n\nvar Comparators = Object.freeze({\n  default: function _default() {\n    var direction = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : _sort_direction.SortDirection.ASC;\n    return function (v1, v2) {\n      // JavaScript's comparison of null/undefined (and some others not handled here) values always returns `false`\n      // (https://www.ecma-international.org/ecma-262/#sec-abstract-relational-comparison)\n      // resulting in cases where v1 < v2 and v1 > v2 are both false.\n      // This leads to unpredictable sorting results in multiple JS engine sorting algorithms\n      // which causes unpredictable user experiences.\n      // Instead:\n      // * 1. push undefined/null values to the end of the sorted list, _regardless of sort direction_\n      //    (non-sortable values always appear at the end, and sortable values are sorted at the top)\n      // * 2. report undefined/null values as equal\n      // * 3. when both values are comparable they are sorted normally\n      var v1IsComparable = v1 != null;\n      var v2IsComparable = v2 != null; // * 1.\n\n      if (v1IsComparable && !v2IsComparable) {\n        return -1;\n      }\n\n      if (!v1IsComparable && v2IsComparable) {\n        return 1;\n      } // * 2.\n\n\n      if (!v1IsComparable && !v2IsComparable) {\n        return 0;\n      } // * 3.\n\n\n      if (v1 === v2) {\n        return 0;\n      }\n\n      var result = v1 > v2 ? 1 : -1;\n      return _sort_direction.SortDirection.isAsc(direction) ? result : -1 * result;\n    };\n  },\n  reverse: function reverse(comparator) {\n    return function (v1, v2) {\n      return comparator(v2, v1);\n    };\n  },\n  value: function value(valueCallback, comparator) {\n    if (!comparator) {\n      comparator = this.default(_sort_direction.SortDirection.ASC);\n    }\n\n    return function (o1, o2) {\n      return comparator(valueCallback(o1), valueCallback(o2));\n    };\n  },\n  property: function property(prop, comparator) {\n    return this.value(function (value) {\n      return (0, _objects.get)(value, prop);\n    }, comparator);\n  }\n});\nexports.Comparators = Comparators;",{"version":3,"sources":["/Users/chanderprall/projects/eui/src/services/sort/comparators.ts"],"names":["Comparators","Object","freeze","default","direction","SortDirection","ASC","v1","v2","v1IsComparable","v2IsComparable","result","isAsc","reverse","comparator","value","valueCallback","o1","o2","property","prop"],"mappings":";;;;;;;;;AAAA;;AACA;;AAMO,IAAMA,WAAW,GAAGC,MAAM,CAACC,MAAP,CAAc;AACvCC,EAAAA,OAAO,EAAE,oBAAmD;AAAA,QAAlDC,SAAkD,uEAAtBC,8BAAcC,GAAQ;AAC1D,WAAO,UAACC,EAAD,EAAgBC,EAAhB,EAAkC;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA,UAAMC,cAAc,GAAGF,EAAE,IAAI,IAA7B;AACA,UAAMG,cAAc,GAAGF,EAAE,IAAI,IAA7B,CAbuC,CAevC;;AACA,UAAIC,cAAc,IAAI,CAACC,cAAvB,EAAuC;AACrC,eAAO,CAAC,CAAR;AACD;;AACD,UAAI,CAACD,cAAD,IAAmBC,cAAvB,EAAuC;AACrC,eAAO,CAAP;AACD,OArBsC,CAuBvC;;;AACA,UAAI,CAACD,cAAD,IAAmB,CAACC,cAAxB,EAAwC;AACtC,eAAO,CAAP;AACD,OA1BsC,CA4BvC;;;AACA,UAAIH,EAAE,KAAKC,EAAX,EAAe;AACb,eAAO,CAAP;AACD;;AACD,UAAMG,MAAM,GAAGJ,EAAE,GAAIC,EAAN,GAAY,CAAZ,GAAgB,CAAC,CAAhC;AACA,aAAOH,8BAAcO,KAAd,CAAoBR,SAApB,IAAiCO,MAAjC,GAA0C,CAAC,CAAD,GAAKA,MAAtD;AACD,KAlCD;AAmCD,GArCsC;AAuCvCE,EAAAA,OAAO,EAAG,iBAAGC,UAAH,EAAgD;AACxD,WAAO,UAACP,EAAD,EAAKC,EAAL;AAAA,aAAYM,UAAU,CAACN,EAAD,EAAKD,EAAL,CAAtB;AAAA,KAAP;AACD,GAzCsC;AA2CvCQ,EAAAA,KA3CuC,iBA4CrCC,aA5CqC,EA6CrCF,UA7CqC,EA8CtB;AACf,QAAI,CAACA,UAAL,EAAiB;AACfA,MAAAA,UAAU,GAAG,KAAKX,OAAL,CAAaE,8BAAcC,GAA3B,CAAb;AACD;;AACD,WAAO,UAACW,EAAD,EAAQC,EAAR,EAAkB;AACvB,aAAOJ,UAAU,CAAEE,aAAa,CAACC,EAAD,CAAf,EAAqBD,aAAa,CAACE,EAAD,CAAlC,CAAjB;AACD,KAFD;AAGD,GArDsC;AAuDvCC,EAAAA,QAvDuC,oBAuD3BC,IAvD2B,EAuDbN,UAvDa,EAuD2B;AAChE,WAAO,KAAKC,KAAL,CAAW,UAAAA,KAAK;AAAA,aAAI,kBAAIA,KAAJ,EAAWK,IAAX,CAAJ;AAAA,KAAhB,EAAsCN,UAAtC,CAAP;AACD;AAzDsC,CAAd,CAApB","sourcesContent":["import { SortDirection } from './sort_direction';\nimport { get } from '../objects';\n\nexport type Primitive = string | boolean | number | null | undefined;\n\ntype Comparator<T = Primitive> = (a: T, b: T) => number;\n\nexport const Comparators = Object.freeze({\n  default: (direction: 'asc' | 'desc' = SortDirection.ASC) => {\n    return (v1: Primitive, v2: Primitive) => {\n      // JavaScript's comparison of null/undefined (and some others not handled here) values always returns `false`\n      // (https://www.ecma-international.org/ecma-262/#sec-abstract-relational-comparison)\n      // resulting in cases where v1 < v2 and v1 > v2 are both false.\n      // This leads to unpredictable sorting results in multiple JS engine sorting algorithms\n      // which causes unpredictable user experiences.\n      // Instead:\n      // * 1. push undefined/null values to the end of the sorted list, _regardless of sort direction_\n      //    (non-sortable values always appear at the end, and sortable values are sorted at the top)\n      // * 2. report undefined/null values as equal\n      // * 3. when both values are comparable they are sorted normally\n\n      const v1IsComparable = v1 != null;\n      const v2IsComparable = v2 != null;\n\n      // * 1.\n      if (v1IsComparable && !v2IsComparable) {\n        return -1;\n      }\n      if (!v1IsComparable && v2IsComparable) {\n        return 1;\n      }\n\n      // * 2.\n      if (!v1IsComparable && !v2IsComparable) {\n        return 0;\n      }\n\n      // * 3.\n      if (v1 === v2) {\n        return 0;\n      }\n      const result = v1! > v2! ? 1 : -1;\n      return SortDirection.isAsc(direction) ? result : -1 * result;\n    };\n  },\n\n  reverse: <T>(comparator: Comparator<T>): Comparator<T> => {\n    return (v1, v2) => comparator(v2, v1);\n  },\n\n  value<T>(\n    valueCallback: (value: T) => Primitive,\n    comparator?: Comparator\n  ): Comparator<T> {\n    if (!comparator) {\n      comparator = this.default(SortDirection.ASC);\n    }\n    return (o1: T, o2: T) => {\n      return comparator!(valueCallback(o1), valueCallback(o2));\n    };\n  },\n\n  property<T>(prop: string, comparator?: Comparator): Comparator<T> {\n    return this.value(value => get(value, prop), comparator);\n  },\n});\n"]}]}