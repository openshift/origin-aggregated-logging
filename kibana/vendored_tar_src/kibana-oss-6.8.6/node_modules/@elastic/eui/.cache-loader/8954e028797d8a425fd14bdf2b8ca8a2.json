{"remainingRequest":"/Users/chanderprall/projects/eui/node_modules/babel-loader/lib/index.js!/Users/chanderprall/projects/eui/src/components/search_bar/query/execute_ast.js","dependencies":[{"path":"/Users/chanderprall/projects/eui/src/components/search_bar/query/execute_ast.js","mtime":1565204169988},{"path":"/Users/chanderprall/projects/eui/.babelrc.js","mtime":1565204168946},{"path":"/Users/chanderprall/projects/eui/node_modules/cache-loader/dist/cjs.js","mtime":1555436064329},{"path":"/Users/chanderprall/projects/eui/node_modules/babel-loader/lib/index.js","mtime":1543517280769}],"contextDependencies":[],"result":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.executeAst = exports.createFilter = void 0;\n\nrequire(\"core-js/modules/web.dom.iterable\");\n\nrequire(\"core-js/modules/es6.array.iterator\");\n\nrequire(\"core-js/modules/es6.object.keys\");\n\nrequire(\"core-js/modules/es6.regexp.match\");\n\nvar _objects = require(\"../../../services/objects\");\n\nvar _predicate = require(\"../../../services/predicate\");\n\nvar _operators = require(\"./operators\");\n\nvar _ast = require(\"./ast\");\n\nvar _nameToOperatorMap;\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nvar EXPLAIN_FIELD = '__explain';\nvar nameToOperatorMap = (_nameToOperatorMap = {}, _defineProperty(_nameToOperatorMap, _ast.AST.Operator.EQ, _operators.eq), _defineProperty(_nameToOperatorMap, _ast.AST.Operator.EXACT, _operators.exact), _defineProperty(_nameToOperatorMap, _ast.AST.Operator.GT, _operators.gt), _defineProperty(_nameToOperatorMap, _ast.AST.Operator.GTE, _operators.gte), _defineProperty(_nameToOperatorMap, _ast.AST.Operator.LT, _operators.lt), _defineProperty(_nameToOperatorMap, _ast.AST.Operator.LTE, _operators.lte), _nameToOperatorMap);\n\nvar defaultIsClauseMatcher = function defaultIsClauseMatcher(item, clause, explain) {\n  var type = clause.type,\n      flag = clause.flag,\n      match = clause.match;\n  var value = (0, _objects.get)(item, clause.flag);\n\n  var must = _ast.AST.Match.isMustClause(clause);\n\n  var hit = !!value === must;\n\n  if (explain && hit) {\n    explain.push({\n      hit: hit,\n      type: type,\n      flag: flag,\n      match: match\n    });\n  }\n\n  return hit;\n};\n\nvar fieldClauseMatcher = function fieldClauseMatcher(item, field) {\n  var clauses = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n  var explain = arguments.length > 3 ? arguments[3] : undefined;\n  return clauses.every(function (clause) {\n    var type = clause.type,\n        value = clause.value,\n        match = clause.match;\n    var operator = nameToOperatorMap[clause.operator];\n\n    if (!operator) {\n      // unknown matcher\n      return true;\n    }\n\n    if (!_ast.AST.Match.isMust(match)) {\n      operator = function operator(value, token) {\n        return !nameToOperatorMap[clause.operator](value, token);\n      };\n    }\n\n    var itemValue = (0, _objects.get)(item, field);\n    var hit = (0, _predicate.isArray)(value) ? value.some(function (v) {\n      return operator(itemValue, v);\n    }) : operator(itemValue, value);\n\n    if (explain && hit) {\n      explain.push({\n        hit: hit,\n        type: type,\n        field: field,\n        value: value,\n        match: match,\n        operator: operator\n      });\n    }\n\n    return hit;\n  });\n};\n\nvar extractStringFieldsFromItem = function extractStringFieldsFromItem(item) {\n  return Object.keys(item).reduce(function (fields, key) {\n    if ((0, _predicate.isString)(item[key])) {\n      fields.push(key);\n    }\n\n    return fields;\n  }, []);\n};\n\nvar termClauseMatcher = function termClauseMatcher(item, fields) {\n  var clauses = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n  var explain = arguments.length > 3 ? arguments[3] : undefined;\n  var searchableFields = fields || extractStringFieldsFromItem(item);\n  return clauses.every(function (clause) {\n    var type = clause.type,\n        value = clause.value,\n        match = clause.match;\n\n    var isMustClause = _ast.AST.Match.isMustClause(clause);\n\n    var equals = nameToOperatorMap[_ast.AST.Operator.EQ];\n    var containsMatches = searchableFields.some(function (field) {\n      var itemValue = (0, _objects.get)(item, field);\n      var isMatch = equals(itemValue, value);\n\n      if (explain) {\n        // If testing for the presence of a term, then we record a match as a match.\n        // If testing for the absence of a term, then we invert this logic: we record a\n        // non-match as a match.\n        var hit = isMustClause && isMatch || !isMustClause && !isMatch;\n\n        if (hit) {\n          explain.push({\n            hit: hit,\n            type: type,\n            field: field,\n            match: match,\n            value: value\n          });\n        }\n      }\n\n      return isMatch;\n    });\n\n    if (isMustClause) {\n      // If we're testing for the presence of a term, then we only need 1 field to match.\n      return containsMatches;\n    } // If we're testing for the absence of a term, we can't have any matching fields at all.\n\n\n    return !containsMatches;\n  });\n};\n\nvar createFilter = function createFilter(ast, defaultFields) {\n  var isClauseMatcher = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : defaultIsClauseMatcher;\n  var explain = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n  // Return items which pass ALL conditions: matches the terms entered, the specified field values,\n  // and the specified \"is\" clauses.\n  return function (item) {\n    var explainLines = explain ? [] : undefined;\n\n    if (explainLines) {\n      item[EXPLAIN_FIELD] = explainLines;\n    }\n\n    var termClauses = ast.getTermClauses();\n    var fields = ast.getFieldNames();\n    var isClauses = ast.getIsClauses();\n    var groupClauses = ast.getGroupClauses();\n    var isTermMatch = termClauseMatcher(item, defaultFields, termClauses, explainLines);\n\n    if (!isTermMatch) {\n      return false;\n    }\n\n    var isFieldsMatch = fields.every(function (field) {\n      return fieldClauseMatcher(item, field, ast.getFieldClauses(field), explainLines);\n    });\n\n    if (!isFieldsMatch) {\n      return false;\n    }\n\n    var isIsMatch = isClauses.every(function (clause) {\n      return isClauseMatcher(item, clause, explainLines);\n    });\n\n    if (!isIsMatch) {\n      return false;\n    }\n\n    var isGroupMatch = groupClauses.every(function (clause) {\n      var matchesGroup = clause.value.some(function (clause) {\n        if (_ast.AST.Term.isInstance(clause)) {\n          return termClauseMatcher(item, defaultFields, [clause], explainLines);\n        }\n\n        if (_ast.AST.Field.isInstance(clause)) {\n          return fieldClauseMatcher(item, clause.field, [clause], explainLines);\n        }\n\n        if (_ast.AST.Is.isInstance(clause)) {\n          return isClauseMatcher(item, clause, explainLines);\n        }\n\n        throw new Error(\"Unknown query clause type in group, [\".concat(clause.type, \"]\"));\n      });\n      return _ast.AST.Match.isMustClause(clause) ? matchesGroup : !matchesGroup;\n    });\n    return isGroupMatch;\n  };\n};\n\nexports.createFilter = createFilter;\n\nvar executeAst = function executeAst(ast, items) {\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  var isClauseMatcher = options.isClauseMatcher,\n      defaultFields = options.defaultFields,\n      explain = options.explain;\n  var filter = createFilter(ast, defaultFields, isClauseMatcher, explain);\n  return items.filter(filter);\n};\n\nexports.executeAst = executeAst;",{"version":3,"sources":["/Users/chanderprall/projects/eui/src/components/search_bar/query/execute_ast.js"],"names":["EXPLAIN_FIELD","nameToOperatorMap","AST","Operator","EQ","eq","EXACT","exact","GT","gt","GTE","gte","LT","lt","LTE","lte","defaultIsClauseMatcher","item","clause","explain","type","flag","match","value","must","Match","isMustClause","hit","push","fieldClauseMatcher","field","clauses","every","operator","isMust","token","itemValue","some","v","extractStringFieldsFromItem","Object","keys","reduce","fields","key","termClauseMatcher","searchableFields","equals","containsMatches","isMatch","createFilter","ast","defaultFields","isClauseMatcher","explainLines","undefined","termClauses","getTermClauses","getFieldNames","isClauses","getIsClauses","groupClauses","getGroupClauses","isTermMatch","isFieldsMatch","getFieldClauses","isIsMatch","isGroupMatch","matchesGroup","Term","isInstance","Field","Is","Error","executeAst","items","options","filter"],"mappings":"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","sourcesContent":["import { get } from '../../../services/objects';\nimport { isString, isArray } from '../../../services/predicate';\nimport { eq, exact, gt, gte, lt, lte } from './operators';\nimport { AST } from './ast';\n\nconst EXPLAIN_FIELD = '__explain';\n\nconst nameToOperatorMap = {\n  [AST.Operator.EQ]: eq,\n  [AST.Operator.EXACT]: exact,\n  [AST.Operator.GT]: gt,\n  [AST.Operator.GTE]: gte,\n  [AST.Operator.LT]: lt,\n  [AST.Operator.LTE]: lte,\n};\n\nconst defaultIsClauseMatcher = (item, clause, explain) => {\n  const { type, flag, match } = clause;\n  const value = get(item, clause.flag);\n  const must = AST.Match.isMustClause(clause);\n  const hit = !!value === must;\n  if (explain && hit) {\n    explain.push({ hit, type, flag, match });\n  }\n  return hit;\n};\n\nconst fieldClauseMatcher = (item, field, clauses = [], explain) => {\n  return clauses.every(clause => {\n    const { type, value, match } = clause;\n    let operator = nameToOperatorMap[clause.operator];\n    if (!operator) {\n      // unknown matcher\n      return true;\n    }\n    if (!AST.Match.isMust(match)) {\n      operator = (value, token) =>\n        !nameToOperatorMap[clause.operator](value, token);\n    }\n    const itemValue = get(item, field);\n    const hit = isArray(value)\n      ? value.some(v => operator(itemValue, v))\n      : operator(itemValue, value);\n    if (explain && hit) {\n      explain.push({ hit, type, field, value, match, operator });\n    }\n    return hit;\n  });\n};\n\nconst extractStringFieldsFromItem = item => {\n  return Object.keys(item).reduce((fields, key) => {\n    if (isString(item[key])) {\n      fields.push(key);\n    }\n    return fields;\n  }, []);\n};\n\nconst termClauseMatcher = (item, fields, clauses = [], explain) => {\n  const searchableFields = fields || extractStringFieldsFromItem(item);\n  return clauses.every(clause => {\n    const { type, value, match } = clause;\n    const isMustClause = AST.Match.isMustClause(clause);\n    const equals = nameToOperatorMap[AST.Operator.EQ];\n\n    const containsMatches = searchableFields.some(field => {\n      const itemValue = get(item, field);\n      const isMatch = equals(itemValue, value);\n\n      if (explain) {\n        // If testing for the presence of a term, then we record a match as a match.\n        // If testing for the absence of a term, then we invert this logic: we record a\n        // non-match as a match.\n        const hit = (isMustClause && isMatch) || (!isMustClause && !isMatch);\n        if (hit) {\n          explain.push({ hit, type, field, match, value });\n        }\n      }\n\n      return isMatch;\n    });\n\n    if (isMustClause) {\n      // If we're testing for the presence of a term, then we only need 1 field to match.\n      return containsMatches;\n    }\n\n    // If we're testing for the absence of a term, we can't have any matching fields at all.\n    return !containsMatches;\n  });\n};\n\nexport const createFilter = (\n  ast,\n  defaultFields,\n  isClauseMatcher = defaultIsClauseMatcher,\n  explain = false\n) => {\n  // Return items which pass ALL conditions: matches the terms entered, the specified field values,\n  // and the specified \"is\" clauses.\n  return item => {\n    const explainLines = explain ? [] : undefined;\n\n    if (explainLines) {\n      item[EXPLAIN_FIELD] = explainLines;\n    }\n\n    const termClauses = ast.getTermClauses();\n    const fields = ast.getFieldNames();\n    const isClauses = ast.getIsClauses();\n    const groupClauses = ast.getGroupClauses();\n\n    const isTermMatch = termClauseMatcher(\n      item,\n      defaultFields,\n      termClauses,\n      explainLines\n    );\n    if (!isTermMatch) {\n      return false;\n    }\n\n    const isFieldsMatch = fields.every(field =>\n      fieldClauseMatcher(item, field, ast.getFieldClauses(field), explainLines)\n    );\n    if (!isFieldsMatch) {\n      return false;\n    }\n\n    const isIsMatch = isClauses.every(clause =>\n      isClauseMatcher(item, clause, explainLines)\n    );\n    if (!isIsMatch) {\n      return false;\n    }\n\n    const isGroupMatch = groupClauses.every(clause => {\n      const matchesGroup = clause.value.some(clause => {\n        if (AST.Term.isInstance(clause)) {\n          return termClauseMatcher(item, defaultFields, [clause], explainLines);\n        }\n        if (AST.Field.isInstance(clause)) {\n          return fieldClauseMatcher(item, clause.field, [clause], explainLines);\n        }\n        if (AST.Is.isInstance(clause)) {\n          return isClauseMatcher(item, clause, explainLines);\n        }\n        throw new Error(`Unknown query clause type in group, [${clause.type}]`);\n      });\n      return AST.Match.isMustClause(clause) ? matchesGroup : !matchesGroup;\n    });\n\n    return isGroupMatch;\n  };\n};\n\nexport const executeAst = (ast, items, options = {}) => {\n  const { isClauseMatcher, defaultFields, explain } = options;\n  const filter = createFilter(ast, defaultFields, isClauseMatcher, explain);\n  return items.filter(filter);\n};\n"]}]}