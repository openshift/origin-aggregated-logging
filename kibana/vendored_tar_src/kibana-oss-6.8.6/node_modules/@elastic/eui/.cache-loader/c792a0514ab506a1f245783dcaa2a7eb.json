{"remainingRequest":"/Users/chanderprall/projects/eui/node_modules/babel-loader/lib/index.js!/Users/chanderprall/projects/eui/src/components/tabs/tabbed_content/tabbed_content.js","dependencies":[{"path":"/Users/chanderprall/projects/eui/src/components/tabs/tabbed_content/tabbed_content.js","mtime":1565204170035},{"path":"/Users/chanderprall/projects/eui/.babelrc.js","mtime":1565204168946},{"path":"/Users/chanderprall/projects/eui/node_modules/cache-loader/dist/cjs.js","mtime":1555436064329},{"path":"/Users/chanderprall/projects/eui/node_modules/babel-loader/lib/index.js","mtime":1543517280769}],"contextDependencies":[],"result":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.EuiTabbedContent = exports.AUTOFOCUS = void 0;\n\nrequire(\"core-js/modules/es7.symbol.async-iterator\");\n\nrequire(\"core-js/modules/es6.symbol\");\n\nrequire(\"core-js/modules/es6.object.assign\");\n\nrequire(\"core-js/modules/web.dom.iterable\");\n\nrequire(\"core-js/modules/es6.array.iterator\");\n\nrequire(\"core-js/modules/es6.object.keys\");\n\nrequire(\"core-js/modules/es6.object.set-prototype-of\");\n\nrequire(\"core-js/modules/es6.function.name\");\n\nrequire(\"core-js/modules/es6.array.find\");\n\nvar _react = _interopRequireWildcard(require(\"react\"));\n\nvar _propTypes = _interopRequireDefault(require(\"prop-types\"));\n\nvar _services = require(\"../../../services\");\n\nvar _tabs = require(\"../tabs\");\n\nvar _tab = require(\"../tab\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }\n\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nvar makeId = (0, _services.htmlIdGenerator)();\nvar AUTOFOCUS = ['initial', 'selected'];\nexports.AUTOFOCUS = AUTOFOCUS;\n\nvar EuiTabbedContent =\n/*#__PURE__*/\nfunction (_Component) {\n  _inherits(EuiTabbedContent, _Component);\n\n  function EuiTabbedContent(props) {\n    var _this;\n\n    _classCallCheck(this, EuiTabbedContent);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(EuiTabbedContent).call(this, props));\n\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"initializeFocus\", function () {\n      if (!_this.state.inFocus && _this.props.autoFocus === 'selected') {\n        // Must wait for setState to finish before calling `.focus()`\n        // as the focus call triggers a blur on the first tab\n        _this.setState({\n          inFocus: true\n        }, function () {\n          var targetTab = _this.divRef.current.querySelector(\"#\".concat(_this.state.selectedTabId));\n\n          targetTab.focus();\n        });\n      }\n    });\n\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"removeFocus\", function (blurEvent) {\n      // only set inFocus to false if the wrapping div doesn't contain the now-focusing element\n      if (blurEvent.currentTarget.contains(blurEvent.relatedTarget) === false) {\n        _this.setState({\n          inFocus: false\n        });\n      }\n    });\n\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"onTabClick\", function (selectedTab) {\n      var _this$props = _this.props,\n          onTabClick = _this$props.onTabClick,\n          externalSelectedTab = _this$props.selectedTab;\n\n      if (onTabClick) {\n        onTabClick(selectedTab);\n      } // Only track selection state if it's not controlled externally.\n\n\n      if (!externalSelectedTab) {\n        _this.setState({\n          selectedTabId: selectedTab.id\n        });\n      }\n    });\n\n    var initialSelectedTab = props.initialSelectedTab,\n        _selectedTab = props.selectedTab,\n        tabs = props.tabs;\n    _this.rootId = makeId();\n    _this.divRef = (0, _react.createRef)(); // Only track selection state if it's not controlled externally.\n\n    var selectedTabId;\n\n    if (!_selectedTab) {\n      selectedTabId = initialSelectedTab && initialSelectedTab.id || tabs[0].id;\n    }\n\n    _this.state = {\n      selectedTabId: selectedTabId,\n      inFocus: false\n    };\n    return _this;\n  }\n\n  _createClass(EuiTabbedContent, [{\n    key: \"componentDidMount\",\n    value: function componentDidMount() {\n      // IE11 doesn't support the `relatedTarget` event property for blur events\n      // but does add it for focusout. React doesn't support `onFocusOut` so here we are.\n      if (this.divRef.current) {\n        this.divRef.current.addEventListener('focusout', this.removeFocus);\n      }\n    }\n  }, {\n    key: \"componentWillUnmount\",\n    value: function componentWillUnmount() {\n      if (this.divRef.current) {\n        this.divRef.current.removeEventListener('focusout', this.removeFocus);\n      }\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      var _this2 = this;\n\n      var _this$props2 = this.props,\n          className = _this$props2.className,\n          display = _this$props2.display,\n          expand = _this$props2.expand,\n          initialSelectedTab = _this$props2.initialSelectedTab,\n          onTabClick = _this$props2.onTabClick,\n          externalSelectedTab = _this$props2.selectedTab,\n          size = _this$props2.size,\n          tabs = _this$props2.tabs,\n          autoFocus = _this$props2.autoFocus,\n          rest = _objectWithoutProperties(_this$props2, [\"className\", \"display\", \"expand\", \"initialSelectedTab\", \"onTabClick\", \"selectedTab\", \"size\", \"tabs\", \"autoFocus\"]); // Allow the consumer to control tab selection.\n\n\n      var selectedTab = externalSelectedTab || tabs.find(function (tab) {\n        return tab.id === _this2.state.selectedTabId;\n      });\n      var selectedTabContent = selectedTab.content,\n          selectedTabId = selectedTab.id;\n      return _react.default.createElement(\"div\", _extends({\n        ref: this.divRef,\n        className: className\n      }, rest, {\n        onFocus: this.initializeFocus\n      }), _react.default.createElement(_tabs.EuiTabs, {\n        expand: expand,\n        display: display,\n        size: size\n      }, tabs.map(function (tab) {\n        var id = tab.id,\n            name = tab.name,\n            content = tab.content,\n            tabProps = _objectWithoutProperties(tab, [\"id\", \"name\", \"content\"]);\n\n        var props = _objectSpread({\n          key: id,\n          id: id\n        }, tabProps, {\n          onClick: function onClick() {\n            return _this2.onTabClick(tab);\n          },\n          isSelected: tab === selectedTab,\n          'aria-controls': \"\".concat(_this2.rootId)\n        });\n\n        return _react.default.createElement(_tab.EuiTab, props, name);\n      })), _react.default.createElement(\"div\", {\n        role: \"tabpanel\",\n        id: \"\".concat(this.rootId),\n        \"aria-labelledby\": selectedTabId\n      }, selectedTabContent));\n    }\n  }]);\n\n  return EuiTabbedContent;\n}(_react.Component);\n\nexports.EuiTabbedContent = EuiTabbedContent;\n\n_defineProperty(EuiTabbedContent, \"propTypes\", {\n  className: _propTypes.default.string,\n\n  /**\n   * Choose `default` or alternative `condensed` display styles\n   */\n  display: _propTypes.default.oneOf(_tabs.DISPLAYS),\n\n  /**\n   * Evenly stretches each tab to fill the horizontal space\n   */\n  expand: _propTypes.default.bool,\n\n  /**\n   * Use this prop to set the initially selected tab while letting the tabbed content component\n   * control selection state internally\n   */\n  initialSelectedTab: _propTypes.default.object,\n  onTabClick: _propTypes.default.func,\n\n  /**\n   * Use this prop if you want to control selection state within the owner component\n   */\n  selectedTab: _propTypes.default.object,\n\n  /**\n   * When tabbing into the tabs, set the focus on `initial` for the first tab,\n   * or `selected` for the currently selected tab. Best use case is for inside of\n   * overlay content like popovers or flyouts.\n   */\n  autoFocus: _propTypes.default.oneOf(AUTOFOCUS),\n  size: _propTypes.default.oneOf(_tabs.SIZES),\n\n  /**\n   * Each tab needs id and content properties, so we can associate it with its panel for accessibility.\n   * The name property is also required to display to the user.\n   */\n  tabs: _propTypes.default.arrayOf(_propTypes.default.shape({\n    content: _propTypes.default.node.isRequired,\n    id: _propTypes.default.string.isRequired,\n    name: _propTypes.default.string.isRequired\n  })).isRequired\n});\n\nEuiTabbedContent.defaultProps = {\n  autoFocus: 'initial'\n};\nEuiTabbedContent.__docgenInfo = {\n  \"description\": \"\",\n  \"methods\": [{\n    \"name\": \"initializeFocus\",\n    \"docblock\": null,\n    \"modifiers\": [],\n    \"params\": [],\n    \"returns\": null\n  }, {\n    \"name\": \"removeFocus\",\n    \"docblock\": null,\n    \"modifiers\": [],\n    \"params\": [{\n      \"name\": \"blurEvent\",\n      \"type\": null\n    }],\n    \"returns\": null\n  }, {\n    \"name\": \"onTabClick\",\n    \"docblock\": null,\n    \"modifiers\": [],\n    \"params\": [{\n      \"name\": \"selectedTab\",\n      \"type\": null\n    }],\n    \"returns\": null\n  }],\n  \"displayName\": \"EuiTabbedContent\",\n  \"props\": {\n    \"autoFocus\": {\n      \"defaultValue\": {\n        \"value\": \"'initial'\",\n        \"computed\": false\n      },\n      \"type\": {\n        \"name\": \"enum\",\n        \"value\": [{\n          \"value\": \"'initial'\",\n          \"computed\": false\n        }, {\n          \"value\": \"'selected'\",\n          \"computed\": false\n        }]\n      },\n      \"required\": false,\n      \"description\": \"When tabbing into the tabs, set the focus on `initial` for the first tab,\\nor `selected` for the currently selected tab. Best use case is for inside of\\noverlay content like popovers or flyouts.\"\n    },\n    \"className\": {\n      \"type\": {\n        \"name\": \"string\"\n      },\n      \"required\": false,\n      \"description\": \"\"\n    },\n    \"display\": {\n      \"type\": {\n        \"name\": \"enum\",\n        \"computed\": true,\n        \"value\": \"DISPLAYS\"\n      },\n      \"required\": false,\n      \"description\": \"Choose `default` or alternative `condensed` display styles\"\n    },\n    \"expand\": {\n      \"type\": {\n        \"name\": \"bool\"\n      },\n      \"required\": false,\n      \"description\": \"Evenly stretches each tab to fill the horizontal space\"\n    },\n    \"initialSelectedTab\": {\n      \"type\": {\n        \"name\": \"object\"\n      },\n      \"required\": false,\n      \"description\": \"Use this prop to set the initially selected tab while letting the tabbed content component\\ncontrol selection state internally\"\n    },\n    \"onTabClick\": {\n      \"type\": {\n        \"name\": \"func\"\n      },\n      \"required\": false,\n      \"description\": \"\"\n    },\n    \"selectedTab\": {\n      \"type\": {\n        \"name\": \"object\"\n      },\n      \"required\": false,\n      \"description\": \"Use this prop if you want to control selection state within the owner component\"\n    },\n    \"size\": {\n      \"type\": {\n        \"name\": \"enum\",\n        \"computed\": true,\n        \"value\": \"SIZES\"\n      },\n      \"required\": false,\n      \"description\": \"\"\n    },\n    \"tabs\": {\n      \"type\": {\n        \"name\": \"arrayOf\",\n        \"value\": {\n          \"name\": \"shape\",\n          \"value\": {\n            \"content\": {\n              \"name\": \"node\",\n              \"required\": true\n            },\n            \"id\": {\n              \"name\": \"string\",\n              \"required\": true\n            },\n            \"name\": {\n              \"name\": \"string\",\n              \"required\": true\n            }\n          }\n        }\n      },\n      \"required\": true,\n      \"description\": \"Each tab needs id and content properties, so we can associate it with its panel for accessibility.\\nThe name property is also required to display to the user.\"\n    }\n  }\n};",{"version":3,"sources":["/Users/chanderprall/projects/eui/src/components/tabs/tabbed_content/tabbed_content.js"],"names":["makeId","AUTOFOCUS","EuiTabbedContent","props","state","inFocus","autoFocus","setState","targetTab","divRef","current","querySelector","selectedTabId","focus","blurEvent","currentTarget","contains","relatedTarget","selectedTab","onTabClick","externalSelectedTab","id","initialSelectedTab","tabs","rootId","addEventListener","removeFocus","removeEventListener","className","display","expand","size","rest","find","tab","selectedTabContent","content","initializeFocus","map","name","tabProps","key","onClick","isSelected","Component","PropTypes","string","oneOf","DISPLAYS","bool","object","func","SIZES","arrayOf","shape","node","isRequired","defaultProps"],"mappings":"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","sourcesContent":["import React, { Component, createRef } from 'react';\nimport PropTypes from 'prop-types';\n\nimport { htmlIdGenerator } from '../../../services';\n\nimport { EuiTabs, DISPLAYS, SIZES } from '../tabs';\nimport { EuiTab } from '../tab';\n\nconst makeId = htmlIdGenerator();\n\nexport const AUTOFOCUS = ['initial', 'selected'];\n\nexport class EuiTabbedContent extends Component {\n  static propTypes = {\n    className: PropTypes.string,\n    /**\n     * Choose `default` or alternative `condensed` display styles\n     */\n    display: PropTypes.oneOf(DISPLAYS),\n    /**\n     * Evenly stretches each tab to fill the horizontal space\n     */\n    expand: PropTypes.bool,\n    /**\n     * Use this prop to set the initially selected tab while letting the tabbed content component\n     * control selection state internally\n     */\n    initialSelectedTab: PropTypes.object,\n    onTabClick: PropTypes.func,\n    /**\n     * Use this prop if you want to control selection state within the owner component\n     */\n    selectedTab: PropTypes.object,\n    /**\n     * When tabbing into the tabs, set the focus on `initial` for the first tab,\n     * or `selected` for the currently selected tab. Best use case is for inside of\n     * overlay content like popovers or flyouts.\n     */\n    autoFocus: PropTypes.oneOf(AUTOFOCUS),\n    size: PropTypes.oneOf(SIZES),\n    /**\n     * Each tab needs id and content properties, so we can associate it with its panel for accessibility.\n     * The name property is also required to display to the user.\n     */\n    tabs: PropTypes.arrayOf(\n      PropTypes.shape({\n        content: PropTypes.node.isRequired,\n        id: PropTypes.string.isRequired,\n        name: PropTypes.string.isRequired,\n      })\n    ).isRequired,\n  };\n\n  constructor(props) {\n    super(props);\n\n    const { initialSelectedTab, selectedTab, tabs } = props;\n\n    this.rootId = makeId();\n    this.divRef = createRef();\n\n    // Only track selection state if it's not controlled externally.\n    let selectedTabId;\n    if (!selectedTab) {\n      selectedTabId =\n        (initialSelectedTab && initialSelectedTab.id) || tabs[0].id;\n    }\n\n    this.state = {\n      selectedTabId,\n      inFocus: false,\n    };\n  }\n\n  componentDidMount() {\n    // IE11 doesn't support the `relatedTarget` event property for blur events\n    // but does add it for focusout. React doesn't support `onFocusOut` so here we are.\n    if (this.divRef.current) {\n      this.divRef.current.addEventListener('focusout', this.removeFocus);\n    }\n  }\n\n  componentWillUnmount() {\n    if (this.divRef.current) {\n      this.divRef.current.removeEventListener('focusout', this.removeFocus);\n    }\n  }\n\n  initializeFocus = () => {\n    if (!this.state.inFocus && this.props.autoFocus === 'selected') {\n      // Must wait for setState to finish before calling `.focus()`\n      // as the focus call triggers a blur on the first tab\n      this.setState({ inFocus: true }, () => {\n        const targetTab = this.divRef.current.querySelector(\n          `#${this.state.selectedTabId}`\n        );\n        targetTab.focus();\n      });\n    }\n  };\n\n  removeFocus = blurEvent => {\n    // only set inFocus to false if the wrapping div doesn't contain the now-focusing element\n    if (blurEvent.currentTarget.contains(blurEvent.relatedTarget) === false) {\n      this.setState({\n        inFocus: false,\n      });\n    }\n  };\n\n  onTabClick = selectedTab => {\n    const { onTabClick, selectedTab: externalSelectedTab } = this.props;\n\n    if (onTabClick) {\n      onTabClick(selectedTab);\n    }\n\n    // Only track selection state if it's not controlled externally.\n    if (!externalSelectedTab) {\n      this.setState({ selectedTabId: selectedTab.id });\n    }\n  };\n\n  render() {\n    const {\n      className,\n      display,\n      expand,\n      initialSelectedTab,\n      onTabClick,\n      selectedTab: externalSelectedTab,\n      size,\n      tabs,\n      autoFocus,\n      ...rest\n    } = this.props;\n\n    // Allow the consumer to control tab selection.\n    const selectedTab =\n      externalSelectedTab ||\n      tabs.find(tab => tab.id === this.state.selectedTabId);\n\n    const { content: selectedTabContent, id: selectedTabId } = selectedTab;\n\n    return (\n      <div\n        ref={this.divRef}\n        className={className}\n        {...rest}\n        onFocus={this.initializeFocus}>\n        <EuiTabs expand={expand} display={display} size={size}>\n          {tabs.map(tab => {\n            const {\n              id,\n              name,\n              content, // eslint-disable-line no-unused-vars\n              ...tabProps\n            } = tab;\n            const props = {\n              key: id,\n              id,\n              ...tabProps,\n              onClick: () => this.onTabClick(tab),\n              isSelected: tab === selectedTab,\n              'aria-controls': `${this.rootId}`,\n            };\n\n            return <EuiTab {...props}>{name}</EuiTab>;\n          })}\n        </EuiTabs>\n\n        <div\n          role=\"tabpanel\"\n          id={`${this.rootId}`}\n          aria-labelledby={selectedTabId}>\n          {selectedTabContent}\n        </div>\n      </div>\n    );\n  }\n}\n\nEuiTabbedContent.defaultProps = {\n  autoFocus: 'initial',\n};\n"]}]}