{"remainingRequest":"/Users/chanderprall/projects/eui/node_modules/babel-loader/lib/index.js!/Users/chanderprall/projects/eui/src/components/context_menu/context_menu_panel.js","dependencies":[{"path":"/Users/chanderprall/projects/eui/src/components/context_menu/context_menu_panel.js","mtime":1567534071245},{"path":"/Users/chanderprall/projects/eui/.babelrc.js","mtime":1565204168946},{"path":"/Users/chanderprall/projects/eui/node_modules/cache-loader/dist/cjs.js","mtime":1555436064329},{"path":"/Users/chanderprall/projects/eui/node_modules/babel-loader/lib/index.js","mtime":1543517280769}],"contextDependencies":[],"result":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.EuiContextMenuPanel = void 0;\n\nrequire(\"core-js/modules/es7.symbol.async-iterator\");\n\nrequire(\"core-js/modules/es6.symbol\");\n\nrequire(\"core-js/modules/es6.object.assign\");\n\nrequire(\"core-js/modules/es6.array.iterator\");\n\nrequire(\"core-js/modules/es6.object.keys\");\n\nrequire(\"core-js/modules/es6.object.set-prototype-of\");\n\nrequire(\"core-js/modules/web.dom.iterable\");\n\nvar _react = _interopRequireWildcard(require(\"react\"));\n\nvar _propTypes = _interopRequireDefault(require(\"prop-types\"));\n\nvar _classnames = _interopRequireDefault(require(\"classnames\"));\n\nvar _tabbable = _interopRequireDefault(require(\"tabbable\"));\n\nvar _icon = require(\"../icon\");\n\nvar _popover = require(\"../popover\");\n\nvar _resize_observer = require(\"../observer/resize_observer\");\n\nvar _services = require(\"../../services\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }\n\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nvar transitionDirectionAndTypeToClassNameMap = {\n  next: {\n    in: 'euiContextMenuPanel-txInLeft',\n    out: 'euiContextMenuPanel-txOutLeft'\n  },\n  previous: {\n    in: 'euiContextMenuPanel-txInRight',\n    out: 'euiContextMenuPanel-txOutRight'\n  }\n};\n\nvar EuiContextMenuPanel =\n/*#__PURE__*/\nfunction (_Component) {\n  _inherits(EuiContextMenuPanel, _Component);\n\n  function EuiContextMenuPanel(props) {\n    var _this;\n\n    _classCallCheck(this, EuiContextMenuPanel);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(EuiContextMenuPanel).call(this, props));\n\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"incrementFocusedItemIndex\", function (amount) {\n      var nextFocusedItemIndex;\n\n      if (_this.state.focusedItemIndex === undefined) {\n        // If this is the beginning of the user's keyboard navigation of the menu, then we'll focus\n        // either the first or last item.\n        nextFocusedItemIndex = amount < 0 ? _this.state.menuItems.length - 1 : 0;\n      } else {\n        nextFocusedItemIndex = _this.state.focusedItemIndex + amount;\n\n        if (nextFocusedItemIndex < 0) {\n          nextFocusedItemIndex = _this.state.menuItems.length - 1;\n        } else if (nextFocusedItemIndex === _this.state.menuItems.length) {\n          nextFocusedItemIndex = 0;\n        }\n      }\n\n      _this.setState({\n        focusedItemIndex: nextFocusedItemIndex\n      });\n    });\n\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"onKeyDown\", function (e) {\n      // If this panel contains items you can use the left arrow key to go back at any time.\n      // But if it doesn't contain items, then you have to focus on the back button specifically,\n      // since there could be content inside the panel which requires use of the left arrow key,\n      // e.g. text inputs.\n      if (_this.props.items.length || document.activeElement === _this.backButton || document.activeElement === _this.panel) {\n        if (e.keyCode === _services.cascadingMenuKeyCodes.LEFT) {\n          if (_this.props.showPreviousPanel) {\n            e.preventDefault();\n            e.stopPropagation();\n\n            _this.props.showPreviousPanel();\n\n            if (_this.props.onUseKeyboardToNavigate) {\n              _this.props.onUseKeyboardToNavigate();\n            }\n          }\n        }\n      }\n\n      if (_this.props.items.length) {\n        switch (e.keyCode) {\n          case _services.cascadingMenuKeyCodes.TAB:\n            // We need to sync up with the user if s/he is tabbing through the items.\n            var focusedItemIndex = _this.state.menuItems.indexOf(document.activeElement);\n\n            _this.setState({\n              focusedItemIndex: focusedItemIndex >= 0 && focusedItemIndex < _this.state.menuItems.length ? focusedItemIndex : undefined\n            });\n\n            break;\n\n          case _services.cascadingMenuKeyCodes.UP:\n            e.preventDefault();\n\n            _this.incrementFocusedItemIndex(-1);\n\n            if (_this.props.onUseKeyboardToNavigate) {\n              _this.props.onUseKeyboardToNavigate();\n            }\n\n            break;\n\n          case _services.cascadingMenuKeyCodes.DOWN:\n            e.preventDefault();\n\n            _this.incrementFocusedItemIndex(1);\n\n            if (_this.props.onUseKeyboardToNavigate) {\n              _this.props.onUseKeyboardToNavigate();\n            }\n\n            break;\n\n          case _services.cascadingMenuKeyCodes.RIGHT:\n            if (_this.props.showNextPanel) {\n              e.preventDefault();\n\n              _this.props.showNextPanel(_this.state.focusedItemIndex);\n\n              if (_this.props.onUseKeyboardToNavigate) {\n                _this.props.onUseKeyboardToNavigate();\n              }\n            }\n\n            break;\n\n          default:\n            break;\n        }\n      }\n    });\n\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"onTransitionComplete\", function () {\n      _this.setState({\n        isTransitioning: false\n      });\n\n      if (_this.props.onTransitionComplete) {\n        _this.props.onTransitionComplete();\n      }\n    });\n\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"menuItemRef\", function (index, node) {\n      // There's a weird bug where if you navigate to a panel without items, then this callback\n      // is still invoked, so we have to do a truthiness check.\n      if (node) {\n        // Store all menu items.\n        _this.state.menuItems[index] = node;\n      }\n    });\n\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"panelRef\", function (node) {\n      _this.panel = node;\n\n      _this.updateHeight();\n    });\n\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"contentRef\", function (node) {\n      _this.content = node;\n    });\n\n    _this.state = {\n      prevProps: {\n        items: _this.props.items\n      },\n      menuItems: [],\n      isTransitioning: Boolean(props.transitionType),\n      focusedItemIndex: props.initialFocusedItemIndex,\n      currentHeight: undefined\n    };\n    return _this;\n  }\n\n  _createClass(EuiContextMenuPanel, [{\n    key: \"updateFocus\",\n    value: function updateFocus() {\n      var _this2 = this;\n\n      // Give positioning time to render before focus is applied. Otherwise page jumps.\n      requestAnimationFrame(function () {\n        if (!_this2._isMounted) {\n          return;\n        } // If this panel has lost focus, then none of its content should be focused.\n\n\n        if (!_this2.props.hasFocus) {\n          if (_this2.panel.contains(document.activeElement)) {\n            document.activeElement.blur();\n          }\n\n          return;\n        } // Setting focus while transitioning causes the animation to glitch, so we have to wait\n        // until it's finished before we focus anything.\n\n\n        if (_this2.state.isTransitioning) {\n          return;\n        } // If there aren't any items then this is probably a form or something.\n\n\n        if (!_this2.state.menuItems.length) {\n          // If we've already focused on something inside the panel, everything's fine.\n          if (_this2.panel.contains(document.activeElement)) {\n            return;\n          } // Otherwise let's focus the first tabbable item and expedite input from the user.\n\n\n          if (_this2.content) {\n            var tabbableItems = (0, _tabbable.default)(_this2.content);\n\n            if (tabbableItems.length) {\n              tabbableItems[0].focus();\n            }\n          }\n\n          return;\n        } // If an item is focused, focus it.\n\n\n        if (_this2.state.focusedItemIndex !== undefined) {\n          _this2.state.menuItems[_this2.state.focusedItemIndex].focus();\n\n          return;\n        } // Focus on the panel as a last resort.\n\n\n        if (!_this2.panel.contains(document.activeElement)) {\n          _this2.panel.focus();\n        }\n      });\n    }\n  }, {\n    key: \"componentDidMount\",\n    value: function componentDidMount() {\n      this.updateFocus();\n      this._isMounted = true;\n    }\n  }, {\n    key: \"componentWillUnmount\",\n    value: function componentWillUnmount() {\n      this._isMounted = false;\n    }\n  }, {\n    key: \"getWatchedPropsForItems\",\n    value: function getWatchedPropsForItems(items) {\n      // This lets us compare prevProps and nextProps among items so we can re-render if our items\n      // have changed.\n      var watchedItemProps = this.props.watchedItemProps; // Create fingerprint of all item's watched properties\n\n      if (items.length && watchedItemProps && watchedItemProps.length) {\n        return JSON.stringify(items.map(function (item) {\n          // Create object of item properties and values\n          var props = {\n            key: item.key\n          };\n          watchedItemProps.forEach(function (prop) {\n            return props[prop] = item.props[prop];\n          });\n          return props;\n        }));\n      }\n\n      return null;\n    }\n  }, {\n    key: \"didItemsChange\",\n    value: function didItemsChange(prevItems, nextItems) {\n      // If the count of items has changed then update\n      if (prevItems.length !== nextItems.length) {\n        return true;\n      } // Check if any watched item properties changed by quick string comparison\n\n\n      if (this.getWatchedPropsForItems(nextItems) !== this.getWatchedPropsForItems(prevItems)) {\n        return true;\n      }\n    }\n  }, {\n    key: \"shouldComponentUpdate\",\n    value: function shouldComponentUpdate(nextProps, nextState) {\n      // Prevent calling `this.updateFocus()` below if we don't have to.\n      if (nextProps.hasFocus !== this.props.hasFocus) {\n        return true;\n      }\n\n      if (nextState.isTransitioning !== this.state.isTransitioning) {\n        return true;\n      }\n\n      if (nextState.focusedItemIndex !== this.state.focusedItemIndex) {\n        return true;\n      } // **\n      // this component should have either items or children,\n      // if there are items we can determine via `watchedItemProps` if we should update\n      // if there are children we can't know if they have changed so return true\n      // **\n\n\n      if (this.props.items.length > 0 || nextProps.items.length > 0) {\n        if (this.didItemsChange(this.props.items, nextProps.items)) {\n          return true;\n        }\n      } // it's not possible (in any good way) to know if `children` has changed, assume they might have\n\n\n      if (this.props.children != null) {\n        return true;\n      }\n\n      return false;\n    }\n  }, {\n    key: \"updateHeight\",\n    value: function updateHeight() {\n      var currentHeight = this.panel ? this.panel.clientHeight : 0;\n\n      if (this.state.height !== currentHeight) {\n        if (this.props.onHeightChange) {\n          this.props.onHeightChange(currentHeight);\n          this.setState({\n            height: currentHeight\n          });\n        }\n      }\n    }\n  }, {\n    key: \"componentDidUpdate\",\n    value: function componentDidUpdate() {\n      this.updateFocus();\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      var _this3 = this;\n\n      var _this$props = this.props,\n          children = _this$props.children,\n          className = _this$props.className,\n          onClose = _this$props.onClose,\n          title = _this$props.title,\n          onHeightChange = _this$props.onHeightChange,\n          transitionType = _this$props.transitionType,\n          transitionDirection = _this$props.transitionDirection,\n          onTransitionComplete = _this$props.onTransitionComplete,\n          onUseKeyboardToNavigate = _this$props.onUseKeyboardToNavigate,\n          hasFocus = _this$props.hasFocus,\n          items = _this$props.items,\n          watchedItemProps = _this$props.watchedItemProps,\n          initialFocusedItemIndex = _this$props.initialFocusedItemIndex,\n          showNextPanel = _this$props.showNextPanel,\n          showPreviousPanel = _this$props.showPreviousPanel,\n          rest = _objectWithoutProperties(_this$props, [\"children\", \"className\", \"onClose\", \"title\", \"onHeightChange\", \"transitionType\", \"transitionDirection\", \"onTransitionComplete\", \"onUseKeyboardToNavigate\", \"hasFocus\", \"items\", \"watchedItemProps\", \"initialFocusedItemIndex\", \"showNextPanel\", \"showPreviousPanel\"]);\n\n      var panelTitle;\n\n      if (title) {\n        if (Boolean(onClose)) {\n          panelTitle = _react.default.createElement(\"button\", {\n            className: \"euiContextMenuPanelTitle\",\n            type: \"button\",\n            onClick: onClose,\n            ref: function ref(node) {\n              _this3.backButton = node;\n            },\n            \"data-test-subj\": \"contextMenuPanelTitleButton\"\n          }, _react.default.createElement(\"span\", {\n            className: \"euiContextMenu__itemLayout\"\n          }, _react.default.createElement(_icon.EuiIcon, {\n            type: \"arrowLeft\",\n            size: \"m\",\n            className: \"euiContextMenu__icon\"\n          }), _react.default.createElement(\"span\", {\n            className: \"euiContextMenu__text\"\n          }, title)));\n        } else {\n          panelTitle = _react.default.createElement(_popover.EuiPopoverTitle, null, _react.default.createElement(\"span\", {\n            className: \"euiContextMenu__itemLayout\"\n          }, title));\n        }\n      }\n\n      var classes = (0, _classnames.default)('euiContextMenuPanel', className, this.state.isTransitioning && transitionDirectionAndTypeToClassNameMap[transitionDirection] ? transitionDirectionAndTypeToClassNameMap[transitionDirection][transitionType] : undefined);\n      var content = items.length ? items.map(function (MenuItem, index) {\n        return (0, _react.cloneElement)(MenuItem, {\n          buttonRef: _this3.menuItemRef.bind(_this3, index)\n        });\n      }) : children;\n      return _react.default.createElement(\"div\", _extends({\n        ref: this.panelRef,\n        className: classes,\n        onKeyDown: this.onKeyDown,\n        tabIndex: \"0\",\n        onAnimationEnd: this.onTransitionComplete\n      }, rest), panelTitle, _react.default.createElement(\"div\", {\n        ref: this.contentRef\n      }, _react.default.createElement(_resize_observer.EuiResizeObserver, {\n        onResize: function onResize() {\n          return _this3.updateHeight();\n        }\n      }, function (resizeRef) {\n        return _react.default.createElement(\"div\", {\n          ref: resizeRef\n        }, content);\n      })));\n    }\n  }], [{\n    key: \"getDerivedStateFromProps\",\n    value: function getDerivedStateFromProps(nextProps, prevState) {\n      var needsUpdate = false;\n      var nextState = {}; // Clear refs to menuItems if we're getting new ones.\n\n      if (nextProps.items !== prevState.prevProps.items) {\n        needsUpdate = true;\n        nextState.menuItems = [];\n        nextState.prevProps = {\n          items: nextProps.items\n        };\n      }\n\n      if (nextProps.transitionType) {\n        needsUpdate = true;\n        nextState.isTransitioning = true;\n      }\n\n      if (needsUpdate) {\n        return nextState;\n      }\n\n      return null;\n    }\n  }]);\n\n  return EuiContextMenuPanel;\n}(_react.Component);\n\nexports.EuiContextMenuPanel = EuiContextMenuPanel;\n\n_defineProperty(EuiContextMenuPanel, \"propTypes\", {\n  children: _propTypes.default.node,\n  className: _propTypes.default.string,\n  title: _propTypes.default.node,\n  onClose: _propTypes.default.func,\n  onHeightChange: _propTypes.default.func,\n  transitionType: _propTypes.default.oneOf(['in', 'out']),\n  transitionDirection: _propTypes.default.oneOf(['next', 'previous']),\n  onTransitionComplete: _propTypes.default.func,\n  onUseKeyboardToNavigate: _propTypes.default.func,\n  hasFocus: _propTypes.default.bool,\n  items: _propTypes.default.array,\n  watchedItemProps: _propTypes.default.array,\n  showNextPanel: _propTypes.default.func,\n  showPreviousPanel: _propTypes.default.func,\n  initialFocusedItemIndex: _propTypes.default.number\n});\n\n_defineProperty(EuiContextMenuPanel, \"defaultProps\", {\n  hasFocus: true,\n  items: []\n});\n\nEuiContextMenuPanel.__docgenInfo = {\n  \"description\": \"\",\n  \"methods\": [{\n    \"name\": \"incrementFocusedItemIndex\",\n    \"docblock\": null,\n    \"modifiers\": [],\n    \"params\": [{\n      \"name\": \"amount\",\n      \"type\": null\n    }],\n    \"returns\": null\n  }, {\n    \"name\": \"onKeyDown\",\n    \"docblock\": null,\n    \"modifiers\": [],\n    \"params\": [{\n      \"name\": \"e\",\n      \"type\": null\n    }],\n    \"returns\": null\n  }, {\n    \"name\": \"updateFocus\",\n    \"docblock\": null,\n    \"modifiers\": [],\n    \"params\": [],\n    \"returns\": null\n  }, {\n    \"name\": \"onTransitionComplete\",\n    \"docblock\": null,\n    \"modifiers\": [],\n    \"params\": [],\n    \"returns\": null\n  }, {\n    \"name\": \"getDerivedStateFromProps\",\n    \"docblock\": null,\n    \"modifiers\": [\"static\"],\n    \"params\": [{\n      \"name\": \"nextProps\",\n      \"type\": null\n    }, {\n      \"name\": \"prevState\",\n      \"type\": null\n    }],\n    \"returns\": null\n  }, {\n    \"name\": \"getWatchedPropsForItems\",\n    \"docblock\": null,\n    \"modifiers\": [],\n    \"params\": [{\n      \"name\": \"items\",\n      \"type\": null\n    }],\n    \"returns\": null\n  }, {\n    \"name\": \"didItemsChange\",\n    \"docblock\": null,\n    \"modifiers\": [],\n    \"params\": [{\n      \"name\": \"prevItems\",\n      \"type\": null\n    }, {\n      \"name\": \"nextItems\",\n      \"type\": null\n    }],\n    \"returns\": null\n  }, {\n    \"name\": \"updateHeight\",\n    \"docblock\": null,\n    \"modifiers\": [],\n    \"params\": [],\n    \"returns\": null\n  }, {\n    \"name\": \"menuItemRef\",\n    \"docblock\": null,\n    \"modifiers\": [],\n    \"params\": [{\n      \"name\": \"index\",\n      \"type\": null\n    }, {\n      \"name\": \"node\",\n      \"type\": null\n    }],\n    \"returns\": null\n  }, {\n    \"name\": \"panelRef\",\n    \"docblock\": null,\n    \"modifiers\": [],\n    \"params\": [{\n      \"name\": \"node\",\n      \"type\": null\n    }],\n    \"returns\": null\n  }, {\n    \"name\": \"contentRef\",\n    \"docblock\": null,\n    \"modifiers\": [],\n    \"params\": [{\n      \"name\": \"node\",\n      \"type\": null\n    }],\n    \"returns\": null\n  }],\n  \"displayName\": \"EuiContextMenuPanel\",\n  \"props\": {\n    \"hasFocus\": {\n      \"defaultValue\": {\n        \"value\": \"true\",\n        \"computed\": false\n      },\n      \"type\": {\n        \"name\": \"bool\"\n      },\n      \"required\": false,\n      \"description\": \"\"\n    },\n    \"items\": {\n      \"defaultValue\": {\n        \"value\": \"[]\",\n        \"computed\": false\n      },\n      \"type\": {\n        \"name\": \"array\"\n      },\n      \"required\": false,\n      \"description\": \"\"\n    },\n    \"children\": {\n      \"type\": {\n        \"name\": \"node\"\n      },\n      \"required\": false,\n      \"description\": \"\"\n    },\n    \"className\": {\n      \"type\": {\n        \"name\": \"string\"\n      },\n      \"required\": false,\n      \"description\": \"\"\n    },\n    \"title\": {\n      \"type\": {\n        \"name\": \"node\"\n      },\n      \"required\": false,\n      \"description\": \"\"\n    },\n    \"onClose\": {\n      \"type\": {\n        \"name\": \"func\"\n      },\n      \"required\": false,\n      \"description\": \"\"\n    },\n    \"onHeightChange\": {\n      \"type\": {\n        \"name\": \"func\"\n      },\n      \"required\": false,\n      \"description\": \"\"\n    },\n    \"transitionType\": {\n      \"type\": {\n        \"name\": \"enum\",\n        \"value\": [{\n          \"value\": \"'in'\",\n          \"computed\": false\n        }, {\n          \"value\": \"'out'\",\n          \"computed\": false\n        }]\n      },\n      \"required\": false,\n      \"description\": \"\"\n    },\n    \"transitionDirection\": {\n      \"type\": {\n        \"name\": \"enum\",\n        \"value\": [{\n          \"value\": \"'next'\",\n          \"computed\": false\n        }, {\n          \"value\": \"'previous'\",\n          \"computed\": false\n        }]\n      },\n      \"required\": false,\n      \"description\": \"\"\n    },\n    \"onTransitionComplete\": {\n      \"type\": {\n        \"name\": \"func\"\n      },\n      \"required\": false,\n      \"description\": \"\"\n    },\n    \"onUseKeyboardToNavigate\": {\n      \"type\": {\n        \"name\": \"func\"\n      },\n      \"required\": false,\n      \"description\": \"\"\n    },\n    \"watchedItemProps\": {\n      \"type\": {\n        \"name\": \"array\"\n      },\n      \"required\": false,\n      \"description\": \"\"\n    },\n    \"showNextPanel\": {\n      \"type\": {\n        \"name\": \"func\"\n      },\n      \"required\": false,\n      \"description\": \"\"\n    },\n    \"showPreviousPanel\": {\n      \"type\": {\n        \"name\": \"func\"\n      },\n      \"required\": false,\n      \"description\": \"\"\n    },\n    \"initialFocusedItemIndex\": {\n      \"type\": {\n        \"name\": \"number\"\n      },\n      \"required\": false,\n      \"description\": \"\"\n    }\n  }\n};",{"version":3,"sources":["/Users/chanderprall/projects/eui/src/components/context_menu/context_menu_panel.js"],"names":["transitionDirectionAndTypeToClassNameMap","next","in","out","previous","EuiContextMenuPanel","props","amount","nextFocusedItemIndex","state","focusedItemIndex","undefined","menuItems","length","setState","e","items","document","activeElement","backButton","panel","keyCode","cascadingMenuKeyCodes","LEFT","showPreviousPanel","preventDefault","stopPropagation","onUseKeyboardToNavigate","TAB","indexOf","UP","incrementFocusedItemIndex","DOWN","RIGHT","showNextPanel","isTransitioning","onTransitionComplete","index","node","updateHeight","content","prevProps","Boolean","transitionType","initialFocusedItemIndex","currentHeight","requestAnimationFrame","_isMounted","hasFocus","contains","blur","tabbableItems","focus","updateFocus","watchedItemProps","JSON","stringify","map","item","key","forEach","prop","prevItems","nextItems","getWatchedPropsForItems","nextProps","nextState","didItemsChange","children","clientHeight","height","onHeightChange","className","onClose","title","transitionDirection","rest","panelTitle","classes","MenuItem","buttonRef","menuItemRef","bind","panelRef","onKeyDown","contentRef","resizeRef","prevState","needsUpdate","Component","PropTypes","string","func","oneOf","bool","array","number"],"mappings":"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","sourcesContent":["import React, { cloneElement, Component } from 'react';\nimport PropTypes from 'prop-types';\nimport classNames from 'classnames';\nimport tabbable from 'tabbable';\n\nimport { EuiIcon } from '../icon';\nimport { EuiPopoverTitle } from '../popover';\nimport { EuiResizeObserver } from '../observer/resize_observer';\nimport { cascadingMenuKeyCodes } from '../../services';\n\nconst transitionDirectionAndTypeToClassNameMap = {\n  next: {\n    in: 'euiContextMenuPanel-txInLeft',\n    out: 'euiContextMenuPanel-txOutLeft',\n  },\n  previous: {\n    in: 'euiContextMenuPanel-txInRight',\n    out: 'euiContextMenuPanel-txOutRight',\n  },\n};\n\nexport class EuiContextMenuPanel extends Component {\n  static propTypes = {\n    children: PropTypes.node,\n    className: PropTypes.string,\n    title: PropTypes.node,\n    onClose: PropTypes.func,\n    onHeightChange: PropTypes.func,\n    transitionType: PropTypes.oneOf(['in', 'out']),\n    transitionDirection: PropTypes.oneOf(['next', 'previous']),\n    onTransitionComplete: PropTypes.func,\n    onUseKeyboardToNavigate: PropTypes.func,\n    hasFocus: PropTypes.bool,\n    items: PropTypes.array,\n    watchedItemProps: PropTypes.array,\n    showNextPanel: PropTypes.func,\n    showPreviousPanel: PropTypes.func,\n    initialFocusedItemIndex: PropTypes.number,\n  };\n\n  static defaultProps = {\n    hasFocus: true,\n    items: [],\n  };\n\n  constructor(props) {\n    super(props);\n\n    this.state = {\n      prevProps: {\n        items: this.props.items,\n      },\n      menuItems: [],\n      isTransitioning: Boolean(props.transitionType),\n      focusedItemIndex: props.initialFocusedItemIndex,\n      currentHeight: undefined,\n    };\n  }\n\n  incrementFocusedItemIndex = amount => {\n    let nextFocusedItemIndex;\n\n    if (this.state.focusedItemIndex === undefined) {\n      // If this is the beginning of the user's keyboard navigation of the menu, then we'll focus\n      // either the first or last item.\n      nextFocusedItemIndex = amount < 0 ? this.state.menuItems.length - 1 : 0;\n    } else {\n      nextFocusedItemIndex = this.state.focusedItemIndex + amount;\n\n      if (nextFocusedItemIndex < 0) {\n        nextFocusedItemIndex = this.state.menuItems.length - 1;\n      } else if (nextFocusedItemIndex === this.state.menuItems.length) {\n        nextFocusedItemIndex = 0;\n      }\n    }\n\n    this.setState({\n      focusedItemIndex: nextFocusedItemIndex,\n    });\n  };\n\n  onKeyDown = e => {\n    // If this panel contains items you can use the left arrow key to go back at any time.\n    // But if it doesn't contain items, then you have to focus on the back button specifically,\n    // since there could be content inside the panel which requires use of the left arrow key,\n    // e.g. text inputs.\n    if (\n      this.props.items.length ||\n      document.activeElement === this.backButton ||\n      document.activeElement === this.panel\n    ) {\n      if (e.keyCode === cascadingMenuKeyCodes.LEFT) {\n        if (this.props.showPreviousPanel) {\n          e.preventDefault();\n          e.stopPropagation();\n          this.props.showPreviousPanel();\n\n          if (this.props.onUseKeyboardToNavigate) {\n            this.props.onUseKeyboardToNavigate();\n          }\n        }\n      }\n    }\n\n    if (this.props.items.length) {\n      switch (e.keyCode) {\n        case cascadingMenuKeyCodes.TAB:\n          // We need to sync up with the user if s/he is tabbing through the items.\n          const focusedItemIndex = this.state.menuItems.indexOf(\n            document.activeElement\n          );\n\n          this.setState({\n            focusedItemIndex:\n              focusedItemIndex >= 0 &&\n              focusedItemIndex < this.state.menuItems.length\n                ? focusedItemIndex\n                : undefined,\n          });\n          break;\n\n        case cascadingMenuKeyCodes.UP:\n          e.preventDefault();\n          this.incrementFocusedItemIndex(-1);\n\n          if (this.props.onUseKeyboardToNavigate) {\n            this.props.onUseKeyboardToNavigate();\n          }\n          break;\n\n        case cascadingMenuKeyCodes.DOWN:\n          e.preventDefault();\n          this.incrementFocusedItemIndex(1);\n\n          if (this.props.onUseKeyboardToNavigate) {\n            this.props.onUseKeyboardToNavigate();\n          }\n          break;\n\n        case cascadingMenuKeyCodes.RIGHT:\n          if (this.props.showNextPanel) {\n            e.preventDefault();\n            this.props.showNextPanel(this.state.focusedItemIndex);\n\n            if (this.props.onUseKeyboardToNavigate) {\n              this.props.onUseKeyboardToNavigate();\n            }\n          }\n          break;\n\n        default:\n          break;\n      }\n    }\n  };\n\n  updateFocus() {\n    // Give positioning time to render before focus is applied. Otherwise page jumps.\n    requestAnimationFrame(() => {\n      if (!this._isMounted) {\n        return;\n      }\n\n      // If this panel has lost focus, then none of its content should be focused.\n      if (!this.props.hasFocus) {\n        if (this.panel.contains(document.activeElement)) {\n          document.activeElement.blur();\n        }\n        return;\n      }\n\n      // Setting focus while transitioning causes the animation to glitch, so we have to wait\n      // until it's finished before we focus anything.\n      if (this.state.isTransitioning) {\n        return;\n      }\n\n      // If there aren't any items then this is probably a form or something.\n      if (!this.state.menuItems.length) {\n        // If we've already focused on something inside the panel, everything's fine.\n        if (this.panel.contains(document.activeElement)) {\n          return;\n        }\n\n        // Otherwise let's focus the first tabbable item and expedite input from the user.\n        if (this.content) {\n          const tabbableItems = tabbable(this.content);\n          if (tabbableItems.length) {\n            tabbableItems[0].focus();\n          }\n        }\n        return;\n      }\n\n      // If an item is focused, focus it.\n      if (this.state.focusedItemIndex !== undefined) {\n        this.state.menuItems[this.state.focusedItemIndex].focus();\n        return;\n      }\n\n      // Focus on the panel as a last resort.\n      if (!this.panel.contains(document.activeElement)) {\n        this.panel.focus();\n      }\n    });\n  }\n\n  onTransitionComplete = () => {\n    this.setState({\n      isTransitioning: false,\n    });\n\n    if (this.props.onTransitionComplete) {\n      this.props.onTransitionComplete();\n    }\n  };\n\n  componentDidMount() {\n    this.updateFocus();\n    this._isMounted = true;\n  }\n\n  componentWillUnmount() {\n    this._isMounted = false;\n  }\n\n  static getDerivedStateFromProps(nextProps, prevState) {\n    let needsUpdate = false;\n    const nextState = {};\n\n    // Clear refs to menuItems if we're getting new ones.\n    if (nextProps.items !== prevState.prevProps.items) {\n      needsUpdate = true;\n      nextState.menuItems = [];\n      nextState.prevProps = { items: nextProps.items };\n    }\n\n    if (nextProps.transitionType) {\n      needsUpdate = true;\n      nextState.isTransitioning = true;\n    }\n\n    if (needsUpdate) {\n      return nextState;\n    }\n    return null;\n  }\n\n  getWatchedPropsForItems(items) {\n    // This lets us compare prevProps and nextProps among items so we can re-render if our items\n    // have changed.\n    const { watchedItemProps } = this.props;\n\n    // Create fingerprint of all item's watched properties\n    if (items.length && watchedItemProps && watchedItemProps.length) {\n      return JSON.stringify(\n        items.map(item => {\n          // Create object of item properties and values\n          const props = {\n            key: item.key,\n          };\n          watchedItemProps.forEach(prop => (props[prop] = item.props[prop]));\n          return props;\n        })\n      );\n    }\n\n    return null;\n  }\n\n  didItemsChange(prevItems, nextItems) {\n    // If the count of items has changed then update\n    if (prevItems.length !== nextItems.length) {\n      return true;\n    }\n\n    // Check if any watched item properties changed by quick string comparison\n    if (\n      this.getWatchedPropsForItems(nextItems) !==\n      this.getWatchedPropsForItems(prevItems)\n    ) {\n      return true;\n    }\n  }\n\n  shouldComponentUpdate(nextProps, nextState) {\n    // Prevent calling `this.updateFocus()` below if we don't have to.\n    if (nextProps.hasFocus !== this.props.hasFocus) {\n      return true;\n    }\n\n    if (nextState.isTransitioning !== this.state.isTransitioning) {\n      return true;\n    }\n\n    if (nextState.focusedItemIndex !== this.state.focusedItemIndex) {\n      return true;\n    }\n\n    // **\n    // this component should have either items or children,\n    // if there are items we can determine via `watchedItemProps` if we should update\n    // if there are children we can't know if they have changed so return true\n    // **\n\n    if (this.props.items.length > 0 || nextProps.items.length > 0) {\n      if (this.didItemsChange(this.props.items, nextProps.items)) {\n        return true;\n      }\n    }\n\n    // it's not possible (in any good way) to know if `children` has changed, assume they might have\n    if (this.props.children != null) {\n      return true;\n    }\n\n    return false;\n  }\n\n  updateHeight() {\n    const currentHeight = this.panel ? this.panel.clientHeight : 0;\n\n    if (this.state.height !== currentHeight) {\n      if (this.props.onHeightChange) {\n        this.props.onHeightChange(currentHeight);\n\n        this.setState({ height: currentHeight });\n      }\n    }\n  }\n\n  componentDidUpdate() {\n    this.updateFocus();\n  }\n\n  menuItemRef = (index, node) => {\n    // There's a weird bug where if you navigate to a panel without items, then this callback\n    // is still invoked, so we have to do a truthiness check.\n    if (node) {\n      // Store all menu items.\n      this.state.menuItems[index] = node;\n    }\n  };\n\n  panelRef = node => {\n    this.panel = node;\n\n    this.updateHeight();\n  };\n\n  contentRef = node => {\n    this.content = node;\n  };\n\n  render() {\n    const {\n      children,\n      className,\n      onClose,\n      title,\n      onHeightChange,\n      transitionType,\n      transitionDirection,\n      onTransitionComplete,\n      onUseKeyboardToNavigate,\n      hasFocus,\n      items,\n      watchedItemProps,\n      initialFocusedItemIndex,\n      showNextPanel,\n      showPreviousPanel,\n      ...rest\n    } = this.props;\n    let panelTitle;\n\n    if (title) {\n      if (Boolean(onClose)) {\n        panelTitle = (\n          <button\n            className=\"euiContextMenuPanelTitle\"\n            type=\"button\"\n            onClick={onClose}\n            ref={node => {\n              this.backButton = node;\n            }}\n            data-test-subj=\"contextMenuPanelTitleButton\">\n            <span className=\"euiContextMenu__itemLayout\">\n              <EuiIcon\n                type=\"arrowLeft\"\n                size=\"m\"\n                className=\"euiContextMenu__icon\"\n              />\n\n              <span className=\"euiContextMenu__text\">{title}</span>\n            </span>\n          </button>\n        );\n      } else {\n        panelTitle = (\n          <EuiPopoverTitle>\n            <span className=\"euiContextMenu__itemLayout\">{title}</span>\n          </EuiPopoverTitle>\n        );\n      }\n    }\n\n    const classes = classNames(\n      'euiContextMenuPanel',\n      className,\n      this.state.isTransitioning &&\n        transitionDirectionAndTypeToClassNameMap[transitionDirection]\n        ? transitionDirectionAndTypeToClassNameMap[transitionDirection][\n            transitionType\n          ]\n        : undefined\n    );\n\n    const content = items.length\n      ? items.map((MenuItem, index) =>\n          cloneElement(MenuItem, {\n            buttonRef: this.menuItemRef.bind(this, index),\n          })\n        )\n      : children;\n\n    return (\n      <div\n        ref={this.panelRef}\n        className={classes}\n        onKeyDown={this.onKeyDown}\n        tabIndex=\"0\"\n        onAnimationEnd={this.onTransitionComplete}\n        {...rest}>\n        {panelTitle}\n\n        <div ref={this.contentRef}>\n          <EuiResizeObserver onResize={() => this.updateHeight()}>\n            {resizeRef => <div ref={resizeRef}>{content}</div>}\n          </EuiResizeObserver>\n        </div>\n      </div>\n    );\n  }\n}\n"]}]}