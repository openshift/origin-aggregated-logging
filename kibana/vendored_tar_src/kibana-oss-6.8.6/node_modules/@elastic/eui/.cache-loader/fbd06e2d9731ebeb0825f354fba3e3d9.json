{"remainingRequest":"/Users/chanderprall/projects/eui/node_modules/babel-loader/lib/index.js!/Users/chanderprall/projects/eui/src/components/search_bar/query/ast_to_es_query_dsl.js","dependencies":[{"path":"/Users/chanderprall/projects/eui/src/components/search_bar/query/ast_to_es_query_dsl.js","mtime":1565204169983},{"path":"/Users/chanderprall/projects/eui/.babelrc.js","mtime":1565204168946},{"path":"/Users/chanderprall/projects/eui/node_modules/cache-loader/dist/cjs.js","mtime":1555436064329},{"path":"/Users/chanderprall/projects/eui/node_modules/babel-loader/lib/index.js","mtime":1543517280769}],"contextDependencies":[],"result":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.astToEsQueryDsl = exports._isFlagToQuery = exports._fieldValuesToQuery = exports._termValuesToQuery = void 0;\n\nrequire(\"core-js/modules/es6.string.iterator\");\n\nrequire(\"core-js/modules/es6.array.from\");\n\nrequire(\"core-js/modules/es6.regexp.to-string\");\n\nrequire(\"core-js/modules/es7.symbol.async-iterator\");\n\nrequire(\"core-js/modules/es6.symbol\");\n\nrequire(\"core-js/modules/es6.regexp.match\");\n\nrequire(\"core-js/modules/es6.array.iterator\");\n\nrequire(\"core-js/modules/es6.object.keys\");\n\nrequire(\"core-js/modules/web.dom.iterable\");\n\nvar _date_format = require(\"./date_format\");\n\nvar _date_value = require(\"./date_value\");\n\nvar _ast = require(\"./ast\");\n\nvar _predicate = require(\"../../../services/predicate\");\n\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }\n\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance\"); }\n\nfunction _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === \"[object Arguments]\") return Array.from(iter); }\n\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nvar processDateOperation = function processDateOperation(value, operator) {\n  var granularity = value.granularity,\n      resolve = value.resolve;\n  var expression = (0, _date_format.printIso8601)(resolve());\n\n  if (!granularity) {\n    return {\n      operator: operator,\n      expression: expression\n    };\n  }\n\n  switch (operator) {\n    case _ast.AST.Operator.GT:\n      expression = \"\".concat(expression, \"||+1\").concat(granularity.es, \"/\").concat(granularity.es);\n      return {\n        operator: _ast.AST.Operator.GTE,\n        expression: expression\n      };\n\n    case _ast.AST.Operator.GTE:\n      expression = \"\".concat(expression, \"||/\").concat(granularity.es);\n      return {\n        operator: operator,\n        expression: expression\n      };\n\n    case _ast.AST.Operator.LT:\n      expression = \"\".concat(expression, \"||/\").concat(granularity.es);\n      return {\n        operator: operator,\n        expression: expression\n      };\n\n    case _ast.AST.Operator.LTE:\n      expression = \"\".concat(expression, \"||+1\").concat(granularity.es, \"/\").concat(granularity.es);\n      return {\n        operator: _ast.AST.Operator.LT,\n        expression: expression\n      };\n\n    default:\n      expression = \"\".concat(expression, \"||/\").concat(granularity.es);\n      return {\n        expression: expression\n      };\n  }\n};\n\nvar _termValuesToQuery = function _termValuesToQuery(values, options) {\n  var body = {\n    query: values.join(' ')\n  };\n\n  if (body.query === '') {\n    return;\n  }\n\n  if (options.defaultFields) {\n    body.fields = options.defaultFields;\n  }\n\n  return {\n    simple_query_string: body\n  };\n};\n\nexports._termValuesToQuery = _termValuesToQuery;\n\nvar _fieldValuesToQuery = function _fieldValuesToQuery(field, operations, andOr) {\n  var queries = [];\n  Object.keys(operations).forEach(function (operator) {\n    var values = operations[operator];\n\n    switch (operator) {\n      case _ast.AST.Operator.EQ:\n        var _values$reduce = values.reduce(function (tokenTypes, value) {\n          if ((0, _date_value.isDateValue)(value)) {\n            tokenTypes.dates.push(value);\n          } else if ((0, _predicate.isDateLike)(value)) {\n            tokenTypes.dates.push((0, _date_value.dateValue)(value));\n          } else if ((0, _predicate.isString)(value) && value.match(/\\s/)) {\n            tokenTypes.phrases.push(value);\n          } else {\n            tokenTypes.terms.push(value);\n          }\n\n          return tokenTypes;\n        }, {\n          terms: [],\n          phrases: [],\n          dates: []\n        }),\n            terms = _values$reduce.terms,\n            phrases = _values$reduce.phrases,\n            dates = _values$reduce.dates;\n\n        if (terms.length > 0) {\n          queries.push({\n            match: _defineProperty({}, field, {\n              query: terms.join(' '),\n              operator: andOr\n            })\n          });\n        }\n\n        if (phrases.length > 0) {\n          queries.push.apply(queries, _toConsumableArray(phrases.map(function (phrase) {\n            return {\n              match_phrase: _defineProperty({}, field, phrase)\n            };\n          })));\n        }\n\n        if (dates.length > 0) {\n          queries.push.apply(queries, _toConsumableArray(dates.map(function (value) {\n            return {\n              match: _defineProperty({}, field, processDateOperation(value).expression)\n            };\n          })));\n        }\n\n        break;\n\n      default:\n        values.forEach(function (value) {\n          if ((0, _date_value.isDateValue)(value)) {\n            var operation = processDateOperation(value, operator);\n            queries.push({\n              range: _defineProperty({}, field, _defineProperty({}, operation.operator, operation.expression))\n            });\n          } else {\n            queries.push({\n              range: _defineProperty({}, field, _defineProperty({}, operator, value))\n            });\n          }\n        });\n    }\n  });\n\n  if (queries.length === 1) {\n    return queries[0];\n  }\n\n  var key = andOr === 'and' ? 'must' : 'should';\n  return {\n    bool: _defineProperty({}, key, queries.concat())\n  };\n};\n\nexports._fieldValuesToQuery = _fieldValuesToQuery;\n\nvar _isFlagToQuery = function _isFlagToQuery(flag, on) {\n  return {\n    term: _defineProperty({}, flag, on)\n  };\n};\n\nexports._isFlagToQuery = _isFlagToQuery;\n\nvar collectTerms = function collectTerms(clauses) {\n  return clauses.reduce(function (values, clause) {\n    if (_ast.AST.Match.isMustClause(clause)) {\n      values.must.push(clause.value);\n    } else {\n      values.mustNot.push(clause.value);\n    }\n\n    return values;\n  }, {\n    must: [],\n    mustNot: []\n  });\n};\n\nvar collectFields = function collectFields(clauses) {\n  var fieldArray = function fieldArray(obj, field, operator) {\n    if (!obj[field]) {\n      obj[field] = {};\n    }\n\n    if (!obj[field][operator]) {\n      obj[field][operator] = [];\n    }\n\n    return obj[field][operator];\n  };\n\n  return clauses.reduce(function (fields, clause) {\n    if (_ast.AST.Match.isMustClause(clause)) {\n      if ((0, _predicate.isArray)(clause.value)) {\n        var _fieldArray;\n\n        (_fieldArray = fieldArray(fields.must.or, clause.field, clause.operator)).push.apply(_fieldArray, _toConsumableArray(clause.value));\n      } else {\n        fieldArray(fields.must.and, clause.field, clause.operator).push(clause.value);\n      }\n    } else {\n      if ((0, _predicate.isArray)(clause.value)) {\n        var _fieldArray2;\n\n        (_fieldArray2 = fieldArray(fields.mustNot.or, clause.field, clause.operator)).push.apply(_fieldArray2, _toConsumableArray(clause.value));\n      } else {\n        fieldArray(fields.mustNot.and, clause.field, clause.operator).push(clause.value);\n      }\n    }\n\n    return fields;\n  }, {\n    must: {\n      and: {},\n      or: {}\n    },\n    mustNot: {\n      and: {},\n      or: {}\n    }\n  });\n};\n\nvar clausesToEsQueryDsl = function clausesToEsQueryDsl(_ref) {\n  var fields = _ref.fields,\n      terms = _ref.terms,\n      is = _ref.is;\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var extraMustQueries = options.extraMustQueries || [];\n  var extraMustNotQueries = options.extraMustNotQueries || [];\n  var termValuesToQuery = options.termValuesToQuery || _termValuesToQuery;\n  var fieldValuesToQuery = options.fieldValuesToQuery || _fieldValuesToQuery;\n  var isFlagToQuery = options.isFlagToQuery || _isFlagToQuery;\n  var must = [];\n  must.push.apply(must, _toConsumableArray(extraMustQueries));\n  var termMustQuery = termValuesToQuery(terms.must, options);\n\n  if (termMustQuery) {\n    must.push(termMustQuery);\n  }\n\n  Object.keys(fields.must.and).forEach(function (field) {\n    must.push(fieldValuesToQuery(field, fields.must.and[field], 'and'));\n  });\n  Object.keys(fields.must.or).forEach(function (field) {\n    must.push(fieldValuesToQuery(field, fields.must.or[field], 'or'));\n  });\n  is.forEach(function (clause) {\n    must.push(isFlagToQuery(clause.flag, _ast.AST.Match.isMustClause(clause)));\n  });\n  var mustNot = [];\n  mustNot.push.apply(mustNot, _toConsumableArray(extraMustNotQueries));\n  var termMustNotQuery = termValuesToQuery(terms.mustNot, options);\n\n  if (termMustNotQuery) {\n    mustNot.push(termMustNotQuery);\n  }\n\n  Object.keys(fields.mustNot.and).forEach(function (field) {\n    mustNot.push(fieldValuesToQuery(field, fields.mustNot.and[field], 'and'));\n  });\n  Object.keys(fields.mustNot.or).forEach(function (field) {\n    mustNot.push(fieldValuesToQuery(field, fields.mustNot.or[field], 'or'));\n  });\n  var bool = {};\n\n  if (must.length !== 0) {\n    bool.must = must;\n  }\n\n  if (mustNot.length !== 0) {\n    bool.must_not = mustNot;\n  }\n\n  return bool;\n};\n\nvar EMPTY_TERMS = {\n  must: [],\n  mustNot: []\n};\nvar EMPTY_FIELDS = {\n  must: {\n    and: {},\n    or: {}\n  },\n  mustNot: {\n    and: {},\n    or: {}\n  }\n};\n\nvar astToEsQueryDsl = function astToEsQueryDsl(ast, options) {\n  if (ast.clauses.length === 0) {\n    return {\n      match_all: {}\n    };\n  }\n\n  var terms = collectTerms(ast.getTermClauses());\n  var fields = collectFields(ast.getFieldClauses());\n  var is = ast.getIsClauses();\n  var matchesBool = clausesToEsQueryDsl({\n    terms: terms,\n    fields: fields,\n    is: is\n  }, options);\n  var hasTopMatches = Object.keys(matchesBool).length > 0;\n  var groupClauses = ast.getGroupClauses();\n\n  if (groupClauses.length === 0) {\n    // there are no GroupClauses, everything at top level is combined as a must\n    return {\n      bool: matchesBool\n    };\n  } else {\n    // there is at least one GroupClause, wrap the above clauses in another layer and append the ORs\n    var must = groupClauses.reduce(function (must, groupClause) {\n      var clauses = groupClause.value.reduce(function (clauses, clause) {\n        if (_ast.AST.Term.isInstance(clause)) {\n          clauses.push(clausesToEsQueryDsl({\n            terms: collectTerms([clause]),\n            fields: EMPTY_FIELDS,\n            is: []\n          }));\n        } else if (_ast.AST.Field.isInstance(clause)) {\n          clauses.push(clausesToEsQueryDsl({\n            terms: EMPTY_TERMS,\n            fields: collectFields([clause]),\n            is: []\n          }));\n        } else if (_ast.AST.Is.isInstance(clause)) {\n          clauses.push(clausesToEsQueryDsl({\n            terms: EMPTY_TERMS,\n            fields: EMPTY_FIELDS,\n            is: [clause]\n          }));\n        }\n\n        return clauses;\n      }, []);\n      must.push({\n        bool: {\n          should: clauses.map(function (clause) {\n            return {\n              bool: clause\n            };\n          })\n        }\n      });\n      return must;\n    }, hasTopMatches // only include the first match group if there are any conditions\n    ? [{\n      bool: matchesBool\n    }] : []);\n    return {\n      bool: {\n        must: must\n      }\n    };\n  }\n};\n\nexports.astToEsQueryDsl = astToEsQueryDsl;",{"version":3,"sources":["/Users/chanderprall/projects/eui/src/components/search_bar/query/ast_to_es_query_dsl.js"],"names":["processDateOperation","value","operator","granularity","resolve","expression","AST","Operator","GT","es","GTE","LT","LTE","_termValuesToQuery","values","options","body","query","join","defaultFields","fields","simple_query_string","_fieldValuesToQuery","field","operations","andOr","queries","Object","keys","forEach","EQ","reduce","tokenTypes","dates","push","match","phrases","terms","length","map","phrase","match_phrase","operation","range","key","bool","_isFlagToQuery","flag","on","term","collectTerms","clauses","clause","Match","isMustClause","must","mustNot","collectFields","fieldArray","obj","or","and","clausesToEsQueryDsl","is","extraMustQueries","extraMustNotQueries","termValuesToQuery","fieldValuesToQuery","isFlagToQuery","termMustQuery","termMustNotQuery","must_not","EMPTY_TERMS","EMPTY_FIELDS","astToEsQueryDsl","ast","match_all","getTermClauses","getFieldClauses","getIsClauses","matchesBool","hasTopMatches","groupClauses","getGroupClauses","groupClause","Term","isInstance","Field","Is","should"],"mappings":"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","sourcesContent":["import { printIso8601 } from './date_format';\nimport { isDateValue, dateValue } from './date_value';\nimport { AST } from './ast';\nimport { isArray, isDateLike, isString } from '../../../services/predicate';\n\nconst processDateOperation = (value, operator) => {\n  const { granularity, resolve } = value;\n  let expression = printIso8601(resolve());\n  if (!granularity) {\n    return { operator, expression };\n  }\n  switch (operator) {\n    case AST.Operator.GT:\n      expression = `${expression}||+1${granularity.es}/${granularity.es}`;\n      return { operator: AST.Operator.GTE, expression };\n    case AST.Operator.GTE:\n      expression = `${expression}||/${granularity.es}`;\n      return { operator, expression };\n    case AST.Operator.LT:\n      expression = `${expression}||/${granularity.es}`;\n      return { operator, expression };\n    case AST.Operator.LTE:\n      expression = `${expression}||+1${granularity.es}/${granularity.es}`;\n      return { operator: AST.Operator.LT, expression };\n    default:\n      expression = `${expression}||/${granularity.es}`;\n      return { expression };\n  }\n};\n\nexport const _termValuesToQuery = (values, options) => {\n  const body = {\n    query: values.join(' '),\n  };\n  if (body.query === '') {\n    return;\n  }\n  if (options.defaultFields) {\n    body.fields = options.defaultFields;\n  }\n  return {\n    simple_query_string: body,\n  };\n};\n\nexport const _fieldValuesToQuery = (field, operations, andOr) => {\n  const queries = [];\n\n  Object.keys(operations).forEach(operator => {\n    const values = operations[operator];\n    switch (operator) {\n      case AST.Operator.EQ:\n        const { terms, phrases, dates } = values.reduce(\n          (tokenTypes, value) => {\n            if (isDateValue(value)) {\n              tokenTypes.dates.push(value);\n            } else if (isDateLike(value)) {\n              tokenTypes.dates.push(dateValue(value));\n            } else if (isString(value) && value.match(/\\s/)) {\n              tokenTypes.phrases.push(value);\n            } else {\n              tokenTypes.terms.push(value);\n            }\n            return tokenTypes;\n          },\n          { terms: [], phrases: [], dates: [] }\n        );\n\n        if (terms.length > 0) {\n          queries.push({\n            match: {\n              [field]: {\n                query: terms.join(' '),\n                operator: andOr,\n              },\n            },\n          });\n        }\n\n        if (phrases.length > 0) {\n          queries.push(\n            ...phrases.map(phrase => ({\n              match_phrase: {\n                [field]: phrase,\n              },\n            }))\n          );\n        }\n\n        if (dates.length > 0) {\n          queries.push(\n            ...dates.map(value => ({\n              match: {\n                [field]: processDateOperation(value).expression,\n              },\n            }))\n          );\n        }\n\n        break;\n\n      default:\n        values.forEach(value => {\n          if (isDateValue(value)) {\n            const operation = processDateOperation(value, operator);\n            queries.push({\n              range: {\n                [field]: {\n                  [operation.operator]: operation.expression,\n                },\n              },\n            });\n          } else {\n            queries.push({\n              range: {\n                [field]: {\n                  [operator]: value,\n                },\n              },\n            });\n          }\n        });\n    }\n  });\n\n  if (queries.length === 1) {\n    return queries[0];\n  }\n\n  const key = andOr === 'and' ? 'must' : 'should';\n  return {\n    bool: {\n      [key]: [...queries],\n    },\n  };\n};\n\nexport const _isFlagToQuery = (flag, on) => {\n  return {\n    term: { [flag]: on },\n  };\n};\n\nconst collectTerms = clauses => {\n  return clauses.reduce(\n    (values, clause) => {\n      if (AST.Match.isMustClause(clause)) {\n        values.must.push(clause.value);\n      } else {\n        values.mustNot.push(clause.value);\n      }\n      return values;\n    },\n    { must: [], mustNot: [] }\n  );\n};\n\nconst collectFields = clauses => {\n  const fieldArray = (obj, field, operator) => {\n    if (!obj[field]) {\n      obj[field] = {};\n    }\n    if (!obj[field][operator]) {\n      obj[field][operator] = [];\n    }\n    return obj[field][operator];\n  };\n\n  return clauses.reduce(\n    (fields, clause) => {\n      if (AST.Match.isMustClause(clause)) {\n        if (isArray(clause.value)) {\n          fieldArray(fields.must.or, clause.field, clause.operator).push(\n            ...clause.value\n          );\n        } else {\n          fieldArray(fields.must.and, clause.field, clause.operator).push(\n            clause.value\n          );\n        }\n      } else {\n        if (isArray(clause.value)) {\n          fieldArray(fields.mustNot.or, clause.field, clause.operator).push(\n            ...clause.value\n          );\n        } else {\n          fieldArray(fields.mustNot.and, clause.field, clause.operator).push(\n            clause.value\n          );\n        }\n      }\n      return fields;\n    },\n    {\n      must: { and: {}, or: {} },\n      mustNot: { and: {}, or: {} },\n    }\n  );\n};\n\nconst clausesToEsQueryDsl = ({ fields, terms, is }, options = {}) => {\n  const extraMustQueries = options.extraMustQueries || [];\n  const extraMustNotQueries = options.extraMustNotQueries || [];\n  const termValuesToQuery = options.termValuesToQuery || _termValuesToQuery;\n  const fieldValuesToQuery = options.fieldValuesToQuery || _fieldValuesToQuery;\n  const isFlagToQuery = options.isFlagToQuery || _isFlagToQuery;\n\n  const must = [];\n  must.push(...extraMustQueries);\n  const termMustQuery = termValuesToQuery(terms.must, options);\n  if (termMustQuery) {\n    must.push(termMustQuery);\n  }\n  Object.keys(fields.must.and).forEach(field => {\n    must.push(fieldValuesToQuery(field, fields.must.and[field], 'and'));\n  });\n  Object.keys(fields.must.or).forEach(field => {\n    must.push(fieldValuesToQuery(field, fields.must.or[field], 'or'));\n  });\n  is.forEach(clause => {\n    must.push(isFlagToQuery(clause.flag, AST.Match.isMustClause(clause)));\n  });\n\n  const mustNot = [];\n  mustNot.push(...extraMustNotQueries);\n  const termMustNotQuery = termValuesToQuery(terms.mustNot, options);\n  if (termMustNotQuery) {\n    mustNot.push(termMustNotQuery);\n  }\n  Object.keys(fields.mustNot.and).forEach(field => {\n    mustNot.push(fieldValuesToQuery(field, fields.mustNot.and[field], 'and'));\n  });\n  Object.keys(fields.mustNot.or).forEach(field => {\n    mustNot.push(fieldValuesToQuery(field, fields.mustNot.or[field], 'or'));\n  });\n\n  const bool = {};\n  if (must.length !== 0) {\n    bool.must = must;\n  }\n  if (mustNot.length !== 0) {\n    bool.must_not = mustNot;\n  }\n\n  return bool;\n};\n\nconst EMPTY_TERMS = { must: [], mustNot: [] };\nconst EMPTY_FIELDS = {\n  must: { and: {}, or: {} },\n  mustNot: { and: {}, or: {} },\n};\n\nexport const astToEsQueryDsl = (ast, options) => {\n  if (ast.clauses.length === 0) {\n    return { match_all: {} };\n  }\n\n  const terms = collectTerms(ast.getTermClauses());\n  const fields = collectFields(ast.getFieldClauses());\n  const is = ast.getIsClauses();\n\n  const matchesBool = clausesToEsQueryDsl({ terms, fields, is }, options);\n  const hasTopMatches = Object.keys(matchesBool).length > 0;\n\n  const groupClauses = ast.getGroupClauses();\n  if (groupClauses.length === 0) {\n    // there are no GroupClauses, everything at top level is combined as a must\n    return { bool: matchesBool };\n  } else {\n    // there is at least one GroupClause, wrap the above clauses in another layer and append the ORs\n    const must = groupClauses.reduce(\n      (must, groupClause) => {\n        const clauses = groupClause.value.reduce((clauses, clause) => {\n          if (AST.Term.isInstance(clause)) {\n            clauses.push(\n              clausesToEsQueryDsl({\n                terms: collectTerms([clause]),\n                fields: EMPTY_FIELDS,\n                is: [],\n              })\n            );\n          } else if (AST.Field.isInstance(clause)) {\n            clauses.push(\n              clausesToEsQueryDsl({\n                terms: EMPTY_TERMS,\n                fields: collectFields([clause]),\n                is: [],\n              })\n            );\n          } else if (AST.Is.isInstance(clause)) {\n            clauses.push(\n              clausesToEsQueryDsl({\n                terms: EMPTY_TERMS,\n                fields: EMPTY_FIELDS,\n                is: [clause],\n              })\n            );\n          }\n          return clauses;\n        }, []);\n\n        must.push({\n          bool: {\n            should: clauses.map(clause => ({ bool: clause })),\n          },\n        });\n        return must;\n      },\n      hasTopMatches // only include the first match group if there are any conditions\n        ? [{ bool: matchesBool }]\n        : []\n    );\n\n    return {\n      bool: { must },\n    };\n  }\n};\n"]}]}