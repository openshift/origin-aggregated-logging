{"remainingRequest":"/Users/chanderprall/projects/eui/node_modules/babel-loader/lib/index.js!/Users/chanderprall/projects/eui/src/components/form/range/range_track.tsx","dependencies":[{"path":"/Users/chanderprall/projects/eui/src/components/form/range/range_track.tsx","mtime":1565364126025},{"path":"/Users/chanderprall/projects/eui/.babelrc.js","mtime":1565204168946},{"path":"/Users/chanderprall/projects/eui/node_modules/cache-loader/dist/cjs.js","mtime":1555436064329},{"path":"/Users/chanderprall/projects/eui/node_modules/babel-loader/lib/index.js","mtime":1543517280769}],"contextDependencies":[],"result":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nObject.defineProperty(exports, \"LEVEL_COLORS\", {\n  enumerable: true,\n  get: function get() {\n    return _range_levels.LEVEL_COLORS;\n  }\n});\nexports.EuiRangeTrack = void 0;\n\nrequire(\"core-js/modules/es7.symbol.async-iterator\");\n\nrequire(\"core-js/modules/es6.symbol\");\n\nrequire(\"core-js/modules/es6.object.set-prototype-of\");\n\nvar _react = _interopRequireWildcard(require(\"react\"));\n\nvar _propTypes = _interopRequireDefault(require(\"prop-types\"));\n\nvar _classnames = _interopRequireDefault(require(\"classnames\"));\n\nvar _range = _interopRequireDefault(require(\"lodash/range\"));\n\nvar _services = require(\"../../../services\");\n\nvar _range_levels = require(\"./range_levels\");\n\nvar _range_ticks = require(\"./range_ticks\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }\n\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nvar EuiRangeTrack =\n/*#__PURE__*/\nfunction (_Component) {\n  _inherits(EuiRangeTrack, _Component);\n\n  function EuiRangeTrack() {\n    var _getPrototypeOf2;\n\n    var _this;\n\n    _classCallCheck(this, EuiRangeTrack);\n\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    _this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(EuiRangeTrack)).call.apply(_getPrototypeOf2, [this].concat(args)));\n\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"validateValueIsInStep\", function (value) {\n      if (value < _this.props.min) {\n        throw new Error(\"The value of \".concat(value, \" is lower than the min value of \").concat(_this.props.min, \".\"));\n      }\n\n      if (value > _this.props.max) {\n        throw new Error(\"The value of \".concat(value, \" is higher than the max value of \").concat(_this.props.max, \".\"));\n      } // Error out if the value doesn't line up with the sequence of steps\n\n\n      if (!(0, _services.isEvenlyDivisibleBy)(value - _this.props.min, _this.props.step !== undefined ? _this.props.step : 1)) {\n        throw new Error(\"The value of \".concat(value, \" is not included in the possible sequence provided by the step of \").concat(_this.props.step, \".\"));\n      } // Return the value if nothing fails\n\n\n      return value;\n    });\n\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"calculateSequence\", function (min, max, interval) {\n      // Loop from min to max, creating adding values at each interval\n      // (adds a very small number to the max since `range` is not inclusive of the max value)\n      var toBeInclusive = 0.000000001;\n      return (0, _range.default)(min, max + toBeInclusive, interval);\n    });\n\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"calculateTicks\", function (min, max, step, tickInterval, customTicks) {\n      var ticks;\n\n      if (customTicks) {\n        // If custom values were passed, use those for the sequence\n        // But make sure they align with the possible sequence\n        ticks = customTicks.map(function (tick) {\n          return _this.validateValueIsInStep(tick.value);\n        });\n      } else {\n        // If a custom interval was passed, use those for the sequence\n        // But make sure they align with the possible sequence\n        var interval = tickInterval || step;\n\n        var tickSequence = _this.calculateSequence(min, max, interval);\n\n        ticks = tickSequence.map(function (tick) {\n          return _this.validateValueIsInStep(tick);\n        });\n      } // Error out if there are too many ticks to render\n\n\n      if (ticks.length > 20) {\n        throw new Error(\"The number of ticks to render is too high (\".concat(ticks.length, \"), reduce the interval.\"));\n      }\n\n      return ticks;\n    });\n\n    return _this;\n  }\n\n  _createClass(EuiRangeTrack, [{\n    key: \"render\",\n    value: function render() {\n      var _this$props = this.props,\n          children = _this$props.children,\n          disabled = _this$props.disabled,\n          max = _this$props.max,\n          min = _this$props.min,\n          step = _this$props.step,\n          showTicks = _this$props.showTicks,\n          tickInterval = _this$props.tickInterval,\n          ticks = _this$props.ticks,\n          levels = _this$props.levels,\n          onChange = _this$props.onChange,\n          value = _this$props.value; // TODO: Move these to only re-calculate if no-value props have changed\n\n      this.validateValueIsInStep(max);\n      var tickSequence;\n      var inputWrapperStyle = {};\n\n      if (showTicks) {\n        tickSequence = this.calculateTicks(min, max, step, tickInterval, ticks); // Calculate if any extra margin should be added to the inputWrapper\n        // because of longer tick labels on the ends\n\n        var lengthOfMinLabel = String(tickSequence[0]).length;\n        var lenghtOfMaxLabel = String(tickSequence[tickSequence.length - 1]).length;\n        var isLastTickTheMax = tickSequence[tickSequence.length - 1] === max;\n\n        if (lengthOfMinLabel > 2) {\n          inputWrapperStyle.marginLeft = \"\".concat(lengthOfMinLabel / 5, \"em\");\n        }\n\n        if (isLastTickTheMax && lenghtOfMaxLabel > 2) {\n          inputWrapperStyle.marginRight = \"\".concat(lenghtOfMaxLabel / 5, \"em\");\n        }\n      }\n\n      var trackClasses = (0, _classnames.default)('euiRangeTrack', {\n        'euiRangeTrack--disabled': disabled\n      });\n      return _react.default.createElement(\"div\", {\n        className: trackClasses,\n        style: inputWrapperStyle\n      }, children, levels && !!levels.length && _react.default.createElement(_range_levels.EuiRangeLevels, {\n        levels: levels,\n        max: max,\n        min: min,\n        showTicks: showTicks\n      }), tickSequence && _react.default.createElement(_range_ticks.EuiRangeTicks, {\n        disabled: disabled,\n        onChange: onChange,\n        ticks: ticks,\n        tickSequence: tickSequence,\n        value: value,\n        min: min,\n        max: max,\n        interval: tickInterval || step\n      }));\n    }\n  }]);\n\n  return EuiRangeTrack;\n}(_react.Component);\n\nexports.EuiRangeTrack = EuiRangeTrack;\nEuiRangeTrack.propTypes = {\n  min: _propTypes.default.number.isRequired,\n  max: _propTypes.default.number.isRequired,\n  step: _propTypes.default.number,\n  value: _propTypes.default.oneOfType([_propTypes.default.number.isRequired, _propTypes.default.string.isRequired, _propTypes.default.arrayOf(_propTypes.default.oneOfType([_propTypes.default.string.isRequired, _propTypes.default.number.isRequired]).isRequired).isRequired]),\n  disabled: _propTypes.default.bool,\n  showTicks: _propTypes.default.bool,\n  tickInterval: _propTypes.default.number,\n  ticks: _propTypes.default.arrayOf(_propTypes.default.shape({\n    value: _propTypes.default.number.isRequired,\n    label: _propTypes.default.node.isRequired\n  }).isRequired),\n  onChange: _propTypes.default.func,\n  levels: _propTypes.default.arrayOf(_propTypes.default.shape({\n    min: _propTypes.default.number.isRequired,\n    max: _propTypes.default.number.isRequired,\n    color: _propTypes.default.oneOf([\"primary\", \"success\", \"warning\", \"danger\"]).isRequired\n  }).isRequired)\n};\nEuiRangeTrack.__docgenInfo = {\n  \"description\": \"\",\n  \"methods\": [{\n    \"name\": \"validateValueIsInStep\",\n    \"docblock\": null,\n    \"modifiers\": [],\n    \"params\": [{\n      \"name\": \"value\",\n      \"type\": null\n    }],\n    \"returns\": null\n  }, {\n    \"name\": \"calculateSequence\",\n    \"docblock\": null,\n    \"modifiers\": [],\n    \"params\": [{\n      \"name\": \"min\",\n      \"type\": null\n    }, {\n      \"name\": \"max\",\n      \"type\": null\n    }, {\n      \"name\": \"interval\",\n      \"type\": null\n    }],\n    \"returns\": null\n  }, {\n    \"name\": \"calculateTicks\",\n    \"docblock\": null,\n    \"modifiers\": [],\n    \"params\": [{\n      \"name\": \"min\",\n      \"type\": null\n    }, {\n      \"name\": \"max\",\n      \"type\": null\n    }, {\n      \"name\": \"step\",\n      \"type\": null\n    }, {\n      \"name\": \"tickInterval\",\n      \"type\": null\n    }, {\n      \"name\": \"customTicks\",\n      \"type\": null\n    }],\n    \"returns\": null\n  }],\n  \"displayName\": \"EuiRangeTrack\",\n  \"props\": {\n    \"min\": {\n      \"type\": {\n        \"name\": \"number\"\n      },\n      \"required\": true,\n      \"description\": \"\"\n    },\n    \"max\": {\n      \"type\": {\n        \"name\": \"number\"\n      },\n      \"required\": true,\n      \"description\": \"\"\n    },\n    \"step\": {\n      \"type\": {\n        \"name\": \"number\"\n      },\n      \"required\": false,\n      \"description\": \"\"\n    },\n    \"value\": {\n      \"type\": {\n        \"name\": \"union\",\n        \"value\": [{\n          \"name\": \"number\"\n        }, {\n          \"name\": \"string\"\n        }, {\n          \"name\": \"arrayOf\",\n          \"value\": {\n            \"name\": \"union\",\n            \"value\": [{\n              \"name\": \"string\"\n            }, {\n              \"name\": \"number\"\n            }]\n          }\n        }]\n      },\n      \"required\": false,\n      \"description\": \"\"\n    },\n    \"disabled\": {\n      \"type\": {\n        \"name\": \"bool\"\n      },\n      \"required\": false,\n      \"description\": \"\"\n    },\n    \"showTicks\": {\n      \"type\": {\n        \"name\": \"bool\"\n      },\n      \"required\": false,\n      \"description\": \"\"\n    },\n    \"tickInterval\": {\n      \"type\": {\n        \"name\": \"number\"\n      },\n      \"required\": false,\n      \"description\": \"\"\n    },\n    \"ticks\": {\n      \"type\": {\n        \"name\": \"arrayOf\",\n        \"value\": {\n          \"name\": \"shape\",\n          \"value\": {\n            \"value\": {\n              \"name\": \"number\",\n              \"required\": true\n            },\n            \"label\": {\n              \"name\": \"node\",\n              \"required\": true\n            }\n          }\n        }\n      },\n      \"required\": false,\n      \"description\": \"\"\n    },\n    \"onChange\": {\n      \"type\": {\n        \"name\": \"func\"\n      },\n      \"required\": false,\n      \"description\": \"\"\n    },\n    \"levels\": {\n      \"type\": {\n        \"name\": \"arrayOf\",\n        \"value\": {\n          \"name\": \"shape\",\n          \"value\": {\n            \"min\": {\n              \"name\": \"number\",\n              \"required\": true\n            },\n            \"max\": {\n              \"name\": \"number\",\n              \"required\": true\n            },\n            \"color\": {\n              \"name\": \"enum\",\n              \"value\": [{\n                \"value\": \"\\\"primary\\\"\",\n                \"computed\": false\n              }, {\n                \"value\": \"\\\"success\\\"\",\n                \"computed\": false\n              }, {\n                \"value\": \"\\\"warning\\\"\",\n                \"computed\": false\n              }, {\n                \"value\": \"\\\"danger\\\"\",\n                \"computed\": false\n              }],\n              \"required\": true\n            }\n          }\n        }\n      },\n      \"required\": false,\n      \"description\": \"\"\n    }\n  }\n};",{"version":3,"sources":["/Users/chanderprall/projects/eui/src/components/form/range/range_track.tsx"],"names":["EuiRangeTrack","value","props","min","Error","max","step","undefined","interval","toBeInclusive","tickInterval","customTicks","ticks","map","tick","validateValueIsInStep","tickSequence","calculateSequence","length","children","disabled","showTicks","levels","onChange","inputWrapperStyle","calculateTicks","lengthOfMinLabel","String","lenghtOfMaxLabel","isLastTickTheMax","marginLeft","marginRight","trackClasses","Component"],"mappings":";;;;;;;;;;;;;;;;;;;AAAA;;;;AACA;;AAEA;;AAEA;;AACA;;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;IAiBaA,a;;;;;;;;;;;;;;;;;;oGACa,UAACC,KAAD,EAAmB;AACzC,UAAIA,KAAK,GAAG,MAAKC,KAAL,CAAWC,GAAvB,EAA4B;AAC1B,cAAM,IAAIC,KAAJ,wBACYH,KADZ,6CAEF,MAAKC,KAAL,CAAWC,GAFT,OAAN;AAKD;;AACD,UAAIF,KAAK,GAAG,MAAKC,KAAL,CAAWG,GAAvB,EAA4B;AAC1B,cAAM,IAAID,KAAJ,wBACYH,KADZ,8CAEF,MAAKC,KAAL,CAAWG,GAFT,OAAN;AAKD,OAdwC,CAezC;;;AACA,UACE,CAAC,mCACCJ,KAAK,GAAG,MAAKC,KAAL,CAAWC,GADpB,EAEC,MAAKD,KAAL,CAAWI,IAAX,KAAoBC,SAApB,GAAgC,MAAKL,KAAL,CAAWI,IAA3C,GAAkD,CAFnD,CADH,EAKE;AACA,cAAM,IAAIF,KAAJ,wBACYH,KADZ,+EAEF,MAAKC,KAAL,CAAWI,IAFT,OAAN;AAKD,OA3BwC,CA4BzC;;;AACA,aAAOL,KAAP;AACD,K;;gGAEmB,UAClBE,GADkB,EAElBE,GAFkB,EAGlBG,QAHkB,EAIf;AACH;AACA;AACA,UAAMC,aAAa,GAAG,WAAtB;AACA,aAAO,oBAAMN,GAAN,EAAWE,GAAG,GAAGI,aAAjB,EAAgCD,QAAhC,CAAP;AACD,K;;6FAEgB,UACfL,GADe,EAEfE,GAFe,EAGfC,IAHe,EAIfI,YAJe,EAKfC,WALe,EAMZ;AACH,UAAIC,KAAJ;;AAEA,UAAID,WAAJ,EAAiB;AACf;AACA;AACAC,QAAAA,KAAK,GAAGD,WAAW,CAACE,GAAZ,CAAgB,UAAAC,IAAI,EAAI;AAC9B,iBAAO,MAAKC,qBAAL,CAA2BD,IAAI,CAACb,KAAhC,CAAP;AACD,SAFO,CAAR;AAGD,OAND,MAMO;AACL;AACA;AACA,YAAMO,QAAQ,GAAGE,YAAY,IAAIJ,IAAjC;;AACA,YAAMU,YAAY,GAAG,MAAKC,iBAAL,CAAuBd,GAAvB,EAA4BE,GAA5B,EAAiCG,QAAjC,CAArB;;AAEAI,QAAAA,KAAK,GAAGI,YAAY,CAACH,GAAb,CAAiB,UAAAC,IAAI,EAAI;AAC/B,iBAAO,MAAKC,qBAAL,CAA2BD,IAA3B,CAAP;AACD,SAFO,CAAR;AAGD,OAlBE,CAoBH;;;AACA,UAAIF,KAAK,CAACM,MAAN,GAAe,EAAnB,EAAuB;AACrB,cAAM,IAAId,KAAJ,sDAEFQ,KAAK,CAACM,MAFJ,6BAAN;AAKD;;AAED,aAAON,KAAP;AACD,K;;;;;;;6BAEQ;AAAA,wBAaH,KAAKV,KAbF;AAAA,UAELiB,QAFK,eAELA,QAFK;AAAA,UAGLC,QAHK,eAGLA,QAHK;AAAA,UAILf,GAJK,eAILA,GAJK;AAAA,UAKLF,GALK,eAKLA,GALK;AAAA,UAMLG,IANK,eAMLA,IANK;AAAA,UAOLe,SAPK,eAOLA,SAPK;AAAA,UAQLX,YARK,eAQLA,YARK;AAAA,UASLE,KATK,eASLA,KATK;AAAA,UAULU,MAVK,eAULA,MAVK;AAAA,UAWLC,QAXK,eAWLA,QAXK;AAAA,UAYLtB,KAZK,eAYLA,KAZK,EAeP;;AACA,WAAKc,qBAAL,CAA2BV,GAA3B;AAEA,UAAIW,YAAJ;AACA,UAAMQ,iBAAgE,GAAG,EAAzE;;AACA,UAAIH,SAAJ,EAAe;AACbL,QAAAA,YAAY,GAAG,KAAKS,cAAL,CAAoBtB,GAApB,EAAyBE,GAAzB,EAA8BC,IAA9B,EAAoCI,YAApC,EAAkDE,KAAlD,CAAf,CADa,CAGb;AACA;;AACA,YAAMc,gBAAgB,GAAGC,MAAM,CAACX,YAAY,CAAC,CAAD,CAAb,CAAN,CAAwBE,MAAjD;AACA,YAAMU,gBAAgB,GAAGD,MAAM,CAACX,YAAY,CAACA,YAAY,CAACE,MAAb,GAAsB,CAAvB,CAAb,CAAN,CACtBA,MADH;AAEA,YAAMW,gBAAgB,GAAGb,YAAY,CAACA,YAAY,CAACE,MAAb,GAAsB,CAAvB,CAAZ,KAA0Cb,GAAnE;;AACA,YAAIqB,gBAAgB,GAAG,CAAvB,EAA0B;AACxBF,UAAAA,iBAAiB,CAACM,UAAlB,aAAkCJ,gBAAgB,GAAG,CAArD;AACD;;AACD,YAAIG,gBAAgB,IAAID,gBAAgB,GAAG,CAA3C,EAA8C;AAC5CJ,UAAAA,iBAAiB,CAACO,WAAlB,aAAmCH,gBAAgB,GAAG,CAAtD;AACD;AACF;;AAED,UAAMI,YAAY,GAAG,yBAAW,eAAX,EAA4B;AAC/C,mCAA2BZ;AADoB,OAA5B,CAArB;AAIA,aACE;AAAK,QAAA,SAAS,EAAEY,YAAhB;AAA8B,QAAA,KAAK,EAAER;AAArC,SACGL,QADH,EAEGG,MAAM,IAAI,CAAC,CAACA,MAAM,CAACJ,MAAnB,IACC,6BAAC,4BAAD;AACE,QAAA,MAAM,EAAEI,MADV;AAEE,QAAA,GAAG,EAAEjB,GAFP;AAGE,QAAA,GAAG,EAAEF,GAHP;AAIE,QAAA,SAAS,EAAEkB;AAJb,QAHJ,EAUGL,YAAY,IACX,6BAAC,0BAAD;AACE,QAAA,QAAQ,EAAEI,QADZ;AAEE,QAAA,QAAQ,EAAEG,QAFZ;AAGE,QAAA,KAAK,EAAEX,KAHT;AAIE,QAAA,YAAY,EAAEI,YAJhB;AAKE,QAAA,KAAK,EAAEf,KALT;AAME,QAAA,GAAG,EAAEE,GANP;AAOE,QAAA,GAAG,EAAEE,GAPP;AAQE,QAAA,QAAQ,EAAEK,YAAY,IAAIJ;AAR5B,QAXJ,CADF;AAyBD;;;;EApJgC2B,gB","sourcesContent":["import React, { Component } from 'react';\nimport PropTypes from \"prop-types\";\nimport classNames from 'classnames';\nimport range from 'lodash/range';\nimport { isEvenlyDivisibleBy } from '../../../services';\nimport { EuiRangeLevels, LEVEL_COLORS } from './range_levels';\nimport { EuiRangeTicks } from './range_ticks';\nexport { LEVEL_COLORS };\nexport class EuiRangeTrack extends Component {\n  validateValueIsInStep = value => {\n    if (value < this.props.min) {\n      throw new Error(`The value of ${value} is lower than the min value of ${this.props.min}.`);\n    }\n\n    if (value > this.props.max) {\n      throw new Error(`The value of ${value} is higher than the max value of ${this.props.max}.`);\n    } // Error out if the value doesn't line up with the sequence of steps\n\n\n    if (!isEvenlyDivisibleBy(value - this.props.min, this.props.step !== undefined ? this.props.step : 1)) {\n      throw new Error(`The value of ${value} is not included in the possible sequence provided by the step of ${this.props.step}.`);\n    } // Return the value if nothing fails\n\n\n    return value;\n  };\n  calculateSequence = (min, max, interval) => {\n    // Loop from min to max, creating adding values at each interval\n    // (adds a very small number to the max since `range` is not inclusive of the max value)\n    const toBeInclusive = 0.000000001;\n    return range(min, max + toBeInclusive, interval);\n  };\n  calculateTicks = (min, max, step, tickInterval, customTicks) => {\n    let ticks;\n\n    if (customTicks) {\n      // If custom values were passed, use those for the sequence\n      // But make sure they align with the possible sequence\n      ticks = customTicks.map(tick => {\n        return this.validateValueIsInStep(tick.value);\n      });\n    } else {\n      // If a custom interval was passed, use those for the sequence\n      // But make sure they align with the possible sequence\n      const interval = tickInterval || step;\n      const tickSequence = this.calculateSequence(min, max, interval);\n      ticks = tickSequence.map(tick => {\n        return this.validateValueIsInStep(tick);\n      });\n    } // Error out if there are too many ticks to render\n\n\n    if (ticks.length > 20) {\n      throw new Error(`The number of ticks to render is too high (${ticks.length}), reduce the interval.`);\n    }\n\n    return ticks;\n  };\n\n  render() {\n    const {\n      children,\n      disabled,\n      max,\n      min,\n      step,\n      showTicks,\n      tickInterval,\n      ticks,\n      levels,\n      onChange,\n      value\n    } = this.props; // TODO: Move these to only re-calculate if no-value props have changed\n\n    this.validateValueIsInStep(max);\n    let tickSequence;\n    const inputWrapperStyle = {};\n\n    if (showTicks) {\n      tickSequence = this.calculateTicks(min, max, step, tickInterval, ticks); // Calculate if any extra margin should be added to the inputWrapper\n      // because of longer tick labels on the ends\n\n      const lengthOfMinLabel = String(tickSequence[0]).length;\n      const lenghtOfMaxLabel = String(tickSequence[tickSequence.length - 1]).length;\n      const isLastTickTheMax = tickSequence[tickSequence.length - 1] === max;\n\n      if (lengthOfMinLabel > 2) {\n        inputWrapperStyle.marginLeft = `${lengthOfMinLabel / 5}em`;\n      }\n\n      if (isLastTickTheMax && lenghtOfMaxLabel > 2) {\n        inputWrapperStyle.marginRight = `${lenghtOfMaxLabel / 5}em`;\n      }\n    }\n\n    const trackClasses = classNames('euiRangeTrack', {\n      'euiRangeTrack--disabled': disabled\n    });\n    return <div className={trackClasses} style={inputWrapperStyle}>\n        {children}\n        {levels && !!levels.length && <EuiRangeLevels levels={levels} max={max} min={min} showTicks={showTicks} />}\n        {tickSequence && <EuiRangeTicks disabled={disabled} onChange={onChange} ticks={ticks} tickSequence={tickSequence} value={value} min={min} max={max} interval={tickInterval || step} />}\n      </div>;\n  }\n\n}\nEuiRangeTrack.propTypes = {\n  min: PropTypes.number.isRequired,\n  max: PropTypes.number.isRequired,\n  step: PropTypes.number,\n  value: PropTypes.oneOfType([PropTypes.number.isRequired, PropTypes.string.isRequired, PropTypes.arrayOf(PropTypes.oneOfType([PropTypes.string.isRequired, PropTypes.number.isRequired]).isRequired).isRequired]),\n  disabled: PropTypes.bool,\n  showTicks: PropTypes.bool,\n  tickInterval: PropTypes.number,\n  ticks: PropTypes.arrayOf(PropTypes.shape({\n    value: PropTypes.number.isRequired,\n    label: PropTypes.node.isRequired\n  }).isRequired),\n  onChange: PropTypes.func,\n  levels: PropTypes.arrayOf(PropTypes.shape({\n    min: PropTypes.number.isRequired,\n    max: PropTypes.number.isRequired,\n    color: PropTypes.oneOf([\"primary\", \"success\", \"warning\", \"danger\"]).isRequired\n  }).isRequired)\n};"]}]}