{"remainingRequest":"/Users/chanderprall/projects/eui/node_modules/babel-loader/lib/index.js!/Users/chanderprall/projects/eui/src/services/transition/transition.ts","dependencies":[{"path":"/Users/chanderprall/projects/eui/src/services/transition/transition.ts","mtime":1565204170079},{"path":"/Users/chanderprall/projects/eui/.babelrc.js","mtime":1565204168946},{"path":"/Users/chanderprall/projects/eui/node_modules/cache-loader/dist/cjs.js","mtime":1555436064329},{"path":"/Users/chanderprall/projects/eui/node_modules/babel-loader/lib/index.js","mtime":1543517280769}],"contextDependencies":[],"result":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getDurationAndPerformOnFrame = exports.performOnFrame = exports.getWaitDuration = exports.getTransitionTimings = void 0;\n\nrequire(\"core-js/modules/es6.regexp.match\");\n\nvar GROUP_NUMERIC = /^([\\d.]+)(s|ms)/;\n\nfunction getMilliseconds(value, unit) {\n  // Given the regex match and capture groups, we can assume `unit` to be either 's' or 'ms'\n  var multiplier = unit === 's' ? 1000 : 1;\n  return parseFloat(value) * multiplier;\n} // Find CSS `transition-duration` and `transition-delay` intervals\n// and return the value of each computed property in 'ms'\n\n\nvar getTransitionTimings = function getTransitionTimings(element) {\n  var computedStyle = window.getComputedStyle(element);\n  var computedDuration = computedStyle.getPropertyValue('transition-duration');\n  var durationMatchArray = computedDuration.match(GROUP_NUMERIC);\n  var durationMatch = durationMatchArray ? getMilliseconds(durationMatchArray[1], durationMatchArray[2]) : 0;\n  var computedDelay = computedStyle.getPropertyValue('transition-delay');\n  var delayMatchArray = computedDelay.match(GROUP_NUMERIC);\n  var delayMatch = delayMatchArray ? getMilliseconds(delayMatchArray[1], delayMatchArray[2]) : 0;\n  return {\n    durationMatch: durationMatch,\n    delayMatch: delayMatch\n  };\n};\n\nexports.getTransitionTimings = getTransitionTimings;\n\nfunction isElementNode(element) {\n  return element.nodeType === document.ELEMENT_NODE;\n} // Uses `getTransitionTimings` to find the total transition time for\n// all elements targeted by a MutationObserver callback\n\n\nvar getWaitDuration = function getWaitDuration(records) {\n  return records.reduce(function (waitDuration, record) {\n    // only check for CSS transition values for ELEMENT nodes\n    if (isElementNode(record.target)) {\n      var _getTransitionTimings = getTransitionTimings(record.target),\n          durationMatch = _getTransitionTimings.durationMatch,\n          delayMatch = _getTransitionTimings.delayMatch;\n\n      waitDuration = Math.max(waitDuration, durationMatch + delayMatch);\n    }\n\n    return waitDuration;\n  }, 0);\n}; // Uses `requestAnimationFrame` to perform a given callback after a specified waiting period\n\n\nexports.getWaitDuration = getWaitDuration;\n\nvar performOnFrame = function performOnFrame(waitDuration, toPerform) {\n  if (waitDuration > 0) {\n    var startTime = Date.now();\n    var endTime = startTime + waitDuration;\n\n    var onFrame = function onFrame() {\n      toPerform();\n\n      if (endTime > Date.now()) {\n        requestAnimationFrame(onFrame);\n      }\n    };\n\n    requestAnimationFrame(onFrame);\n  }\n}; // Convenience method for combining the result of 'getWaitDuration' directly with 'performOnFrame'\n\n\nexports.performOnFrame = performOnFrame;\n\nvar getDurationAndPerformOnFrame = function getDurationAndPerformOnFrame(records, toPerform) {\n  performOnFrame(getWaitDuration(records), toPerform);\n};\n\nexports.getDurationAndPerformOnFrame = getDurationAndPerformOnFrame;",{"version":3,"sources":["/Users/chanderprall/projects/eui/src/services/transition/transition.ts"],"names":["GROUP_NUMERIC","getMilliseconds","value","unit","multiplier","parseFloat","getTransitionTimings","element","computedStyle","window","getComputedStyle","computedDuration","getPropertyValue","durationMatchArray","match","durationMatch","computedDelay","delayMatchArray","delayMatch","isElementNode","nodeType","document","ELEMENT_NODE","getWaitDuration","records","reduce","waitDuration","record","target","Math","max","performOnFrame","toPerform","startTime","Date","now","endTime","onFrame","requestAnimationFrame","getDurationAndPerformOnFrame"],"mappings":";;;;;;;;;AAAA,IAAMA,aAAa,GAAG,iBAAtB;;AAEA,SAASC,eAAT,CAAyBC,KAAzB,EAAwCC,IAAxC,EAAsD;AACpD;AACA,MAAMC,UAAU,GAAGD,IAAI,KAAK,GAAT,GAAe,IAAf,GAAsB,CAAzC;AACA,SAAOE,UAAU,CAACH,KAAD,CAAV,GAAoBE,UAA3B;AACD,C,CACD;AACA;;;AACO,IAAME,oBAAoB,GAAG,SAAvBA,oBAAuB,CAACC,OAAD,EAAsB;AACxD,MAAMC,aAAa,GAAGC,MAAM,CAACC,gBAAP,CAAwBH,OAAxB,CAAtB;AAEA,MAAMI,gBAAgB,GAAGH,aAAa,CAACI,gBAAd,CACvB,qBADuB,CAAzB;AAGA,MAAMC,kBAAkB,GAAGF,gBAAgB,CAACG,KAAjB,CAAuBd,aAAvB,CAA3B;AACA,MAAMe,aAAa,GAAGF,kBAAkB,GACpCZ,eAAe,CAACY,kBAAkB,CAAC,CAAD,CAAnB,EAAwBA,kBAAkB,CAAC,CAAD,CAA1C,CADqB,GAEpC,CAFJ;AAIA,MAAMG,aAAa,GAAGR,aAAa,CAACI,gBAAd,CAA+B,kBAA/B,CAAtB;AACA,MAAMK,eAAe,GAAGD,aAAa,CAACF,KAAd,CAAoBd,aAApB,CAAxB;AACA,MAAMkB,UAAU,GAAGD,eAAe,GAC9BhB,eAAe,CAACgB,eAAe,CAAC,CAAD,CAAhB,EAAqBA,eAAe,CAAC,CAAD,CAApC,CADe,GAE9B,CAFJ;AAIA,SAAO;AAAEF,IAAAA,aAAa,EAAbA,aAAF;AAAiBG,IAAAA,UAAU,EAAVA;AAAjB,GAAP;AACD,CAlBM;;;;AAoBP,SAASC,aAAT,CAAuBZ,OAAvB,EAA0D;AACxD,SAAOA,OAAO,CAACa,QAAR,KAAqBC,QAAQ,CAACC,YAArC;AACD,C,CACD;AACA;;;AACO,IAAMC,eAAe,GAAG,SAAlBA,eAAkB,CAACC,OAAD,EAA+B;AAC5D,SAAOA,OAAO,CAACC,MAAR,CAAe,UAACC,YAAD,EAAeC,MAAf,EAA0B;AAC9C;AACA,QAAIR,aAAa,CAACQ,MAAM,CAACC,MAAR,CAAjB,EAAkC;AAAA,kCACMtB,oBAAoB,CAACqB,MAAM,CAACC,MAAR,CAD1B;AAAA,UACxBb,aADwB,yBACxBA,aADwB;AAAA,UACTG,UADS,yBACTA,UADS;;AAEhCQ,MAAAA,YAAY,GAAGG,IAAI,CAACC,GAAL,CAASJ,YAAT,EAAuBX,aAAa,GAAGG,UAAvC,CAAf;AACD;;AAED,WAAOQ,YAAP;AACD,GARM,EAQJ,CARI,CAAP;AASD,CAVM,C,CAYP;;;;;AACO,IAAMK,cAAc,GAAG,SAAjBA,cAAiB,CAACL,YAAD,EAAuBM,SAAvB,EAAiD;AAC7E,MAAIN,YAAY,GAAG,CAAnB,EAAsB;AACpB,QAAMO,SAAS,GAAGC,IAAI,CAACC,GAAL,EAAlB;AACA,QAAMC,OAAO,GAAGH,SAAS,GAAGP,YAA5B;;AAEA,QAAMW,OAAO,GAAG,SAAVA,OAAU,GAAM;AACpBL,MAAAA,SAAS;;AAET,UAAII,OAAO,GAAGF,IAAI,CAACC,GAAL,EAAd,EAA0B;AACxBG,QAAAA,qBAAqB,CAACD,OAAD,CAArB;AACD;AACF,KAND;;AAQAC,IAAAA,qBAAqB,CAACD,OAAD,CAArB;AACD;AACF,CAfM,C,CAiBP;;;;;AACO,IAAME,4BAA4B,GAAG,SAA/BA,4BAA+B,CAC1Cf,OAD0C,EAE1CQ,SAF0C,EAGvC;AACHD,EAAAA,cAAc,CAACR,eAAe,CAACC,OAAD,CAAhB,EAA2BQ,SAA3B,CAAd;AACD,CALM","sourcesContent":["const GROUP_NUMERIC = /^([\\d.]+)(s|ms)/;\n\nfunction getMilliseconds(value: string, unit: string) {\n  // Given the regex match and capture groups, we can assume `unit` to be either 's' or 'ms'\n  const multiplier = unit === 's' ? 1000 : 1;\n  return parseFloat(value) * multiplier;\n}\n// Find CSS `transition-duration` and `transition-delay` intervals\n// and return the value of each computed property in 'ms'\nexport const getTransitionTimings = (element: Element) => {\n  const computedStyle = window.getComputedStyle(element);\n\n  const computedDuration = computedStyle.getPropertyValue(\n    'transition-duration'\n  );\n  const durationMatchArray = computedDuration.match(GROUP_NUMERIC);\n  const durationMatch = durationMatchArray\n    ? getMilliseconds(durationMatchArray[1], durationMatchArray[2])\n    : 0;\n\n  const computedDelay = computedStyle.getPropertyValue('transition-delay');\n  const delayMatchArray = computedDelay.match(GROUP_NUMERIC);\n  const delayMatch = delayMatchArray\n    ? getMilliseconds(delayMatchArray[1], delayMatchArray[2])\n    : 0;\n\n  return { durationMatch, delayMatch };\n};\n\nfunction isElementNode(element: Node): element is Element {\n  return element.nodeType === document.ELEMENT_NODE;\n}\n// Uses `getTransitionTimings` to find the total transition time for\n// all elements targeted by a MutationObserver callback\nexport const getWaitDuration = (records: MutationRecord[]) => {\n  return records.reduce((waitDuration, record) => {\n    // only check for CSS transition values for ELEMENT nodes\n    if (isElementNode(record.target)) {\n      const { durationMatch, delayMatch } = getTransitionTimings(record.target);\n      waitDuration = Math.max(waitDuration, durationMatch + delayMatch);\n    }\n\n    return waitDuration;\n  }, 0);\n};\n\n// Uses `requestAnimationFrame` to perform a given callback after a specified waiting period\nexport const performOnFrame = (waitDuration: number, toPerform: () => void) => {\n  if (waitDuration > 0) {\n    const startTime = Date.now();\n    const endTime = startTime + waitDuration;\n\n    const onFrame = () => {\n      toPerform();\n\n      if (endTime > Date.now()) {\n        requestAnimationFrame(onFrame);\n      }\n    };\n\n    requestAnimationFrame(onFrame);\n  }\n};\n\n// Convenience method for combining the result of 'getWaitDuration' directly with 'performOnFrame'\nexport const getDurationAndPerformOnFrame = (\n  records: MutationRecord[],\n  toPerform: () => void\n) => {\n  performOnFrame(getWaitDuration(records), toPerform);\n};\n"]}]}