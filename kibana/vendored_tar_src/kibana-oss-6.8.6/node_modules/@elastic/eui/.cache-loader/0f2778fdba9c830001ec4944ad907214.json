{"remainingRequest":"/Users/chanderprall/projects/eui/node_modules/babel-loader/lib/index.js!/Users/chanderprall/projects/eui/src/components/popover/popover.tsx","dependencies":[{"path":"/Users/chanderprall/projects/eui/src/components/popover/popover.tsx","mtime":1567626462181},{"path":"/Users/chanderprall/projects/eui/.babelrc.js","mtime":1565204168946},{"path":"/Users/chanderprall/projects/eui/node_modules/cache-loader/dist/cjs.js","mtime":1555436064329},{"path":"/Users/chanderprall/projects/eui/node_modules/babel-loader/lib/index.js","mtime":1543517280769}],"contextDependencies":[],"result":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getPopoverPositionFromAnchorPosition = getPopoverPositionFromAnchorPosition;\nexports.getPopoverAlignFromAnchorPosition = getPopoverAlignFromAnchorPosition;\nexports.EuiPopover = exports.DISPLAY = exports.ANCHOR_POSITIONS = void 0;\n\nvar _propTypes = _interopRequireDefault(require(\"prop-types\"));\n\nrequire(\"core-js/modules/es6.object.assign\");\n\nrequire(\"core-js/modules/es6.object.set-prototype-of\");\n\nrequire(\"core-js/modules/es7.symbol.async-iterator\");\n\nrequire(\"core-js/modules/es6.symbol\");\n\nrequire(\"core-js/modules/web.dom.iterable\");\n\nrequire(\"core-js/modules/es6.array.iterator\");\n\nrequire(\"core-js/modules/es6.object.keys\");\n\nrequire(\"core-js/modules/es6.regexp.match\");\n\nvar _react = _interopRequireWildcard(require(\"react\"));\n\nvar _classnames = _interopRequireDefault(require(\"classnames\"));\n\nvar _tabbable = _interopRequireDefault(require(\"tabbable\"));\n\nvar _focus_trap = require(\"../focus_trap\");\n\nvar _services = require(\"../../services\");\n\nvar _outside_click_detector = require(\"../outside_click_detector\");\n\nvar _accessibility = require(\"../accessibility\");\n\nvar _panel = require(\"../panel\");\n\nvar _portal = require(\"../portal\");\n\nvar _mutation_observer = require(\"../observer/mutation_observer\");\n\nvar _popover = require(\"../../services/popover\");\n\nvar _i18n = require(\"../i18n\");\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); }\n\nfunction _iterableToArrayLimit(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nvar anchorPositionToPopoverPositionMap = {\n  up: 'top',\n  right: 'right',\n  down: 'bottom',\n  left: 'left'\n};\n\nfunction getPopoverPositionFromAnchorPosition(anchorPosition) {\n  // maps the anchor position to the matching popover position\n  // e.g. \"upLeft\" -> \"top\", \"downRight\" -> \"bottom\"\n  // extract the first positional word from anchorPosition:\n  // starts at the beginning (\" ^ \") of anchorPosition and\n  // captures all of the characters (\" (.*?) \") until the\n  var _ref = anchorPosition.match(/^(.*?)[A-Z]/),\n      _ref2 = _slicedToArray(_ref, 2),\n      primaryPosition = _ref2[1];\n\n  return anchorPositionToPopoverPositionMap[primaryPosition];\n}\n\nfunction getPopoverAlignFromAnchorPosition(anchorPosition) {\n  // maps the gravity to the matching popover position\n  // e.g. \"upLeft\" -> \"left\", \"rightDown\" -> \"bottom\"\n  // extract the second positional word from anchorPosition:\n  // starts a capture group at the first capital letter\n  var _ref3 = anchorPosition.match(/([A-Z].*)/),\n      _ref4 = _slicedToArray(_ref3, 2),\n      align = _ref4[1]; // this performs two tasks:\n  // 1. normalizes the align position by lowercasing it\n  // 2. `center` doesn't exist in the lookup map which converts it to `undefined` meaning no align\n\n\n  return anchorPositionToPopoverPositionMap[align.toLowerCase()];\n}\n\nvar anchorPositionToClassNameMap = {\n  upCenter: 'euiPopover--anchorUpCenter',\n  upLeft: 'euiPopover--anchorUpLeft',\n  upRight: 'euiPopover--anchorUpRight',\n  downCenter: 'euiPopover--anchorDownCenter',\n  downLeft: 'euiPopover--anchorDownLeft',\n  downRight: 'euiPopover--anchorDownRight',\n  leftCenter: 'euiPopover--anchorLeftCenter',\n  leftUp: 'euiPopover--anchorLeftUp',\n  leftDown: 'euiPopover--anchorLeftDown',\n  rightCenter: 'euiPopover--anchorRightCenter',\n  rightUp: 'euiPopover--anchorRightUp',\n  rightDown: 'euiPopover--anchorRightDown'\n};\nvar ANCHOR_POSITIONS = Object.keys(anchorPositionToClassNameMap);\nexports.ANCHOR_POSITIONS = ANCHOR_POSITIONS;\nvar displayToClassNameMap = {\n  inlineBlock: undefined,\n  block: 'euiPopover--displayBlock'\n};\nvar DISPLAY = Object.keys(displayToClassNameMap);\nexports.DISPLAY = DISPLAY;\nvar DEFAULT_POPOVER_STYLES = {\n  top: 50,\n  left: 50\n};\n\nfunction getElementFromInitialFocus(initialFocus) {\n  var initialFocusType = _typeof(initialFocus);\n\n  if (initialFocusType === 'string') {\n    return document.querySelector(initialFocus);\n  }\n\n  if (initialFocusType === 'function') {\n    return initialFocus();\n  }\n\n  return initialFocus;\n}\n\nvar EuiPopover =\n/*#__PURE__*/\nfunction (_Component) {\n  _inherits(EuiPopover, _Component);\n\n  _createClass(EuiPopover, null, [{\n    key: \"getDerivedStateFromProps\",\n    value: function getDerivedStateFromProps(nextProps, prevState) {\n      if (prevState.prevProps.isOpen && !nextProps.isOpen) {\n        return {\n          prevProps: {\n            isOpen: nextProps.isOpen\n          },\n          isClosing: true,\n          isOpening: false\n        };\n      }\n\n      if (prevState.prevProps.isOpen !== nextProps.isOpen) {\n        return {\n          prevProps: {\n            isOpen: nextProps.isOpen\n          }\n        };\n      }\n\n      return null;\n    }\n  }]);\n\n  function EuiPopover(props) {\n    var _this;\n\n    _classCallCheck(this, EuiPopover);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(EuiPopover).call(this, props));\n\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"closingTransitionTimeout\", void 0);\n\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"button\", null);\n\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"panel\", null);\n\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"onKeyDown\", function (e) {\n      if (e.keyCode === _services.cascadingMenuKeyCodes.ESCAPE) {\n        if (_this.state.isOpenStable || _this.state.isOpening) {\n          e.preventDefault();\n          e.stopPropagation();\n\n          _this.props.closePopover();\n        }\n      }\n    });\n\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"onMutation\", function (records) {\n      var waitDuration = (0, _services.getWaitDuration)(records);\n\n      _this.positionPopoverFixed();\n\n      (0, _services.performOnFrame)(waitDuration, _this.positionPopoverFixed);\n    });\n\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"positionPopover\", function (allowEnforcePosition) {\n      if (_this.button == null || _this.panel == null) return;\n      var _ref5 = _this.props,\n          anchorPosition = _ref5.anchorPosition;\n      var position = getPopoverPositionFromAnchorPosition(anchorPosition);\n      var forcePosition = undefined;\n\n      if (allowEnforcePosition && _this.state.isOpenStable && _this.state.openPosition != null) {\n        position = _this.state.openPosition;\n        forcePosition = true;\n      }\n\n      var _findPopoverPosition = (0, _popover.findPopoverPosition)({\n        container: _this.props.container,\n        position: position,\n        forcePosition: forcePosition,\n        align: getPopoverAlignFromAnchorPosition(anchorPosition),\n        anchor: _this.button,\n        popover: _this.panel,\n        offset: !_this.props.attachToAnchor && _this.props.hasArrow ? 16 : 8,\n        arrowConfig: {\n          arrowWidth: 24,\n          arrowBuffer: 10\n        },\n        returnBoundingBox: _this.props.attachToAnchor\n      }),\n          top = _findPopoverPosition.top,\n          left = _findPopoverPosition.left,\n          foundPosition = _findPopoverPosition.position,\n          arrow = _findPopoverPosition.arrow,\n          anchorBoundingBox = _findPopoverPosition.anchorBoundingBox; // the popover's z-index must inherit from the button\n      // this keeps a button's popover under a flyout that would cover the button\n      // but a popover triggered inside a flyout will appear over that flyout\n\n\n      var zIndexProp = _this.props.zIndex;\n      var zIndex = zIndexProp == null ? (0, _popover.getElementZIndex)(_this.button, _this.panel) : zIndexProp;\n      var popoverStyles = {\n        top: top,\n        left: _this.props.attachToAnchor && anchorBoundingBox ? anchorBoundingBox.left : left,\n        zIndex: zIndex\n      };\n      var willRenderArrow = !_this.props.attachToAnchor && _this.props.hasArrow;\n      var arrowStyles = willRenderArrow ? arrow : undefined;\n      var arrowPosition = foundPosition;\n\n      _this.setState({\n        popoverStyles: popoverStyles,\n        arrowStyles: arrowStyles,\n        arrowPosition: arrowPosition,\n        openPosition: foundPosition\n      });\n    });\n\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"positionPopoverFixed\", function () {\n      _this.positionPopover(true);\n    });\n\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"positionPopoverFluid\", function () {\n      _this.positionPopover(false);\n    });\n\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"panelRef\", function (node) {\n      _this.panel = node;\n      _this.props.panelRef && _this.props.panelRef(node);\n\n      if (node == null) {\n        // panel has unmounted, restore the state defaults\n        _this.setState({\n          popoverStyles: DEFAULT_POPOVER_STYLES,\n          arrowStyles: {},\n          arrowPosition: null,\n          openPosition: null,\n          isOpenStable: false\n        });\n\n        window.removeEventListener('resize', _this.positionPopoverFluid);\n      } else {\n        // panel is coming into existence\n        _this.positionPopoverFluid();\n\n        window.addEventListener('resize', _this.positionPopoverFluid);\n      }\n    });\n\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"buttonRef\", function (node) {\n      _this.button = node;\n      _this.props.buttonRef && _this.props.buttonRef(node);\n    });\n\n    _this.state = {\n      prevProps: {\n        isOpen: props.isOpen\n      },\n      suppressingPopover: _this.props.isOpen,\n      // only suppress if created with isOpen=true\n      isClosing: false,\n      isOpening: false,\n      popoverStyles: DEFAULT_POPOVER_STYLES,\n      arrowStyles: {},\n      arrowPosition: null,\n      openPosition: null,\n      // once a stable position has been found, keep the contents on that side\n      isOpenStable: false // wait for any initial opening transitions to finish before marking as stable\n\n    };\n    return _this;\n  }\n\n  _createClass(EuiPopover, [{\n    key: \"updateFocus\",\n    value: function updateFocus() {\n      var _this2 = this;\n\n      // Wait for the DOM to update.\n      window.requestAnimationFrame(function () {\n        if (!_this2.props.ownFocus || !_this2.panel) {\n          return;\n        } // If we've already focused on something inside the panel, everything's fine.\n\n\n        if (_this2.panel.contains(document.activeElement)) {\n          return;\n        } // Otherwise let's focus the first tabbable item and expedite input from the user.\n\n\n        var focusTarget;\n\n        if (_this2.props.initialFocus != null) {\n          focusTarget = getElementFromInitialFocus(_this2.props.initialFocus);\n\n          if (focusTarget) {\n            // there's a race condition between the popover content becoming visible and this function call\n            // if the element isn't visible yet (due to css styling) then it can't accept focus\n            // so wait for another render and try again\n            var visibility = window.getComputedStyle(focusTarget).visibility;\n\n            if (visibility === 'hidden') {\n              _this2.updateFocus();\n            }\n          }\n        } else {\n          var tabbableItems = (0, _tabbable.default)(_this2.panel);\n\n          if (tabbableItems.length) {\n            focusTarget = tabbableItems[0];\n          }\n        }\n\n        if (focusTarget != null) focusTarget.focus();\n      });\n    }\n  }, {\n    key: \"componentDidMount\",\n    value: function componentDidMount() {\n      if (this.state.suppressingPopover) {\n        // component was created with isOpen=true; now that it's mounted\n        // stop suppressing and start opening\n        this.setState({\n          suppressingPopover: false,\n          isOpening: true\n        }); // eslint-disable-line react/no-did-mount-set-state\n      }\n\n      if (this.props.repositionOnScroll) {\n        window.addEventListener('scroll', this.positionPopoverFixed);\n      }\n\n      this.updateFocus();\n    }\n  }, {\n    key: \"componentDidUpdate\",\n    value: function componentDidUpdate(prevProps) {\n      var _this3 = this;\n\n      // The popover is being opened.\n      if (!prevProps.isOpen && this.props.isOpen) {\n        clearTimeout(this.closingTransitionTimeout); // We need to set this state a beat after the render takes place, so that the CSS\n        // transition can take effect.\n\n        window.requestAnimationFrame(function () {\n          _this3.setState({\n            isOpening: true\n          });\n        }); // for each child element of `this.panel`, find any transition duration we should wait for before stabilizing\n\n        var _Array$prototype$slic = Array.prototype.slice.call(this.panel ? this.panel.children : undefined).reduce(function (_ref6, element) {\n          var durationMatch = _ref6.durationMatch,\n              delayMatch = _ref6.delayMatch;\n          var transitionTimings = (0, _services.getTransitionTimings)(element);\n          return {\n            durationMatch: Math.max(durationMatch, transitionTimings.durationMatch),\n            delayMatch: Math.max(delayMatch, transitionTimings.delayMatch)\n          };\n        }, {\n          durationMatch: 0,\n          delayMatch: 0\n        }),\n            durationMatch = _Array$prototype$slic.durationMatch,\n            delayMatch = _Array$prototype$slic.delayMatch;\n\n        setTimeout(function () {\n          _this3.setState({\n            isOpenStable: true\n          }, function () {\n            _this3.positionPopoverFixed();\n\n            _this3.updateFocus();\n          });\n        }, durationMatch + delayMatch);\n      } // update scroll listener\n\n\n      if (prevProps.repositionOnScroll !== this.props.repositionOnScroll) {\n        if (this.props.repositionOnScroll) {\n          window.addEventListener('scroll', this.positionPopoverFixed);\n        } else {\n          window.removeEventListener('scroll', this.positionPopoverFixed);\n        }\n      } // The popover is being closed.\n\n\n      if (prevProps.isOpen && !this.props.isOpen) {\n        // If the user has just closed the popover, queue up the removal of the content after the\n        // transition is complete.\n        this.closingTransitionTimeout = window.setTimeout(function () {\n          _this3.setState({\n            isClosing: false\n          });\n        }, 250);\n      }\n    }\n  }, {\n    key: \"componentWillUnmount\",\n    value: function componentWillUnmount() {\n      window.removeEventListener('scroll', this.positionPopoverFixed);\n      clearTimeout(this.closingTransitionTimeout);\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      var _this4 = this;\n\n      var _this$props = this.props,\n          anchorClassName = _this$props.anchorClassName,\n          anchorPosition = _this$props.anchorPosition,\n          button = _this$props.button,\n          buttonRef = _this$props.buttonRef,\n          insert = _this$props.insert,\n          isOpen = _this$props.isOpen,\n          ownFocus = _this$props.ownFocus,\n          withTitle = _this$props.withTitle,\n          children = _this$props.children,\n          className = _this$props.className,\n          closePopover = _this$props.closePopover,\n          panelClassName = _this$props.panelClassName,\n          panelPaddingSize = _this$props.panelPaddingSize,\n          panelRef = _this$props.panelRef,\n          popoverRef = _this$props.popoverRef,\n          hasArrow = _this$props.hasArrow,\n          repositionOnScroll = _this$props.repositionOnScroll,\n          zIndex = _this$props.zIndex,\n          initialFocus = _this$props.initialFocus,\n          attachToAnchor = _this$props.attachToAnchor,\n          display = _this$props.display,\n          rest = _objectWithoutProperties(_this$props, [\"anchorClassName\", \"anchorPosition\", \"button\", \"buttonRef\", \"insert\", \"isOpen\", \"ownFocus\", \"withTitle\", \"children\", \"className\", \"closePopover\", \"panelClassName\", \"panelPaddingSize\", \"panelRef\", \"popoverRef\", \"hasArrow\", \"repositionOnScroll\", \"zIndex\", \"initialFocus\", \"attachToAnchor\", \"display\"]);\n\n      var classes = (0, _classnames.default)('euiPopover', anchorPosition ? anchorPositionToClassNameMap[anchorPosition] : null, display ? displayToClassNameMap[display] : null, {\n        'euiPopover-isOpen': this.state.isOpening,\n        'euiPopover--withTitle': withTitle\n      }, className);\n      var anchorClasses = (0, _classnames.default)('euiPopover__anchor', anchorClassName);\n      var panelClasses = (0, _classnames.default)('euiPopover__panel', \"euiPopover__panel--\".concat(this.state.arrowPosition), {\n        'euiPopover__panel-isOpen': this.state.isOpening\n      }, {\n        'euiPopover__panel-withTitle': withTitle\n      }, {\n        'euiPopover__panel-noArrow': !hasArrow || attachToAnchor\n      }, {\n        'euiPopover__panel-isAttached': attachToAnchor\n      }, panelClassName);\n      var panel;\n\n      if (!this.state.suppressingPopover && (isOpen || this.state.isClosing)) {\n        var tabIndex;\n\n        var _initialFocus;\n\n        var ariaLive;\n\n        if (ownFocus) {\n          tabIndex = 0;\n          ariaLive = 'off';\n\n          _initialFocus = function _initialFocus() {\n            return _this4.panel;\n          };\n        } else {\n          ariaLive = 'assertive';\n        }\n\n        var focusTrapScreenReaderText;\n\n        if (ownFocus) {\n          focusTrapScreenReaderText = _react.default.createElement(_accessibility.EuiScreenReaderOnly, null, _react.default.createElement(\"p\", {\n            role: \"alert\"\n          }, _react.default.createElement(_i18n.EuiI18n, {\n            token: \"euiPopover.screenReaderAnnouncement\",\n            default: \"You are in a popup. To exit this popup, hit escape.\"\n          })));\n        }\n\n        var arrowClassNames = (0, _classnames.default)('euiPopover__panelArrow', \"euiPopover__panelArrow--\".concat(this.state.arrowPosition));\n        panel = _react.default.createElement(_portal.EuiPortal, {\n          insert: insert\n        }, _react.default.createElement(_focus_trap.EuiFocusTrap, {\n          returnFocus: !this.state.isOpening // Ignore temporary state of indecisive focus\n          ,\n          clickOutsideDisables: true,\n          initialFocus: _initialFocus,\n          disabled: !ownFocus\n        }, focusTrapScreenReaderText, _react.default.createElement(_panel.EuiPanel, {\n          panelRef: this.panelRef,\n          className: panelClasses,\n          paddingSize: panelPaddingSize,\n          tabIndex: tabIndex,\n          \"aria-live\": ariaLive,\n          style: this.state.popoverStyles\n        }, _react.default.createElement(\"div\", {\n          className: arrowClassNames,\n          style: this.state.arrowStyles\n        }), _react.default.createElement(_mutation_observer.EuiMutationObserver, {\n          observerOptions: {\n            attributes: true,\n            // element attribute changes\n            childList: true,\n            // added/removed elements\n            characterData: true,\n            // text changes\n            subtree: true // watch all child elements\n\n          },\n          onMutation: this.onMutation\n        }, function (mutationRef) {\n          return _react.default.createElement(\"div\", {\n            ref: mutationRef\n          }, children);\n        }))));\n      }\n\n      return _react.default.createElement(_outside_click_detector.EuiOutsideClickDetector, {\n        isDisabled: !isOpen,\n        onOutsideClick: closePopover\n      }, _react.default.createElement(\"div\", _extends({\n        className: classes,\n        onKeyDown: this.onKeyDown,\n        ref: popoverRef\n      }, rest), _react.default.createElement(\"div\", {\n        className: anchorClasses,\n        ref: this.buttonRef\n      }, button instanceof HTMLElement ? null : button), panel));\n    }\n  }]);\n\n  return EuiPopover;\n}(_react.Component);\n\nexports.EuiPopover = EuiPopover;\n\n_defineProperty(EuiPopover, \"defaultProps\", {\n  isOpen: false,\n  ownFocus: false,\n  anchorPosition: 'downCenter',\n  panelPaddingSize: 'm',\n  hasArrow: true,\n  display: 'inlineBlock'\n});\n\nEuiPopover.propTypes = {\n  className: _propTypes.default.string,\n  \"aria-label\": _propTypes.default.string,\n  \"data-test-subj\": _propTypes.default.string,\n  anchorClassName: _propTypes.default.string,\n  anchorPosition: _propTypes.default.oneOf([\"upCenter\", \"upLeft\", \"upRight\", \"downCenter\", \"downLeft\", \"downRight\", \"leftCenter\", \"leftUp\", \"leftDown\", \"rightCenter\", \"rightUp\", \"rightDown\"]),\n\n  /** Style and position alteration for arrow-less, left-aligned\n     * attachment. Intended for use with inputs as anchors, Ã  la\n     * EuiColorPicker */\n  attachToAnchor: _propTypes.default.bool,\n  button: _propTypes.default.any.isRequired,\n  buttonRef: _propTypes.default.any,\n  closePopover: _propTypes.default.any.isRequired,\n  container: _propTypes.default.any,\n\n  /** CSS display type for both the popover and anchor */\n  display: _propTypes.default.oneOf([\"inlineBlock\", \"block\"]),\n  hasArrow: _propTypes.default.bool,\n\n  /** specifies what element should initially have focus; Can be a DOM\n     * node, or a selector string (which will be passed to\n     * document.querySelector() to find the DOM node), or a function that\n     * returns a DOM node. */\n  initialFocus: _propTypes.default.any,\n\n  /** Passed directly to EuiPortal for DOM positioning. Both properties are\n     * required if prop is specified **/\n  insert: _propTypes.default.shape({\n    sibling: _propTypes.default.any.isRequired,\n    position: _propTypes.default.oneOf([\"before\", \"after\"]).isRequired\n  }),\n  isOpen: _propTypes.default.bool,\n  ownFocus: _propTypes.default.bool,\n  panelClassName: _propTypes.default.string,\n  panelPaddingSize: _propTypes.default.oneOf([\"none\", \"s\", \"m\", \"l\"]),\n  panelRef: _propTypes.default.any,\n  popoverRef: _propTypes.default.any,\n\n  /** When `true`, the popover's position is re-calculated when the user\n     * scrolls, this supports having fixed-position popover anchors. */\n  repositionOnScroll: _propTypes.default.bool,\n  withTitle: _propTypes.default.bool,\n\n  /** By default, popover content inherits the z-index of the anchor\n     * component; pass zIndex to override */\n  zIndex: _propTypes.default.number\n};\nEuiPopover.__docgenInfo = {\n  \"description\": \"\",\n  \"methods\": [{\n    \"name\": \"getDerivedStateFromProps\",\n    \"docblock\": null,\n    \"modifiers\": [\"static\"],\n    \"params\": [{\n      \"name\": \"nextProps\",\n      \"type\": null\n    }, {\n      \"name\": \"prevState\",\n      \"type\": null\n    }],\n    \"returns\": null\n  }, {\n    \"name\": \"onKeyDown\",\n    \"docblock\": null,\n    \"modifiers\": [],\n    \"params\": [{\n      \"name\": \"e\",\n      \"type\": null\n    }],\n    \"returns\": null\n  }, {\n    \"name\": \"updateFocus\",\n    \"docblock\": null,\n    \"modifiers\": [],\n    \"params\": [],\n    \"returns\": null\n  }, {\n    \"name\": \"onMutation\",\n    \"docblock\": null,\n    \"modifiers\": [],\n    \"params\": [{\n      \"name\": \"records\",\n      \"type\": null\n    }],\n    \"returns\": null\n  }, {\n    \"name\": \"positionPopover\",\n    \"docblock\": null,\n    \"modifiers\": [],\n    \"params\": [{\n      \"name\": \"allowEnforcePosition\",\n      \"type\": null\n    }],\n    \"returns\": null\n  }, {\n    \"name\": \"positionPopoverFixed\",\n    \"docblock\": null,\n    \"modifiers\": [],\n    \"params\": [],\n    \"returns\": null\n  }, {\n    \"name\": \"positionPopoverFluid\",\n    \"docblock\": null,\n    \"modifiers\": [],\n    \"params\": [],\n    \"returns\": null\n  }, {\n    \"name\": \"panelRef\",\n    \"docblock\": null,\n    \"modifiers\": [],\n    \"params\": [{\n      \"name\": \"node\",\n      \"type\": null\n    }],\n    \"returns\": null\n  }, {\n    \"name\": \"buttonRef\",\n    \"docblock\": null,\n    \"modifiers\": [],\n    \"params\": [{\n      \"name\": \"node\",\n      \"type\": null\n    }],\n    \"returns\": null\n  }],\n  \"displayName\": \"EuiPopover\",\n  \"props\": {\n    \"isOpen\": {\n      \"defaultValue\": {\n        \"value\": \"false\",\n        \"computed\": false\n      },\n      \"type\": {\n        \"name\": \"bool\"\n      },\n      \"required\": false,\n      \"description\": \"\"\n    },\n    \"ownFocus\": {\n      \"defaultValue\": {\n        \"value\": \"false\",\n        \"computed\": false\n      },\n      \"type\": {\n        \"name\": \"bool\"\n      },\n      \"required\": false,\n      \"description\": \"\"\n    },\n    \"anchorPosition\": {\n      \"defaultValue\": {\n        \"value\": \"'downCenter'\",\n        \"computed\": false\n      },\n      \"type\": {\n        \"name\": \"enum\",\n        \"value\": [{\n          \"value\": \"\\\"upCenter\\\"\",\n          \"computed\": false\n        }, {\n          \"value\": \"\\\"upLeft\\\"\",\n          \"computed\": false\n        }, {\n          \"value\": \"\\\"upRight\\\"\",\n          \"computed\": false\n        }, {\n          \"value\": \"\\\"downCenter\\\"\",\n          \"computed\": false\n        }, {\n          \"value\": \"\\\"downLeft\\\"\",\n          \"computed\": false\n        }, {\n          \"value\": \"\\\"downRight\\\"\",\n          \"computed\": false\n        }, {\n          \"value\": \"\\\"leftCenter\\\"\",\n          \"computed\": false\n        }, {\n          \"value\": \"\\\"leftUp\\\"\",\n          \"computed\": false\n        }, {\n          \"value\": \"\\\"leftDown\\\"\",\n          \"computed\": false\n        }, {\n          \"value\": \"\\\"rightCenter\\\"\",\n          \"computed\": false\n        }, {\n          \"value\": \"\\\"rightUp\\\"\",\n          \"computed\": false\n        }, {\n          \"value\": \"\\\"rightDown\\\"\",\n          \"computed\": false\n        }]\n      },\n      \"required\": false,\n      \"description\": \"\"\n    },\n    \"panelPaddingSize\": {\n      \"defaultValue\": {\n        \"value\": \"'m'\",\n        \"computed\": false\n      },\n      \"type\": {\n        \"name\": \"enum\",\n        \"value\": [{\n          \"value\": \"\\\"none\\\"\",\n          \"computed\": false\n        }, {\n          \"value\": \"\\\"s\\\"\",\n          \"computed\": false\n        }, {\n          \"value\": \"\\\"m\\\"\",\n          \"computed\": false\n        }, {\n          \"value\": \"\\\"l\\\"\",\n          \"computed\": false\n        }]\n      },\n      \"required\": false,\n      \"description\": \"\"\n    },\n    \"hasArrow\": {\n      \"defaultValue\": {\n        \"value\": \"true\",\n        \"computed\": false\n      },\n      \"type\": {\n        \"name\": \"bool\"\n      },\n      \"required\": false,\n      \"description\": \"\"\n    },\n    \"display\": {\n      \"defaultValue\": {\n        \"value\": \"'inlineBlock'\",\n        \"computed\": false\n      },\n      \"type\": {\n        \"name\": \"enum\",\n        \"value\": [{\n          \"value\": \"\\\"inlineBlock\\\"\",\n          \"computed\": false\n        }, {\n          \"value\": \"\\\"block\\\"\",\n          \"computed\": false\n        }]\n      },\n      \"required\": false,\n      \"description\": \"CSS display type for both the popover and anchor\"\n    },\n    \"className\": {\n      \"type\": {\n        \"name\": \"custom\",\n        \"raw\": \"_propTypes.default.string\"\n      },\n      \"required\": false,\n      \"description\": \"\"\n    },\n    \"aria-label\": {\n      \"type\": {\n        \"name\": \"custom\",\n        \"raw\": \"_propTypes.default.string\"\n      },\n      \"required\": false,\n      \"description\": \"\"\n    },\n    \"data-test-subj\": {\n      \"type\": {\n        \"name\": \"custom\",\n        \"raw\": \"_propTypes.default.string\"\n      },\n      \"required\": false,\n      \"description\": \"\"\n    },\n    \"anchorClassName\": {\n      \"type\": {\n        \"name\": \"string\"\n      },\n      \"required\": false,\n      \"description\": \"\"\n    },\n    \"attachToAnchor\": {\n      \"type\": {\n        \"name\": \"bool\"\n      },\n      \"required\": false,\n      \"description\": \"Style and position alteration for arrow-less, left-aligned\\nattachment. Intended for use with inputs as anchors, \\xE0 la\\nEuiColorPicker\"\n    },\n    \"button\": {\n      \"type\": {\n        \"name\": \"any\"\n      },\n      \"required\": true,\n      \"description\": \"\"\n    },\n    \"buttonRef\": {\n      \"type\": {\n        \"name\": \"any\"\n      },\n      \"required\": false,\n      \"description\": \"\"\n    },\n    \"closePopover\": {\n      \"type\": {\n        \"name\": \"any\"\n      },\n      \"required\": true,\n      \"description\": \"\"\n    },\n    \"container\": {\n      \"type\": {\n        \"name\": \"any\"\n      },\n      \"required\": false,\n      \"description\": \"\"\n    },\n    \"initialFocus\": {\n      \"type\": {\n        \"name\": \"any\"\n      },\n      \"required\": false,\n      \"description\": \"specifies what element should initially have focus; Can be a DOM\\nnode, or a selector string (which will be passed to\\ndocument.querySelector() to find the DOM node), or a function that\\nreturns a DOM node.\"\n    },\n    \"insert\": {\n      \"type\": {\n        \"name\": \"shape\",\n        \"value\": {\n          \"sibling\": {\n            \"name\": \"any\",\n            \"required\": true\n          },\n          \"position\": {\n            \"name\": \"enum\",\n            \"value\": [{\n              \"value\": \"\\\"before\\\"\",\n              \"computed\": false\n            }, {\n              \"value\": \"\\\"after\\\"\",\n              \"computed\": false\n            }],\n            \"required\": true\n          }\n        }\n      },\n      \"required\": false,\n      \"description\": \"Passed directly to EuiPortal for DOM positioning. Both properties are\\nrequired if prop is specified *\"\n    },\n    \"panelClassName\": {\n      \"type\": {\n        \"name\": \"string\"\n      },\n      \"required\": false,\n      \"description\": \"\"\n    },\n    \"panelRef\": {\n      \"type\": {\n        \"name\": \"any\"\n      },\n      \"required\": false,\n      \"description\": \"\"\n    },\n    \"popoverRef\": {\n      \"type\": {\n        \"name\": \"any\"\n      },\n      \"required\": false,\n      \"description\": \"\"\n    },\n    \"repositionOnScroll\": {\n      \"type\": {\n        \"name\": \"bool\"\n      },\n      \"required\": false,\n      \"description\": \"When `true`, the popover's position is re-calculated when the user\\nscrolls, this supports having fixed-position popover anchors.\"\n    },\n    \"withTitle\": {\n      \"type\": {\n        \"name\": \"bool\"\n      },\n      \"required\": false,\n      \"description\": \"\"\n    },\n    \"zIndex\": {\n      \"type\": {\n        \"name\": \"number\"\n      },\n      \"required\": false,\n      \"description\": \"By default, popover content inherits the z-index of the anchor\\ncomponent; pass zIndex to override\"\n    }\n  }\n};",{"version":3,"sources":["/Users/chanderprall/projects/eui/src/components/popover/popover.tsx"],"names":["anchorPositionToPopoverPositionMap","up","right","down","left","getPopoverPositionFromAnchorPosition","anchorPosition","match","primaryPosition","getPopoverAlignFromAnchorPosition","align","toLowerCase","anchorPositionToClassNameMap","upCenter","upLeft","upRight","downCenter","downLeft","downRight","leftCenter","leftUp","leftDown","rightCenter","rightUp","rightDown","ANCHOR_POSITIONS","Object","keys","displayToClassNameMap","inlineBlock","undefined","block","DISPLAY","DEFAULT_POPOVER_STYLES","top","getElementFromInitialFocus","initialFocus","initialFocusType","document","querySelector","EuiPopover","nextProps","prevState","prevProps","isOpen","isClosing","isOpening","props","e","keyCode","cascadingMenuKeyCodes","ESCAPE","state","isOpenStable","preventDefault","stopPropagation","closePopover","records","waitDuration","positionPopoverFixed","allowEnforcePosition","button","panel","position","forcePosition","openPosition","container","anchor","popover","offset","attachToAnchor","hasArrow","arrowConfig","arrowWidth","arrowBuffer","returnBoundingBox","foundPosition","arrow","anchorBoundingBox","zIndexProp","zIndex","popoverStyles","willRenderArrow","arrowStyles","arrowPosition","setState","positionPopover","node","panelRef","window","removeEventListener","positionPopoverFluid","addEventListener","buttonRef","suppressingPopover","requestAnimationFrame","ownFocus","contains","activeElement","focusTarget","visibility","getComputedStyle","updateFocus","tabbableItems","length","focus","repositionOnScroll","clearTimeout","closingTransitionTimeout","Array","prototype","slice","call","children","reduce","element","durationMatch","delayMatch","transitionTimings","Math","max","setTimeout","anchorClassName","insert","withTitle","className","panelClassName","panelPaddingSize","popoverRef","display","rest","classes","anchorClasses","panelClasses","tabIndex","ariaLive","focusTrapScreenReaderText","arrowClassNames","attributes","childList","characterData","subtree","onMutation","mutationRef","onKeyDown","HTMLElement","Component"],"mappings":"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","sourcesContent":["import \"core-js/modules/web.dom.iterable\";\nimport \"core-js/modules/es6.array.iterator\";\nimport \"core-js/modules/es6.object.keys\";\nimport \"core-js/modules/es6.regexp.match\";\n\nfunction _typeof(obj) {\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function (obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function (obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}\n\nimport PropTypes from \"prop-types\";\n\nfunction _slicedToArray(arr, i) {\n  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest();\n}\n\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n}\n\nfunction _iterableToArrayLimit(arr, i) {\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n  var _e = undefined;\n\n  try {\n    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n\n  return _arr;\n}\n\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\n\nimport React, { Component } from 'react';\nimport classNames from 'classnames';\nimport tabbable from 'tabbable';\nimport { EuiFocusTrap } from '../focus_trap';\nimport { cascadingMenuKeyCodes, getTransitionTimings, getWaitDuration, performOnFrame } from '../../services';\nimport { EuiOutsideClickDetector } from '../outside_click_detector';\nimport { EuiScreenReaderOnly } from '../accessibility';\nimport { EuiPanel } from '../panel';\nimport { EuiPortal } from '../portal';\nimport { EuiMutationObserver } from '../observer/mutation_observer';\nimport { findPopoverPosition, getElementZIndex } from '../../services/popover';\nimport { EuiI18n } from '../i18n';\nvar anchorPositionToPopoverPositionMap = {\n  up: 'top',\n  right: 'right',\n  down: 'bottom',\n  left: 'left'\n};\nexport function getPopoverPositionFromAnchorPosition(anchorPosition) {\n  // maps the anchor position to the matching popover position\n  // e.g. \"upLeft\" -> \"top\", \"downRight\" -> \"bottom\"\n  // extract the first positional word from anchorPosition:\n  // starts at the beginning (\" ^ \") of anchorPosition and\n  // captures all of the characters (\" (.*?) \") until the\n  var _ref = anchorPosition.match(/^(.*?)[A-Z]/),\n      _ref2 = _slicedToArray(_ref, 2),\n      primaryPosition = _ref2[1];\n\n  return anchorPositionToPopoverPositionMap[primaryPosition];\n}\nexport function getPopoverAlignFromAnchorPosition(anchorPosition) {\n  // maps the gravity to the matching popover position\n  // e.g. \"upLeft\" -> \"left\", \"rightDown\" -> \"bottom\"\n  // extract the second positional word from anchorPosition:\n  // starts a capture group at the first capital letter\n  var _ref3 = anchorPosition.match(/([A-Z].*)/),\n      _ref4 = _slicedToArray(_ref3, 2),\n      align = _ref4[1]; // this performs two tasks:\n  // 1. normalizes the align position by lowercasing it\n  // 2. `center` doesn't exist in the lookup map which converts it to `undefined` meaning no align\n\n\n  return anchorPositionToPopoverPositionMap[align.toLowerCase()];\n}\nvar anchorPositionToClassNameMap = {\n  upCenter: 'euiPopover--anchorUpCenter',\n  upLeft: 'euiPopover--anchorUpLeft',\n  upRight: 'euiPopover--anchorUpRight',\n  downCenter: 'euiPopover--anchorDownCenter',\n  downLeft: 'euiPopover--anchorDownLeft',\n  downRight: 'euiPopover--anchorDownRight',\n  leftCenter: 'euiPopover--anchorLeftCenter',\n  leftUp: 'euiPopover--anchorLeftUp',\n  leftDown: 'euiPopover--anchorLeftDown',\n  rightCenter: 'euiPopover--anchorRightCenter',\n  rightUp: 'euiPopover--anchorRightUp',\n  rightDown: 'euiPopover--anchorRightDown'\n};\nexport var ANCHOR_POSITIONS = Object.keys(anchorPositionToClassNameMap);\nvar displayToClassNameMap = {\n  inlineBlock: undefined,\n  block: 'euiPopover--displayBlock'\n};\nexport var DISPLAY = Object.keys(displayToClassNameMap);\nvar DEFAULT_POPOVER_STYLES = {\n  top: 50,\n  left: 50\n};\n\nfunction getElementFromInitialFocus(initialFocus) {\n  var initialFocusType = _typeof(initialFocus);\n\n  if (initialFocusType === 'string') {\n    return document.querySelector(initialFocus);\n  }\n\n  if (initialFocusType === 'function') {\n    return initialFocus();\n  }\n\n  return initialFocus;\n}\n\nexport class EuiPopover extends Component {\n  static defaultProps = {\n    isOpen: false,\n    ownFocus: false,\n    anchorPosition: 'downCenter',\n    panelPaddingSize: 'm',\n    hasArrow: true,\n    display: 'inlineBlock'\n  };\n\n  static getDerivedStateFromProps(nextProps, prevState) {\n    if (prevState.prevProps.isOpen && !nextProps.isOpen) {\n      return {\n        prevProps: {\n          isOpen: nextProps.isOpen\n        },\n        isClosing: true,\n        isOpening: false\n      };\n    }\n\n    if (prevState.prevProps.isOpen !== nextProps.isOpen) {\n      return {\n        prevProps: {\n          isOpen: nextProps.isOpen\n        }\n      };\n    }\n\n    return null;\n  }\n\n  button = null;\n  panel = null;\n\n  constructor(props) {\n    super(props);\n    this.state = {\n      prevProps: {\n        isOpen: props.isOpen\n      },\n      suppressingPopover: this.props.isOpen,\n      // only suppress if created with isOpen=true\n      isClosing: false,\n      isOpening: false,\n      popoverStyles: DEFAULT_POPOVER_STYLES,\n      arrowStyles: {},\n      arrowPosition: null,\n      openPosition: null,\n      // once a stable position has been found, keep the contents on that side\n      isOpenStable: false // wait for any initial opening transitions to finish before marking as stable\n\n    };\n  }\n\n  onKeyDown = e => {\n    if (e.keyCode === cascadingMenuKeyCodes.ESCAPE) {\n      if (this.state.isOpenStable || this.state.isOpening) {\n        e.preventDefault();\n        e.stopPropagation();\n        this.props.closePopover();\n      }\n    }\n  };\n\n  updateFocus() {\n    // Wait for the DOM to update.\n    window.requestAnimationFrame(() => {\n      if (!this.props.ownFocus || !this.panel) {\n        return;\n      } // If we've already focused on something inside the panel, everything's fine.\n\n\n      if (this.panel.contains(document.activeElement)) {\n        return;\n      } // Otherwise let's focus the first tabbable item and expedite input from the user.\n\n\n      let focusTarget;\n\n      if (this.props.initialFocus != null) {\n        focusTarget = getElementFromInitialFocus(this.props.initialFocus);\n\n        if (focusTarget) {\n          // there's a race condition between the popover content becoming visible and this function call\n          // if the element isn't visible yet (due to css styling) then it can't accept focus\n          // so wait for another render and try again\n          const visibility = window.getComputedStyle(focusTarget).visibility;\n\n          if (visibility === 'hidden') {\n            this.updateFocus();\n          }\n        }\n      } else {\n        const tabbableItems = tabbable(this.panel);\n\n        if (tabbableItems.length) {\n          focusTarget = tabbableItems[0];\n        }\n      }\n\n      if (focusTarget != null) focusTarget.focus();\n    });\n  }\n\n  componentDidMount() {\n    if (this.state.suppressingPopover) {\n      // component was created with isOpen=true; now that it's mounted\n      // stop suppressing and start opening\n      this.setState({\n        suppressingPopover: false,\n        isOpening: true\n      }); // eslint-disable-line react/no-did-mount-set-state\n    }\n\n    if (this.props.repositionOnScroll) {\n      window.addEventListener('scroll', this.positionPopoverFixed);\n    }\n\n    this.updateFocus();\n  }\n\n  componentDidUpdate(prevProps) {\n    // The popover is being opened.\n    if (!prevProps.isOpen && this.props.isOpen) {\n      clearTimeout(this.closingTransitionTimeout); // We need to set this state a beat after the render takes place, so that the CSS\n      // transition can take effect.\n\n      window.requestAnimationFrame(() => {\n        this.setState({\n          isOpening: true\n        });\n      }); // for each child element of `this.panel`, find any transition duration we should wait for before stabilizing\n\n      const {\n        durationMatch,\n        delayMatch\n      } = Array.prototype.slice.call(this.panel ? this.panel.children : undefined).reduce(({\n        durationMatch,\n        delayMatch\n      }, element) => {\n        const transitionTimings = getTransitionTimings(element);\n        return {\n          durationMatch: Math.max(durationMatch, transitionTimings.durationMatch),\n          delayMatch: Math.max(delayMatch, transitionTimings.delayMatch)\n        };\n      }, {\n        durationMatch: 0,\n        delayMatch: 0\n      });\n      setTimeout(() => {\n        this.setState({\n          isOpenStable: true\n        }, () => {\n          this.positionPopoverFixed();\n          this.updateFocus();\n        });\n      }, durationMatch + delayMatch);\n    } // update scroll listener\n\n\n    if (prevProps.repositionOnScroll !== this.props.repositionOnScroll) {\n      if (this.props.repositionOnScroll) {\n        window.addEventListener('scroll', this.positionPopoverFixed);\n      } else {\n        window.removeEventListener('scroll', this.positionPopoverFixed);\n      }\n    } // The popover is being closed.\n\n\n    if (prevProps.isOpen && !this.props.isOpen) {\n      // If the user has just closed the popover, queue up the removal of the content after the\n      // transition is complete.\n      this.closingTransitionTimeout = window.setTimeout(() => {\n        this.setState({\n          isClosing: false\n        });\n      }, 250);\n    }\n  }\n\n  componentWillUnmount() {\n    window.removeEventListener('scroll', this.positionPopoverFixed);\n    clearTimeout(this.closingTransitionTimeout);\n  }\n\n  onMutation = records => {\n    const waitDuration = getWaitDuration(records);\n    this.positionPopoverFixed();\n    performOnFrame(waitDuration, this.positionPopoverFixed);\n  };\n  positionPopover = allowEnforcePosition => {\n    if (this.button == null || this.panel == null) return;\n    const {\n      anchorPosition\n    } = this.props;\n    let position = getPopoverPositionFromAnchorPosition(anchorPosition);\n    let forcePosition = undefined;\n\n    if (allowEnforcePosition && this.state.isOpenStable && this.state.openPosition != null) {\n      position = this.state.openPosition;\n      forcePosition = true;\n    }\n\n    const {\n      top,\n      left,\n      position: foundPosition,\n      arrow,\n      anchorBoundingBox\n    } = findPopoverPosition({\n      container: this.props.container,\n      position,\n      forcePosition,\n      align: getPopoverAlignFromAnchorPosition(anchorPosition),\n      anchor: this.button,\n      popover: this.panel,\n      offset: !this.props.attachToAnchor && this.props.hasArrow ? 16 : 8,\n      arrowConfig: {\n        arrowWidth: 24,\n        arrowBuffer: 10\n      },\n      returnBoundingBox: this.props.attachToAnchor\n    }); // the popover's z-index must inherit from the button\n    // this keeps a button's popover under a flyout that would cover the button\n    // but a popover triggered inside a flyout will appear over that flyout\n\n    const {\n      zIndex: zIndexProp\n    } = this.props;\n    const zIndex = zIndexProp == null ? getElementZIndex(this.button, this.panel) : zIndexProp;\n    const popoverStyles = {\n      top,\n      left: this.props.attachToAnchor && anchorBoundingBox ? anchorBoundingBox.left : left,\n      zIndex\n    };\n    const willRenderArrow = !this.props.attachToAnchor && this.props.hasArrow;\n    const arrowStyles = willRenderArrow ? arrow : undefined;\n    const arrowPosition = foundPosition;\n    this.setState({\n      popoverStyles,\n      arrowStyles,\n      arrowPosition,\n      openPosition: foundPosition\n    });\n  };\n  positionPopoverFixed = () => {\n    this.positionPopover(true);\n  };\n  positionPopoverFluid = () => {\n    this.positionPopover(false);\n  };\n  panelRef = node => {\n    this.panel = node;\n    this.props.panelRef && this.props.panelRef(node);\n\n    if (node == null) {\n      // panel has unmounted, restore the state defaults\n      this.setState({\n        popoverStyles: DEFAULT_POPOVER_STYLES,\n        arrowStyles: {},\n        arrowPosition: null,\n        openPosition: null,\n        isOpenStable: false\n      });\n      window.removeEventListener('resize', this.positionPopoverFluid);\n    } else {\n      // panel is coming into existence\n      this.positionPopoverFluid();\n      window.addEventListener('resize', this.positionPopoverFluid);\n    }\n  };\n  buttonRef = node => {\n    this.button = node;\n    this.props.buttonRef && this.props.buttonRef(node);\n  };\n\n  render() {\n    const {\n      anchorClassName,\n      anchorPosition,\n      button,\n      buttonRef,\n      insert,\n      isOpen,\n      ownFocus,\n      withTitle,\n      children,\n      className,\n      closePopover,\n      panelClassName,\n      panelPaddingSize,\n      panelRef,\n      popoverRef,\n      hasArrow,\n      repositionOnScroll,\n      zIndex,\n      initialFocus,\n      attachToAnchor,\n      display,\n      ...rest\n    } = this.props;\n    const classes = classNames('euiPopover', anchorPosition ? anchorPositionToClassNameMap[anchorPosition] : null, display ? displayToClassNameMap[display] : null, {\n      'euiPopover-isOpen': this.state.isOpening,\n      'euiPopover--withTitle': withTitle\n    }, className);\n    const anchorClasses = classNames('euiPopover__anchor', anchorClassName);\n    const panelClasses = classNames('euiPopover__panel', `euiPopover__panel--${this.state.arrowPosition}`, {\n      'euiPopover__panel-isOpen': this.state.isOpening\n    }, {\n      'euiPopover__panel-withTitle': withTitle\n    }, {\n      'euiPopover__panel-noArrow': !hasArrow || attachToAnchor\n    }, {\n      'euiPopover__panel-isAttached': attachToAnchor\n    }, panelClassName);\n    let panel;\n\n    if (!this.state.suppressingPopover && (isOpen || this.state.isClosing)) {\n      let tabIndex;\n      let initialFocus;\n      let ariaLive;\n\n      if (ownFocus) {\n        tabIndex = 0;\n        ariaLive = 'off';\n\n        initialFocus = () => this.panel;\n      } else {\n        ariaLive = 'assertive';\n      }\n\n      let focusTrapScreenReaderText;\n\n      if (ownFocus) {\n        focusTrapScreenReaderText = <EuiScreenReaderOnly>\n            <p role=\"alert\">\n              <EuiI18n token=\"euiPopover.screenReaderAnnouncement\" default=\"You are in a popup. To exit this popup, hit escape.\" />\n            </p>\n          </EuiScreenReaderOnly>;\n      }\n\n      const arrowClassNames = classNames('euiPopover__panelArrow', `euiPopover__panelArrow--${this.state.arrowPosition}`);\n      panel = <EuiPortal insert={insert}>\n          <EuiFocusTrap returnFocus={!this.state.isOpening} // Ignore temporary state of indecisive focus\n        clickOutsideDisables={true} initialFocus={initialFocus} disabled={!ownFocus}>\n            {focusTrapScreenReaderText}\n            <EuiPanel panelRef={this.panelRef} className={panelClasses} paddingSize={panelPaddingSize} tabIndex={tabIndex} aria-live={ariaLive} style={this.state.popoverStyles}>\n              <div className={arrowClassNames} style={this.state.arrowStyles} />\n              <EuiMutationObserver observerOptions={{\n              attributes: true,\n              // element attribute changes\n              childList: true,\n              // added/removed elements\n              characterData: true,\n              // text changes\n              subtree: true // watch all child elements\n\n            }} onMutation={this.onMutation}>\n                {mutationRef => <div ref={mutationRef}>{children}</div>}\n              </EuiMutationObserver>\n            </EuiPanel>\n          </EuiFocusTrap>\n        </EuiPortal>;\n    }\n\n    return <EuiOutsideClickDetector isDisabled={!isOpen} onOutsideClick={closePopover}>\n        <div className={classes} onKeyDown={this.onKeyDown} ref={popoverRef} {...rest}>\n          <div className={anchorClasses} ref={this.buttonRef}>\n            {button instanceof HTMLElement ? null : button}\n          </div>\n          {panel}\n        </div>\n      </EuiOutsideClickDetector>;\n  }\n\n}\nEuiPopover.propTypes = {\n  className: _propTypes.default.string,\n  \"aria-label\": _propTypes.default.string,\n  \"data-test-subj\": _propTypes.default.string,\n  anchorClassName: PropTypes.string,\n  anchorPosition: PropTypes.oneOf([\"upCenter\", \"upLeft\", \"upRight\", \"downCenter\", \"downLeft\", \"downRight\", \"leftCenter\", \"leftUp\", \"leftDown\", \"rightCenter\", \"rightUp\", \"rightDown\"]),\n\n  /** Style and position alteration for arrow-less, left-aligned\n     * attachment. Intended for use with inputs as anchors, Ã  la\n     * EuiColorPicker */\n  attachToAnchor: PropTypes.bool,\n  button: PropTypes.any.isRequired,\n  buttonRef: PropTypes.any,\n  closePopover: PropTypes.any.isRequired,\n  container: PropTypes.any,\n\n  /** CSS display type for both the popover and anchor */\n  display: PropTypes.oneOf([\"inlineBlock\", \"block\"]),\n  hasArrow: PropTypes.bool,\n\n  /** specifies what element should initially have focus; Can be a DOM\n     * node, or a selector string (which will be passed to\n     * document.querySelector() to find the DOM node), or a function that\n     * returns a DOM node. */\n  initialFocus: PropTypes.any,\n\n  /** Passed directly to EuiPortal for DOM positioning. Both properties are\n     * required if prop is specified **/\n  insert: PropTypes.shape({\n    sibling: PropTypes.any.isRequired,\n    position: PropTypes.oneOf([\"before\", \"after\"]).isRequired\n  }),\n  isOpen: PropTypes.bool,\n  ownFocus: PropTypes.bool,\n  panelClassName: PropTypes.string,\n  panelPaddingSize: PropTypes.oneOf([\"none\", \"s\", \"m\", \"l\"]),\n  panelRef: PropTypes.any,\n  popoverRef: PropTypes.any,\n\n  /** When `true`, the popover's position is re-calculated when the user\n     * scrolls, this supports having fixed-position popover anchors. */\n  repositionOnScroll: PropTypes.bool,\n  withTitle: PropTypes.bool,\n\n  /** By default, popover content inherits the z-index of the anchor\n     * component; pass zIndex to override */\n  zIndex: PropTypes.number\n};"]}]}