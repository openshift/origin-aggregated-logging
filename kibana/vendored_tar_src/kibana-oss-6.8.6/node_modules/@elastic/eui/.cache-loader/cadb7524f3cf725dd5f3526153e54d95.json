{"remainingRequest":"/Users/chanderprall/projects/eui/node_modules/babel-loader/lib/index.js!/Users/chanderprall/projects/eui/src/components/tool_tip/tool_tip.tsx","dependencies":[{"path":"/Users/chanderprall/projects/eui/src/components/tool_tip/tool_tip.tsx","mtime":1565204170050},{"path":"/Users/chanderprall/projects/eui/.babelrc.js","mtime":1565204168946},{"path":"/Users/chanderprall/projects/eui/node_modules/cache-loader/dist/cjs.js","mtime":1555436064329},{"path":"/Users/chanderprall/projects/eui/node_modules/babel-loader/lib/index.js","mtime":1543517280769}],"contextDependencies":[],"result":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.EuiToolTip = exports.DELAY = exports.POSITIONS = void 0;\n\nrequire(\"core-js/modules/es7.symbol.async-iterator\");\n\nrequire(\"core-js/modules/es6.symbol\");\n\nrequire(\"core-js/modules/es6.object.assign\");\n\nrequire(\"core-js/modules/web.dom.iterable\");\n\nrequire(\"core-js/modules/es6.array.iterator\");\n\nrequire(\"core-js/modules/es6.object.keys\");\n\nrequire(\"core-js/modules/es6.object.set-prototype-of\");\n\nrequire(\"core-js/modules/es6.string.anchor\");\n\nvar _react = _interopRequireWildcard(require(\"react\"));\n\nvar _propTypes = _interopRequireDefault(require(\"prop-types\"));\n\nvar _classnames = _interopRequireDefault(require(\"classnames\"));\n\nvar _common = require(\"../common\");\n\nvar _portal = require(\"../portal\");\n\nvar _tool_tip_popover = require(\"./tool_tip_popover\");\n\nvar _services = require(\"../../services\");\n\nvar _make_id = _interopRequireDefault(require(\"../form/form_row/make_id\"));\n\nvar _resize_observer = require(\"../observer/resize_observer\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }\n\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nvar positionsToClassNameMap = {\n  top: 'euiToolTip--top',\n  right: 'euiToolTip--right',\n  bottom: 'euiToolTip--bottom',\n  left: 'euiToolTip--left'\n};\nvar POSITIONS = (0, _common.keysOf)(positionsToClassNameMap);\nexports.POSITIONS = POSITIONS;\nvar delayToClassNameMap = {\n  regular: null,\n  long: 'euiToolTip--delayLong'\n};\nvar DELAY = (0, _common.keysOf)(delayToClassNameMap);\nexports.DELAY = DELAY;\nvar DEFAULT_TOOLTIP_STYLES = {\n  // position the tooltip content near the top-left\n  // corner of the window so it can't create scrollbars\n  // 50,50 because who knows what negative margins, padding, etc\n  top: 50,\n  left: 50,\n  // just in case, avoid any potential flicker by hiding\n  // the tooltip before it is positioned\n  opacity: 0\n};\n\nvar EuiToolTip =\n/*#__PURE__*/\nfunction (_Component) {\n  _inherits(EuiToolTip, _Component);\n\n  function EuiToolTip() {\n    var _getPrototypeOf2;\n\n    var _this;\n\n    _classCallCheck(this, EuiToolTip);\n\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    _this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(EuiToolTip)).call.apply(_getPrototypeOf2, [this].concat(args)));\n\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"_isMounted\", false);\n\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"anchor\", null);\n\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"popover\", null);\n\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"state\", {\n      visible: false,\n      hasFocus: false,\n      calculatedPosition: _this.props.position,\n      toolTipStyles: DEFAULT_TOOLTIP_STYLES,\n      arrowStyles: undefined,\n      id: _this.props.id || (0, _make_id.default)()\n    });\n\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"testAnchor\", function () {\n      // when the tooltip is visible, this checks if the anchor is still part of document\n      // this fixes when the react root is removed from the dom without unmounting\n      // https://github.com/elastic/eui/issues/1105\n      if (document.body.contains(_this.anchor) === false) {\n        // the anchor is no longer part of `document`\n        _this.hideToolTip();\n      } else {\n        if (_this.state.visible) {\n          // if still visible, keep checking\n          requestAnimationFrame(_this.testAnchor);\n        }\n      }\n    });\n\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"setPopoverRef\", function (ref) {\n      _this.popover = ref; // if the popover has been unmounted, clear\n      // any previous knowledge about its size\n\n      if (ref == null) {\n        _this.setState({\n          toolTipStyles: DEFAULT_TOOLTIP_STYLES,\n          arrowStyles: undefined\n        });\n      }\n    });\n\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"showToolTip\", function () {\n      _this.setState({\n        visible: true\n      });\n    });\n\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"positionToolTip\", function () {\n      var requestedPosition = _this.props.position;\n\n      if (!_this.anchor || !_this.popover) {\n        return;\n      }\n\n      var _findPopoverPosition = (0, _services.findPopoverPosition)({\n        anchor: _this.anchor,\n        popover: _this.popover,\n        position: requestedPosition,\n        offset: 16,\n        // offset popover 16px from the anchor\n        arrowConfig: {\n          arrowWidth: 12,\n          arrowBuffer: 4\n        }\n      }),\n          position = _findPopoverPosition.position,\n          left = _findPopoverPosition.left,\n          top = _findPopoverPosition.top,\n          arrow = _findPopoverPosition.arrow; // If encroaching the right edge of the window:\n      // When `props.content` changes and is longer than `prevProps.content`, the tooltip width remains and\n      // the resizeObserver callback will fire twice (once for vertical resize caused by text line wrapping,\n      // once for a subsequent position correction) and cause a flash rerender and reposition.\n      // To prevent this, we can orient from the right so that text line wrapping does not occur, negating\n      // the second resizeObserver callback call.\n\n\n      var windowWidth = document.documentElement.clientWidth || window.innerWidth;\n      var useRightValue = windowWidth / 2 < left;\n      var toolTipStyles = {\n        top: top,\n        left: useRightValue ? 'auto' : left,\n        right: useRightValue ? windowWidth - left - _this.popover.offsetWidth : 'auto'\n      };\n\n      _this.setState({\n        visible: true,\n        calculatedPosition: position,\n        toolTipStyles: toolTipStyles,\n        arrowStyles: arrow\n      });\n    });\n\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"hideToolTip\", function () {\n      if (_this._isMounted) {\n        _this.setState({\n          visible: false\n        });\n      }\n    });\n\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"onFocus\", function () {\n      _this.setState({\n        hasFocus: true\n      });\n\n      _this.showToolTip();\n    });\n\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"onBlur\", function () {\n      _this.setState({\n        hasFocus: false\n      });\n\n      _this.hideToolTip();\n    });\n\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"onMouseOut\", function (e) {\n      // Prevent mousing over children from hiding the tooltip by testing for whether the mouse has\n      // left the anchor for a non-child.\n      if (_this.anchor === e.relatedTarget || _this.anchor != null && !_this.anchor.contains(e.relatedTarget)) {\n        if (!_this.state.hasFocus) {\n          _this.hideToolTip();\n        }\n      }\n\n      if (_this.props.onMouseOut) {\n        _this.props.onMouseOut(e);\n      }\n    });\n\n    return _this;\n  }\n\n  _createClass(EuiToolTip, [{\n    key: \"componentDidMount\",\n    value: function componentDidMount() {\n      this._isMounted = true;\n    }\n  }, {\n    key: \"componentWillUnmount\",\n    value: function componentWillUnmount() {\n      this._isMounted = false;\n    }\n  }, {\n    key: \"componentDidUpdate\",\n    value: function componentDidUpdate(prevProps, prevState) {\n      if (prevState.visible === false && this.state.visible === true) {\n        requestAnimationFrame(this.testAnchor);\n      }\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      var _this2 = this;\n\n      var _this$props = this.props,\n          children = _this$props.children,\n          className = _this$props.className,\n          anchorClassName = _this$props.anchorClassName,\n          content = _this$props.content,\n          title = _this$props.title,\n          delay = _this$props.delay,\n          rest = _objectWithoutProperties(_this$props, [\"children\", \"className\", \"anchorClassName\", \"content\", \"title\", \"delay\"]);\n\n      var _this$state = this.state,\n          arrowStyles = _this$state.arrowStyles,\n          id = _this$state.id,\n          toolTipStyles = _this$state.toolTipStyles,\n          visible = _this$state.visible;\n      var classes = (0, _classnames.default)('euiToolTip', positionsToClassNameMap[this.state.calculatedPosition], delayToClassNameMap[delay], className);\n      var anchorClasses = (0, _classnames.default)('euiToolTipAnchor', anchorClassName);\n      var tooltip;\n\n      if (visible && (content || title)) {\n        tooltip = _react.default.createElement(_portal.EuiPortal, null, _react.default.createElement(_tool_tip_popover.EuiToolTipPopover, _extends({\n          className: classes,\n          style: toolTipStyles,\n          positionToolTip: this.positionToolTip,\n          popoverRef: this.setPopoverRef,\n          title: title,\n          id: id,\n          role: \"tooltip\"\n        }, rest), _react.default.createElement(\"div\", {\n          style: arrowStyles,\n          className: \"euiToolTip__arrow\"\n        }), _react.default.createElement(_resize_observer.EuiResizeObserver, {\n          onResize: this.positionToolTip\n        }, function (resizeRef) {\n          return _react.default.createElement(\"div\", {\n            ref: resizeRef\n          }, content);\n        })));\n      }\n\n      var anchor = // eslint-disable-next-line jsx-a11y/mouse-events-have-key-events\n      _react.default.createElement(\"span\", {\n        ref: function ref(anchor) {\n          return _this2.anchor = anchor;\n        },\n        className: anchorClasses,\n        onMouseOver: this.showToolTip,\n        onMouseOut: this.onMouseOut\n      }, (0, _react.cloneElement)(children, _objectSpread({\n        onFocus: this.showToolTip,\n        onBlur: this.hideToolTip\n      }, visible && {\n        'aria-describedby': this.state.id\n      })));\n\n      return _react.default.createElement(_react.Fragment, null, anchor, tooltip);\n    }\n  }]);\n\n  return EuiToolTip;\n}(_react.Component);\n\nexports.EuiToolTip = EuiToolTip;\n\n_defineProperty(EuiToolTip, \"defaultProps\", {\n  position: 'top',\n  delay: 'regular'\n});\n\nEuiToolTip.propTypes = {\n  /**\n     * Passes onto the the trigger.\n     */\n  anchorClassName: _propTypes.default.string,\n\n  /**\n     * The in-view trigger for your tooltip.\n     */\n  children: _propTypes.default.element.isRequired,\n\n  /**\n     * Passes onto the tooltip itself, not the trigger.\n     */\n  className: _propTypes.default.string,\n\n  /**\n     * The main content of your tooltip.\n     */\n  content: _propTypes.default.node,\n\n  /**\n     * Delay before showing tooltip. Good for repeatable items.\n     */\n  delay: _propTypes.default.oneOf([\"regular\", \"long\"]).isRequired,\n\n  /**\n     * An optional title for your tooltip.\n     */\n  title: _propTypes.default.node,\n\n  /**\n     * Unless you provide one, this will be randomly generated.\n     */\n  id: _propTypes.default.string,\n\n  /**\n     * Suggested position. If there is not enough room for it this will be changed.\n     */\n  position: _propTypes.default.oneOf([\"top\", \"right\", \"bottom\", \"left\"]).isRequired,\n\n  /**\n     * If supplied, called when mouse movement causes the tool tip to be\n     * hidden.\n     */\n  onMouseOut: _propTypes.default.func\n};\nEuiToolTip.__docgenInfo = {\n  \"description\": \"\",\n  \"methods\": [{\n    \"name\": \"testAnchor\",\n    \"docblock\": null,\n    \"modifiers\": [],\n    \"params\": [],\n    \"returns\": null\n  }, {\n    \"name\": \"setPopoverRef\",\n    \"docblock\": null,\n    \"modifiers\": [],\n    \"params\": [{\n      \"name\": \"ref\",\n      \"type\": null\n    }],\n    \"returns\": null\n  }, {\n    \"name\": \"showToolTip\",\n    \"docblock\": null,\n    \"modifiers\": [],\n    \"params\": [],\n    \"returns\": null\n  }, {\n    \"name\": \"positionToolTip\",\n    \"docblock\": null,\n    \"modifiers\": [],\n    \"params\": [],\n    \"returns\": null\n  }, {\n    \"name\": \"hideToolTip\",\n    \"docblock\": null,\n    \"modifiers\": [],\n    \"params\": [],\n    \"returns\": null\n  }, {\n    \"name\": \"onFocus\",\n    \"docblock\": null,\n    \"modifiers\": [],\n    \"params\": [],\n    \"returns\": null\n  }, {\n    \"name\": \"onBlur\",\n    \"docblock\": null,\n    \"modifiers\": [],\n    \"params\": [],\n    \"returns\": null\n  }, {\n    \"name\": \"onMouseOut\",\n    \"docblock\": null,\n    \"modifiers\": [],\n    \"params\": [{\n      \"name\": \"e\",\n      \"type\": null\n    }],\n    \"returns\": null\n  }],\n  \"displayName\": \"EuiToolTip\",\n  \"props\": {\n    \"position\": {\n      \"defaultValue\": {\n        \"value\": \"'top'\",\n        \"computed\": false\n      },\n      \"type\": {\n        \"name\": \"enum\",\n        \"value\": [{\n          \"value\": \"\\\"top\\\"\",\n          \"computed\": false\n        }, {\n          \"value\": \"\\\"right\\\"\",\n          \"computed\": false\n        }, {\n          \"value\": \"\\\"bottom\\\"\",\n          \"computed\": false\n        }, {\n          \"value\": \"\\\"left\\\"\",\n          \"computed\": false\n        }]\n      },\n      \"required\": false,\n      \"description\": \"Suggested position. If there is not enough room for it this will be changed.\"\n    },\n    \"delay\": {\n      \"defaultValue\": {\n        \"value\": \"'regular'\",\n        \"computed\": false\n      },\n      \"type\": {\n        \"name\": \"enum\",\n        \"value\": [{\n          \"value\": \"\\\"regular\\\"\",\n          \"computed\": false\n        }, {\n          \"value\": \"\\\"long\\\"\",\n          \"computed\": false\n        }]\n      },\n      \"required\": false,\n      \"description\": \"Delay before showing tooltip. Good for repeatable items.\"\n    },\n    \"anchorClassName\": {\n      \"type\": {\n        \"name\": \"string\"\n      },\n      \"required\": false,\n      \"description\": \"Passes onto the the trigger.\"\n    },\n    \"children\": {\n      \"type\": {\n        \"name\": \"element\"\n      },\n      \"required\": true,\n      \"description\": \"The in-view trigger for your tooltip.\"\n    },\n    \"className\": {\n      \"type\": {\n        \"name\": \"string\"\n      },\n      \"required\": false,\n      \"description\": \"Passes onto the tooltip itself, not the trigger.\"\n    },\n    \"content\": {\n      \"type\": {\n        \"name\": \"node\"\n      },\n      \"required\": false,\n      \"description\": \"The main content of your tooltip.\"\n    },\n    \"title\": {\n      \"type\": {\n        \"name\": \"node\"\n      },\n      \"required\": false,\n      \"description\": \"An optional title for your tooltip.\"\n    },\n    \"id\": {\n      \"type\": {\n        \"name\": \"string\"\n      },\n      \"required\": false,\n      \"description\": \"Unless you provide one, this will be randomly generated.\"\n    },\n    \"onMouseOut\": {\n      \"type\": {\n        \"name\": \"func\"\n      },\n      \"required\": false,\n      \"description\": \"If supplied, called when mouse movement causes the tool tip to be\\nhidden.\"\n    }\n  }\n};",{"version":3,"sources":["/Users/chanderprall/projects/eui/src/components/tool_tip/tool_tip.tsx"],"names":["positionsToClassNameMap","top","right","bottom","left","POSITIONS","delayToClassNameMap","regular","long","DELAY","DEFAULT_TOOLTIP_STYLES","opacity","EuiToolTip","visible","hasFocus","calculatedPosition","props","position","toolTipStyles","arrowStyles","undefined","id","document","body","contains","anchor","hideToolTip","state","requestAnimationFrame","testAnchor","ref","popover","setState","requestedPosition","offset","arrowConfig","arrowWidth","arrowBuffer","arrow","windowWidth","documentElement","clientWidth","window","innerWidth","useRightValue","offsetWidth","_isMounted","showToolTip","e","relatedTarget","onMouseOut","prevProps","prevState","children","className","anchorClassName","content","title","delay","rest","classes","anchorClasses","tooltip","positionToolTip","setPopoverRef","resizeRef","onFocus","onBlur","Component"],"mappings":"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","sourcesContent":["import React, { Component, cloneElement, Fragment } from 'react';\nimport PropTypes from \"prop-types\";\nimport classNames from 'classnames';\nimport { keysOf } from '../common';\nimport { EuiPortal } from '../portal';\nimport { EuiToolTipPopover } from './tool_tip_popover';\nimport { findPopoverPosition } from '../../services';\nimport makeId from '../form/form_row/make_id';\nimport { EuiResizeObserver } from '../observer/resize_observer';\nvar positionsToClassNameMap = {\n  top: 'euiToolTip--top',\n  right: 'euiToolTip--right',\n  bottom: 'euiToolTip--bottom',\n  left: 'euiToolTip--left'\n};\nexport var POSITIONS = keysOf(positionsToClassNameMap);\nvar delayToClassNameMap = {\n  regular: null,\n  long: 'euiToolTip--delayLong'\n};\nexport var DELAY = keysOf(delayToClassNameMap);\nvar DEFAULT_TOOLTIP_STYLES = {\n  // position the tooltip content near the top-left\n  // corner of the window so it can't create scrollbars\n  // 50,50 because who knows what negative margins, padding, etc\n  top: 50,\n  left: 50,\n  // just in case, avoid any potential flicker by hiding\n  // the tooltip before it is positioned\n  opacity: 0\n};\nexport class EuiToolTip extends Component {\n  _isMounted = false;\n  anchor = null;\n  popover = null;\n  state = {\n    visible: false,\n    hasFocus: false,\n    calculatedPosition: this.props.position,\n    toolTipStyles: DEFAULT_TOOLTIP_STYLES,\n    arrowStyles: undefined,\n    id: this.props.id || makeId()\n  };\n  static defaultProps = {\n    position: 'top',\n    delay: 'regular'\n  };\n\n  componentDidMount() {\n    this._isMounted = true;\n  }\n\n  componentWillUnmount() {\n    this._isMounted = false;\n  }\n\n  componentDidUpdate(prevProps, prevState) {\n    if (prevState.visible === false && this.state.visible === true) {\n      requestAnimationFrame(this.testAnchor);\n    }\n  }\n\n  testAnchor = () => {\n    // when the tooltip is visible, this checks if the anchor is still part of document\n    // this fixes when the react root is removed from the dom without unmounting\n    // https://github.com/elastic/eui/issues/1105\n    if (document.body.contains(this.anchor) === false) {\n      // the anchor is no longer part of `document`\n      this.hideToolTip();\n    } else {\n      if (this.state.visible) {\n        // if still visible, keep checking\n        requestAnimationFrame(this.testAnchor);\n      }\n    }\n  };\n  setPopoverRef = ref => {\n    this.popover = ref; // if the popover has been unmounted, clear\n    // any previous knowledge about its size\n\n    if (ref == null) {\n      this.setState({\n        toolTipStyles: DEFAULT_TOOLTIP_STYLES,\n        arrowStyles: undefined\n      });\n    }\n  };\n  showToolTip = () => {\n    this.setState({\n      visible: true\n    });\n  };\n  positionToolTip = () => {\n    const requestedPosition = this.props.position;\n\n    if (!this.anchor || !this.popover) {\n      return;\n    }\n\n    const {\n      position,\n      left,\n      top,\n      arrow\n    } = findPopoverPosition({\n      anchor: this.anchor,\n      popover: this.popover,\n      position: requestedPosition,\n      offset: 16,\n      // offset popover 16px from the anchor\n      arrowConfig: {\n        arrowWidth: 12,\n        arrowBuffer: 4\n      }\n    }); // If encroaching the right edge of the window:\n    // When `props.content` changes and is longer than `prevProps.content`, the tooltip width remains and\n    // the resizeObserver callback will fire twice (once for vertical resize caused by text line wrapping,\n    // once for a subsequent position correction) and cause a flash rerender and reposition.\n    // To prevent this, we can orient from the right so that text line wrapping does not occur, negating\n    // the second resizeObserver callback call.\n\n    const windowWidth = document.documentElement.clientWidth || window.innerWidth;\n    const useRightValue = windowWidth / 2 < left;\n    const toolTipStyles = {\n      top,\n      left: useRightValue ? 'auto' : left,\n      right: useRightValue ? windowWidth - left - this.popover.offsetWidth : 'auto'\n    };\n    this.setState({\n      visible: true,\n      calculatedPosition: position,\n      toolTipStyles,\n      arrowStyles: arrow\n    });\n  };\n  hideToolTip = () => {\n    if (this._isMounted) {\n      this.setState({\n        visible: false\n      });\n    }\n  };\n  onFocus = () => {\n    this.setState({\n      hasFocus: true\n    });\n    this.showToolTip();\n  };\n  onBlur = () => {\n    this.setState({\n      hasFocus: false\n    });\n    this.hideToolTip();\n  };\n  onMouseOut = e => {\n    // Prevent mousing over children from hiding the tooltip by testing for whether the mouse has\n    // left the anchor for a non-child.\n    if (this.anchor === e.relatedTarget || this.anchor != null && !this.anchor.contains(e.relatedTarget)) {\n      if (!this.state.hasFocus) {\n        this.hideToolTip();\n      }\n    }\n\n    if (this.props.onMouseOut) {\n      this.props.onMouseOut(e);\n    }\n  };\n\n  render() {\n    const {\n      children,\n      className,\n      anchorClassName,\n      content,\n      title,\n      delay,\n      ...rest\n    } = this.props;\n    const {\n      arrowStyles,\n      id,\n      toolTipStyles,\n      visible\n    } = this.state;\n    const classes = classNames('euiToolTip', positionsToClassNameMap[this.state.calculatedPosition], delayToClassNameMap[delay], className);\n    const anchorClasses = classNames('euiToolTipAnchor', anchorClassName);\n    let tooltip;\n\n    if (visible && (content || title)) {\n      tooltip = <EuiPortal>\n          <EuiToolTipPopover className={classes} style={toolTipStyles} positionToolTip={this.positionToolTip} popoverRef={this.setPopoverRef} title={title} id={id} role=\"tooltip\" {...rest}>\n            <div style={arrowStyles} className=\"euiToolTip__arrow\" />\n            <EuiResizeObserver onResize={this.positionToolTip}>\n              {resizeRef => <div ref={resizeRef}>{content}</div>}\n            </EuiResizeObserver>\n          </EuiToolTipPopover>\n        </EuiPortal>;\n    }\n\n    const anchor = // eslint-disable-next-line jsx-a11y/mouse-events-have-key-events\n    <span ref={anchor => this.anchor = anchor} className={anchorClasses} onMouseOver={this.showToolTip} onMouseOut={this.onMouseOut}>\n        {\n        /**\n        * Re: jsx-a11y/mouse-events-have-key-events\n        * We apply onFocus, onBlur, etc to the children element because that's the element\n        * the user will be interacting with, as opposed to the enclosing anchor element.\n        * For example, if the inner component is a button and the user tabs to it, we want\n        * the enter key to trigger the button. That won't work if the enclosing anchor\n        * element has focus.\n        */\n      }\n        {cloneElement(children, {\n        onFocus: this.showToolTip,\n        onBlur: this.hideToolTip,\n        ...(visible && {\n          'aria-describedby': this.state.id\n        })\n      })}\n      </span>;\n    return <Fragment>\n        {anchor}\n        {tooltip}\n      </Fragment>;\n  }\n\n}\nEuiToolTip.propTypes = {\n  /**\n     * Passes onto the the trigger.\n     */\n  anchorClassName: PropTypes.string,\n\n  /**\n     * The in-view trigger for your tooltip.\n     */\n  children: PropTypes.element.isRequired,\n\n  /**\n     * Passes onto the tooltip itself, not the trigger.\n     */\n  className: PropTypes.string,\n\n  /**\n     * The main content of your tooltip.\n     */\n  content: PropTypes.node,\n\n  /**\n     * Delay before showing tooltip. Good for repeatable items.\n     */\n  delay: PropTypes.oneOf([\"regular\", \"long\"]).isRequired,\n\n  /**\n     * An optional title for your tooltip.\n     */\n  title: PropTypes.node,\n\n  /**\n     * Unless you provide one, this will be randomly generated.\n     */\n  id: PropTypes.string,\n\n  /**\n     * Suggested position. If there is not enough room for it this will be changed.\n     */\n  position: PropTypes.oneOf([\"top\", \"right\", \"bottom\", \"left\"]).isRequired,\n\n  /**\n     * If supplied, called when mouse movement causes the tool tip to be\n     * hidden.\n     */\n  onMouseOut: PropTypes.func\n};"]}]}