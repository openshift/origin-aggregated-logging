{"remainingRequest":"/Users/chanderprall/projects/eui/node_modules/babel-loader/lib/index.js!/Users/chanderprall/projects/eui/src/components/i18n/i18n.tsx","dependencies":[{"path":"/Users/chanderprall/projects/eui/src/components/i18n/i18n.tsx","mtime":1567693556083},{"path":"/Users/chanderprall/projects/eui/.babelrc.js","mtime":1565204168946},{"path":"/Users/chanderprall/projects/eui/node_modules/cache-loader/dist/cjs.js","mtime":1555436064329},{"path":"/Users/chanderprall/projects/eui/node_modules/babel-loader/lib/index.js","mtime":1543517280769}],"contextDependencies":[],"result":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.EuiI18n = void 0;\n\nrequire(\"core-js/modules/web.dom.iterable\");\n\nrequire(\"core-js/modules/es6.array.iterator\");\n\nvar _react = _interopRequireWildcard(require(\"react\"));\n\nvar _context = require(\"../context\");\n\nvar _i18n_util = require(\"./i18n_util\");\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }\n\nfunction errorOnMissingValues(token) {\n  throw new Error(\"I18n mapping for token \\\"\".concat(token, \"\\\" is a formatting function but no values were provided.\"));\n}\n\nfunction lookupToken(token, i18nMapping, valueDefault, i18nMappingFunc, values) {\n  var renderable = i18nMapping && i18nMapping[token] || valueDefault;\n\n  if (typeof renderable === 'function') {\n    if (values === undefined) {\n      return errorOnMissingValues(token);\n    } else {\n      // @ts-ignore-next-line\n      // TypeScript complains that `DEFAULT` doesn't have a call signature\n      // but we verified `renderable` is a function\n      return renderable(values);\n    }\n  } else if (values === undefined || typeof renderable !== 'string') {\n    if (i18nMappingFunc && typeof valueDefault === 'string') {\n      renderable = i18nMappingFunc(valueDefault);\n    } // there's a hole in the typings here as there is no guarantee that i18nMappingFunc\n    // returned the same type of the default value, but we need to keep that assumption\n\n\n    return renderable;\n  }\n\n  var children = (0, _i18n_util.processStringToChildren)(renderable, values, i18nMappingFunc);\n\n  if (typeof children === 'string') {\n    // likewise, `processStringToChildren` returns a string or ReactChild[] depending on\n    // the type of `values`, so we will make the assumption that the default value is correct.\n    return children;\n  }\n\n  var Component = function Component() {\n    return _react.default.createElement(_react.Fragment, null, children);\n  }; // same reasons as above, we can't promise the transforms match the default's type\n\n\n  return _react.default.createElement(Component, values);\n}\n\nfunction hasTokens(x) {\n  return x.tokens != null;\n} // Must use the generics <T extends {}>\n// If instead typed with React.FunctionComponent there isn't feedback given back to the dev\n// when using a `values` object with a renderer callback.\n\n\nvar EuiI18n = function EuiI18n(props) {\n  return _react.default.createElement(_context.EuiI18nConsumer, null, function (i18nConfig) {\n    var mapping = i18nConfig.mapping,\n        mappingFunc = i18nConfig.mappingFunc;\n\n    if (hasTokens(props)) {\n      return props.children(props.tokens.map(function (token, idx) {\n        return lookupToken(token, mapping, props.defaults[idx], mappingFunc);\n      }));\n    }\n\n    var tokenValue = lookupToken(props.token, mapping, props.default, mappingFunc, props.values);\n\n    if (props.children) {\n      return props.children(tokenValue);\n    } else {\n      return tokenValue;\n    }\n  });\n};\n\nexports.EuiI18n = EuiI18n;\nEuiI18n.__docgenInfo = {\n  \"description\": \"\",\n  \"methods\": [],\n  \"displayName\": \"EuiI18n\"\n};",{"version":3,"sources":["/Users/chanderprall/projects/eui/src/components/i18n/i18n.tsx"],"names":["errorOnMissingValues","token","Error","lookupToken","i18nMapping","valueDefault","i18nMappingFunc","values","renderable","undefined","children","Component","React","createElement","hasTokens","x","tokens","EuiI18n","props","i18nConfig","mapping","mappingFunc","map","idx","defaults","tokenValue","default"],"mappings":";;;;;;;;;;;AAAA;;AACA;;AAGA;;;;AAEA,SAASA,oBAAT,CAA8BC,KAA9B,EAAoD;AAClD,QAAM,IAAIC,KAAJ,oCACuBD,KADvB,8DAAN;AAGD;;AAED,SAASE,WAAT,CAKEF,KALF,EAMEG,WANF,EAOEC,YAPF,EAQEC,eARF,EASEC,MATF,EAUY;AACV,MAAIC,UAAU,GAAIJ,WAAW,IAAIA,WAAW,CAACH,KAAD,CAA3B,IAAuCI,YAAxD;;AAEA,MAAI,OAAOG,UAAP,KAAsB,UAA1B,EAAsC;AACpC,QAAID,MAAM,KAAKE,SAAf,EAA0B;AACxB,aAAOT,oBAAoB,CAACC,KAAD,CAA3B;AACD,KAFD,MAEO;AACL;AACA;AACA;AACA,aAAOO,UAAU,CAACD,MAAD,CAAjB;AACD;AACF,GATD,MASO,IAAIA,MAAM,KAAKE,SAAX,IAAwB,OAAOD,UAAP,KAAsB,QAAlD,EAA4D;AACjE,QAAIF,eAAe,IAAI,OAAOD,YAAP,KAAwB,QAA/C,EAAyD;AACvDG,MAAAA,UAAU,GAAGF,eAAe,CAACD,YAAD,CAA5B;AACD,KAHgE,CAIjE;AACA;;;AACA,WAAOG,UAAP;AACD;;AAED,MAAME,QAAQ,GAAG,wCAAwBF,UAAxB,EAAoCD,MAApC,EAA4CD,eAA5C,CAAjB;;AACA,MAAI,OAAOI,QAAP,KAAoB,QAAxB,EAAkC;AAChC;AACA;AACA,WAAOA,QAAP;AACD;;AAED,MAAMC,SAAiC,GAAG,SAApCA,SAAoC,GAAM;AAC9C,WAAO,6BAAC,eAAD,QAAWD,QAAX,CAAP;AACD,GAFD,CA5BU,CAgCV;;;AACA,SAAOE,eAAMC,aAAN,CAAoBF,SAApB,EAA+BJ,MAA/B,CAAP;AACD;;AAsBD,SAASO,SAAT,CAAmBC,CAAnB,EAAoE;AAClE,SAAOA,CAAC,CAACC,MAAF,IAAY,IAAnB;AACD,C,CAED;AACA;AACA;;;AACA,IAAMC,OAAO,GAAI,SAAXA,OAAW,CACfC,KADe;AAAA,SAGf,6BAAC,wBAAD,QACG,UAAAC,UAAU,EAAI;AAAA,QACLC,OADK,GACoBD,UADpB,CACLC,OADK;AAAA,QACIC,WADJ,GACoBF,UADpB,CACIE,WADJ;;AAEb,QAAIP,SAAS,CAACI,KAAD,CAAb,EAAsB;AACpB,aAAOA,KAAK,CAACR,QAAN,CACLQ,KAAK,CAACF,MAAN,CAAaM,GAAb,CAAiB,UAACrB,KAAD,EAAQsB,GAAR;AAAA,eACfpB,WAAW,CAACF,KAAD,EAAQmB,OAAR,EAAiBF,KAAK,CAACM,QAAN,CAAeD,GAAf,CAAjB,EAAsCF,WAAtC,CADI;AAAA,OAAjB,CADK,CAAP;AAKD;;AAED,QAAMI,UAAU,GAAGtB,WAAW,CAC5Be,KAAK,CAACjB,KADsB,EAE5BmB,OAF4B,EAG5BF,KAAK,CAACQ,OAHsB,EAI5BL,WAJ4B,EAK5BH,KAAK,CAACX,MALsB,CAA9B;;AAOA,QAAIW,KAAK,CAACR,QAAV,EAAoB;AAClB,aAAOQ,KAAK,CAACR,QAAN,CAAee,UAAf,CAAP;AACD,KAFD,MAEO;AACL,aAAOA,UAAP;AACD;AACF,GAvBH,CAHe;AAAA,CAAjB","sourcesContent":["import React, { Fragment } from 'react';\nimport { EuiI18nConsumer } from '../context';\nimport { processStringToChildren } from './i18n_util';\n\nfunction errorOnMissingValues(token) {\n  throw new Error(\"I18n mapping for token \\\"\".concat(token, \"\\\" is a formatting function but no values were provided.\"));\n}\n\nfunction lookupToken(token, i18nMapping, valueDefault, i18nMappingFunc, values) {\n  var renderable = i18nMapping && i18nMapping[token] || valueDefault;\n\n  if (typeof renderable === 'function') {\n    if (values === undefined) {\n      return errorOnMissingValues(token);\n    } else {\n      // @ts-ignore-next-line\n      // TypeScript complains that `DEFAULT` doesn't have a call signature\n      // but we verified `renderable` is a function\n      return renderable(values);\n    }\n  } else if (values === undefined || typeof renderable !== 'string') {\n    if (i18nMappingFunc && typeof valueDefault === 'string') {\n      renderable = i18nMappingFunc(valueDefault);\n    } // there's a hole in the typings here as there is no guarantee that i18nMappingFunc\n    // returned the same type of the default value, but we need to keep that assumption\n\n\n    return renderable;\n  }\n\n  var children = processStringToChildren(renderable, values, i18nMappingFunc);\n\n  if (typeof children === 'string') {\n    // likewise, `processStringToChildren` returns a string or ReactChild[] depending on\n    // the type of `values`, so we will make the assumption that the default value is correct.\n    return children;\n  }\n\n  var Component = () => {\n    return <Fragment>{children}</Fragment>;\n  }; // same reasons as above, we can't promise the transforms match the default's type\n\n\n  return React.createElement(Component, values);\n}\n\nfunction hasTokens(x) {\n  return x.tokens != null;\n} // Must use the generics <T extends {}>\n// If instead typed with React.FunctionComponent there isn't feedback given back to the dev\n// when using a `values` object with a renderer callback.\n\n\nvar EuiI18n = props => <EuiI18nConsumer>\n    {i18nConfig => {\n    const {\n      mapping,\n      mappingFunc\n    } = i18nConfig;\n\n    if (hasTokens(props)) {\n      return props.children(props.tokens.map((token, idx) => lookupToken(token, mapping, props.defaults[idx], mappingFunc)));\n    }\n\n    const tokenValue = lookupToken(props.token, mapping, props.default, mappingFunc, props.values);\n\n    if (props.children) {\n      return props.children(tokenValue);\n    } else {\n      return tokenValue;\n    }\n  }}\n  </EuiI18nConsumer>;\n\nexport { EuiI18n };"]}]}