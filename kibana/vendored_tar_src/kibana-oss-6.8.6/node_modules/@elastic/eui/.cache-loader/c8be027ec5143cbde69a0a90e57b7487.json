{"remainingRequest":"/Users/chanderprall/projects/eui/node_modules/babel-loader/lib/index.js!/Users/chanderprall/projects/eui/src/components/search_bar/query/query.js","dependencies":[{"path":"/Users/chanderprall/projects/eui/src/components/search_bar/query/query.js","mtime":1565204169991},{"path":"/Users/chanderprall/projects/eui/.babelrc.js","mtime":1565204168946},{"path":"/Users/chanderprall/projects/eui/node_modules/cache-loader/dist/cjs.js","mtime":1555436064329},{"path":"/Users/chanderprall/projects/eui/node_modules/babel-loader/lib/index.js","mtime":1543517280769}],"contextDependencies":[],"result":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Query = void 0;\n\nvar _default_syntax = require(\"./default_syntax\");\n\nvar _execute_ast = require(\"./execute_ast\");\n\nvar _predicate = require(\"../../../services/predicate\");\n\nvar _ast_to_es_query_dsl = require(\"./ast_to_es_query_dsl\");\n\nvar _ast_to_es_query_string = require(\"./ast_to_es_query_string\");\n\nvar _date_value = require(\"./date_value\");\n\nvar _ast = require(\"./ast\");\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n/**\n * This is the consumer interface for the query - it's effectively a wrapper construct around\n * the AST and some of its related utility functions (e.g. parsing, text representation, executing, etc...)\n * It is immutable - all mutating operations return a new (mutated) query instance.\n */\nvar Query =\n/*#__PURE__*/\nfunction () {\n  _createClass(Query, null, [{\n    key: \"parse\",\n    value: function parse(text, options) {\n      var syntax = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : _default_syntax.defaultSyntax;\n      return new Query(syntax.parse(text, options), syntax, text);\n    }\n  }, {\n    key: \"parseDateValue\",\n    value: function parseDateValue(value) {\n      var format = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;\n      return (0, _date_value.dateValueParser)(format)(value);\n    }\n  }, {\n    key: \"isMust\",\n    value: function isMust(clause) {\n      return _ast.AST.Match.isMustClause(clause);\n    }\n  }, {\n    key: \"isTerm\",\n    value: function isTerm(clause) {\n      return _ast.AST.Term.isInstance(clause);\n    }\n  }, {\n    key: \"isIs\",\n    value: function isIs(clause) {\n      return _ast.AST.Is.isInstance(clause);\n    }\n  }, {\n    key: \"isField\",\n    value: function isField(clause) {\n      return _ast.AST.Field.isInstance(clause);\n    }\n  }]);\n\n  function Query(ast) {\n    var syntax = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _default_syntax.defaultSyntax;\n    var text = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : undefined;\n\n    _classCallCheck(this, Query);\n\n    this.ast = ast;\n    this.text = text || syntax.print(ast);\n    this.syntax = syntax;\n  }\n\n  _createClass(Query, [{\n    key: \"hasSimpleFieldClause\",\n    value: function hasSimpleFieldClause(field) {\n      var value = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;\n      return this.ast.hasSimpleFieldClause(field, value);\n    }\n  }, {\n    key: \"getSimpleFieldClause\",\n    value: function getSimpleFieldClause(field, value) {\n      return this.ast.getSimpleFieldClause(field, value);\n    }\n  }, {\n    key: \"removeSimpleFieldClauses\",\n    value: function removeSimpleFieldClauses(field) {\n      var ast = this.ast.removeSimpleFieldClauses(field);\n      return new Query(ast, this.syntax);\n    }\n  }, {\n    key: \"addSimpleFieldValue\",\n    value: function addSimpleFieldValue(field, value) {\n      var must = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n      var operator = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : _ast.Operator.EQ;\n      var ast = this.ast.addSimpleFieldValue(field, value, must, operator);\n      return new Query(ast, this.syntax);\n    }\n  }, {\n    key: \"removeSimpleFieldValue\",\n    value: function removeSimpleFieldValue(field, value) {\n      var ast = this.ast.removeSimpleFieldValue(field, value);\n      return new Query(ast, this.syntax);\n    }\n  }, {\n    key: \"hasOrFieldClause\",\n    value: function hasOrFieldClause(field) {\n      var value = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;\n      return this.ast.hasOrFieldClause(field, value);\n    }\n  }, {\n    key: \"getOrFieldClause\",\n    value: function getOrFieldClause(field, value) {\n      return this.ast.getOrFieldClause(field, value);\n    }\n  }, {\n    key: \"addOrFieldValue\",\n    value: function addOrFieldValue(field, value) {\n      var must = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n      var ast = this.ast.addOrFieldValue(field, value, must);\n      return new Query(ast, this.syntax);\n    }\n  }, {\n    key: \"removeOrFieldValue\",\n    value: function removeOrFieldValue(field, value) {\n      var ast = this.ast.removeOrFieldValue(field, value);\n      return new Query(ast, this.syntax);\n    }\n  }, {\n    key: \"removeOrFieldClauses\",\n    value: function removeOrFieldClauses(field) {\n      var ast = this.ast.removeOrFieldClauses(field);\n      return new Query(ast, this.syntax);\n    }\n  }, {\n    key: \"hasIsClause\",\n    value: function hasIsClause(flag) {\n      return !(0, _predicate.isNil)(this.ast.getIsClause(flag));\n    }\n  }, {\n    key: \"getIsClause\",\n    value: function getIsClause(flag) {\n      return this.ast.getIsClause(flag);\n    }\n  }, {\n    key: \"addMustIsClause\",\n    value: function addMustIsClause(flag) {\n      var ast = this.ast.addClause(_ast.AST.Is.must(flag));\n      return new Query(ast, this.syntax);\n    }\n  }, {\n    key: \"addMustNotIsClause\",\n    value: function addMustNotIsClause(flag) {\n      var ast = this.ast.addClause(_ast.AST.Is.mustNot(flag));\n      return new Query(ast, this.syntax);\n    }\n  }, {\n    key: \"removeIsClause\",\n    value: function removeIsClause(flag) {\n      var ast = this.ast.removeIsClause(flag);\n      return new Query(ast, this.syntax);\n    }\n    /**\n     * Executes this query over the given iterable item and returns\n     * an new array of all items that matched this query. Options:\n     *\n     * defaultFields: string[]\n     *\n     *    An array of field names to match the default clauses against. When not specified, the query\n     *    will pick up all the string fields of each record and try to match against those.\n     *\n     * isClauseMatcher?: (record: any, flag: string, applied: boolean, explain?: []) => boolean\n     *\n     *    By default the 'is' clauses will try to match against boolean fields - where the flag of the clause\n     *    indicates the field name. You can change this behaviour by providing this matcher function for the\n     *    is clause. For example, if the object has a `tags` field, one can create a matcher that checks if\n     *    an object has a specific tag (e.g. \"is:marketing\", \"is:kitchen\", etc..)\n     *\n     * explain?: boolean\n     *\n     *    When set to `true`, each item in the returns array will have an `__explain` field that will hold\n     *    information about why the objects matched the query (default to `false`, mainly/only useful for\n     *    debugging)\n     */\n\n  }], [{\n    key: \"execute\",\n    value: function execute(query, items) {\n      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      var q = (0, _predicate.isString)(query) ? Query.parse(query) : query;\n      return (0, _execute_ast.executeAst)(q.ast, items, options);\n    }\n    /**\n     * Builds and returns an Elasticsearch query out this query. Options:\n     *\n     * defaultFields?: string[]\n     *\n     *    An array of field names to match the default clauses against. When not specified, the query\n     *    will pick up all the string fields of each record and try to match against those.\n     *\n     * isToQuery?: (flag: string, on: boolean) => Object (elasticsearch query object)\n     *\n     *    By default, \"is\" clauses will be translated to a term query where the flag is the field\n     *    and the \"on\" value will be the value of the field. This function lets you change this default\n     *    translation and provide your own custom one.\n     *\n     * termValuesToQuery?: (values: string[]) => Object (elasticsearch query object)\n     *\n     *    By default, \"term\" clauses will be translated to a \"simple_query_string\" query where all\n     *    the values serve as terms in the query string. This function lets you change this default\n     *    translation and provide your own custom one.\n     *\n     * fieldValuesToAndQuery?: (field: string, values: string[]) => Object (elasticsearch query object)\n     *\n     *    By default, \"field\" clauses will be translated to a match query where all the values serve as\n     *    terms in the query(the operator is AND). This function lets you change this default translation\n     *    and provide your own custom one.\n     */\n\n  }, {\n    key: \"toESQuery\",\n    value: function toESQuery(query) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var q = (0, _predicate.isString)(query) ? Query.parse(query) : query;\n      return (0, _ast_to_es_query_dsl.astToEsQueryDsl)(q.ast, options);\n    }\n  }, {\n    key: \"toESQueryString\",\n    value: function toESQueryString(query) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var q = (0, _predicate.isString)(query) ? Query.parse(query) : query;\n      return (0, _ast_to_es_query_string.astToEsQueryString)(q.ast, options);\n    }\n  }]);\n\n  return Query;\n}();\n\nexports.Query = Query;\n\n_defineProperty(Query, \"MATCH_ALL\", Query.parse(''));",{"version":3,"sources":["/Users/chanderprall/projects/eui/src/components/search_bar/query/query.js"],"names":["Query","text","options","syntax","defaultSyntax","parse","value","format","undefined","clause","AST","Match","isMustClause","Term","isInstance","Is","Field","ast","print","field","hasSimpleFieldClause","getSimpleFieldClause","removeSimpleFieldClauses","must","operator","Operator","EQ","addSimpleFieldValue","removeSimpleFieldValue","hasOrFieldClause","getOrFieldClause","addOrFieldValue","removeOrFieldValue","removeOrFieldClauses","flag","getIsClause","addClause","mustNot","removeIsClause","query","items","q"],"mappings":"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","sourcesContent":["import { defaultSyntax } from './default_syntax';\nimport { executeAst } from './execute_ast';\nimport { isNil, isString } from '../../../services/predicate';\nimport { astToEsQueryDsl } from './ast_to_es_query_dsl';\nimport { astToEsQueryString } from './ast_to_es_query_string';\nimport { dateValueParser } from './date_value';\nimport { AST, Operator } from './ast';\n\n/**\n * This is the consumer interface for the query - it's effectively a wrapper construct around\n * the AST and some of its related utility functions (e.g. parsing, text representation, executing, etc...)\n * It is immutable - all mutating operations return a new (mutated) query instance.\n */\nexport class Query {\n  static parse(text, options, syntax = defaultSyntax) {\n    return new Query(syntax.parse(text, options), syntax, text);\n  }\n\n  static parseDateValue(value, format = undefined) {\n    return dateValueParser(format)(value);\n  }\n\n  static isMust(clause) {\n    return AST.Match.isMustClause(clause);\n  }\n\n  static MATCH_ALL = Query.parse('');\n\n  static isTerm(clause) {\n    return AST.Term.isInstance(clause);\n  }\n\n  static isIs(clause) {\n    return AST.Is.isInstance(clause);\n  }\n\n  static isField(clause) {\n    return AST.Field.isInstance(clause);\n  }\n\n  constructor(ast, syntax = defaultSyntax, text = undefined) {\n    this.ast = ast;\n    this.text = text || syntax.print(ast);\n    this.syntax = syntax;\n  }\n\n  hasSimpleFieldClause(field, value = undefined) {\n    return this.ast.hasSimpleFieldClause(field, value);\n  }\n\n  getSimpleFieldClause(field, value) {\n    return this.ast.getSimpleFieldClause(field, value);\n  }\n\n  removeSimpleFieldClauses(field) {\n    const ast = this.ast.removeSimpleFieldClauses(field);\n    return new Query(ast, this.syntax);\n  }\n\n  addSimpleFieldValue(field, value, must = true, operator = Operator.EQ) {\n    const ast = this.ast.addSimpleFieldValue(field, value, must, operator);\n    return new Query(ast, this.syntax);\n  }\n\n  removeSimpleFieldValue(field, value) {\n    const ast = this.ast.removeSimpleFieldValue(field, value);\n    return new Query(ast, this.syntax);\n  }\n\n  hasOrFieldClause(field, value = undefined) {\n    return this.ast.hasOrFieldClause(field, value);\n  }\n\n  getOrFieldClause(field, value) {\n    return this.ast.getOrFieldClause(field, value);\n  }\n\n  addOrFieldValue(field, value, must = true) {\n    const ast = this.ast.addOrFieldValue(field, value, must);\n    return new Query(ast, this.syntax);\n  }\n\n  removeOrFieldValue(field, value) {\n    const ast = this.ast.removeOrFieldValue(field, value);\n    return new Query(ast, this.syntax);\n  }\n\n  removeOrFieldClauses(field) {\n    const ast = this.ast.removeOrFieldClauses(field);\n    return new Query(ast, this.syntax);\n  }\n\n  hasIsClause(flag) {\n    return !isNil(this.ast.getIsClause(flag));\n  }\n\n  getIsClause(flag) {\n    return this.ast.getIsClause(flag);\n  }\n\n  addMustIsClause(flag) {\n    const ast = this.ast.addClause(AST.Is.must(flag));\n    return new Query(ast, this.syntax);\n  }\n\n  addMustNotIsClause(flag) {\n    const ast = this.ast.addClause(AST.Is.mustNot(flag));\n    return new Query(ast, this.syntax);\n  }\n\n  removeIsClause(flag) {\n    const ast = this.ast.removeIsClause(flag);\n    return new Query(ast, this.syntax);\n  }\n\n  /**\n   * Executes this query over the given iterable item and returns\n   * an new array of all items that matched this query. Options:\n   *\n   * defaultFields: string[]\n   *\n   *    An array of field names to match the default clauses against. When not specified, the query\n   *    will pick up all the string fields of each record and try to match against those.\n   *\n   * isClauseMatcher?: (record: any, flag: string, applied: boolean, explain?: []) => boolean\n   *\n   *    By default the 'is' clauses will try to match against boolean fields - where the flag of the clause\n   *    indicates the field name. You can change this behaviour by providing this matcher function for the\n   *    is clause. For example, if the object has a `tags` field, one can create a matcher that checks if\n   *    an object has a specific tag (e.g. \"is:marketing\", \"is:kitchen\", etc..)\n   *\n   * explain?: boolean\n   *\n   *    When set to `true`, each item in the returns array will have an `__explain` field that will hold\n   *    information about why the objects matched the query (default to `false`, mainly/only useful for\n   *    debugging)\n   */\n  static execute(query, items, options = {}) {\n    const q = isString(query) ? Query.parse(query) : query;\n    return executeAst(q.ast, items, options);\n  }\n\n  /**\n   * Builds and returns an Elasticsearch query out this query. Options:\n   *\n   * defaultFields?: string[]\n   *\n   *    An array of field names to match the default clauses against. When not specified, the query\n   *    will pick up all the string fields of each record and try to match against those.\n   *\n   * isToQuery?: (flag: string, on: boolean) => Object (elasticsearch query object)\n   *\n   *    By default, \"is\" clauses will be translated to a term query where the flag is the field\n   *    and the \"on\" value will be the value of the field. This function lets you change this default\n   *    translation and provide your own custom one.\n   *\n   * termValuesToQuery?: (values: string[]) => Object (elasticsearch query object)\n   *\n   *    By default, \"term\" clauses will be translated to a \"simple_query_string\" query where all\n   *    the values serve as terms in the query string. This function lets you change this default\n   *    translation and provide your own custom one.\n   *\n   * fieldValuesToAndQuery?: (field: string, values: string[]) => Object (elasticsearch query object)\n   *\n   *    By default, \"field\" clauses will be translated to a match query where all the values serve as\n   *    terms in the query(the operator is AND). This function lets you change this default translation\n   *    and provide your own custom one.\n   */\n  static toESQuery(query, options = {}) {\n    const q = isString(query) ? Query.parse(query) : query;\n    return astToEsQueryDsl(q.ast, options);\n  }\n\n  static toESQueryString(query, options = {}) {\n    const q = isString(query) ? Query.parse(query) : query;\n    return astToEsQueryString(q.ast, options);\n  }\n}\n"]}]}