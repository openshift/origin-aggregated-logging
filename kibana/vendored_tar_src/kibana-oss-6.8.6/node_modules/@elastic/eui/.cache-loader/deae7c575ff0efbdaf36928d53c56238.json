{"remainingRequest":"/Users/chanderprall/projects/eui/node_modules/babel-loader/lib/index.js!/Users/chanderprall/projects/eui/src/components/popover/popover.js","dependencies":[{"path":"/Users/chanderprall/projects/eui/src/components/popover/popover.js","mtime":1567534071284},{"path":"/Users/chanderprall/projects/eui/.babelrc.js","mtime":1565204168946},{"path":"/Users/chanderprall/projects/eui/node_modules/cache-loader/dist/cjs.js","mtime":1555436064329},{"path":"/Users/chanderprall/projects/eui/node_modules/babel-loader/lib/index.js","mtime":1543517280769}],"contextDependencies":[],"result":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getPopoverPositionFromAnchorPosition = getPopoverPositionFromAnchorPosition;\nexports.getPopoverAlignFromAnchorPosition = getPopoverAlignFromAnchorPosition;\nexports.EuiPopoverPropTypes = exports.EuiPopover = exports.DISPLAY = exports.ANCHOR_POSITIONS = void 0;\n\nrequire(\"core-js/modules/es6.object.assign\");\n\nrequire(\"core-js/modules/es6.object.set-prototype-of\");\n\nrequire(\"core-js/modules/es7.symbol.async-iterator\");\n\nrequire(\"core-js/modules/es6.symbol\");\n\nrequire(\"core-js/modules/web.dom.iterable\");\n\nrequire(\"core-js/modules/es6.array.iterator\");\n\nrequire(\"core-js/modules/es6.object.keys\");\n\nrequire(\"core-js/modules/es6.regexp.match\");\n\nvar _react = _interopRequireWildcard(require(\"react\"));\n\nvar _propTypes = _interopRequireDefault(require(\"prop-types\"));\n\nvar _classnames = _interopRequireDefault(require(\"classnames\"));\n\nvar _tabbable = _interopRequireDefault(require(\"tabbable\"));\n\nvar _services = require(\"../../services\");\n\nvar _focus_trap = require(\"../focus_trap\");\n\nvar _outside_click_detector = require(\"../outside_click_detector\");\n\nvar _accessibility = require(\"../accessibility\");\n\nvar _panel = require(\"../panel\");\n\nvar _portal = require(\"../portal\");\n\nvar _mutation_observer = require(\"../observer/mutation_observer\");\n\nvar _popover_positioning = require(\"../../services/popover/popover_positioning\");\n\nvar _i18n = require(\"../i18n\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); }\n\nfunction _iterableToArrayLimit(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nvar anchorPositionToPopoverPositionMap = {\n  up: 'top',\n  right: 'right',\n  down: 'bottom',\n  left: 'left'\n};\n\nfunction getPopoverPositionFromAnchorPosition(anchorPosition) {\n  // maps the anchor position to the matching popover position\n  // e.g. \"upLeft\" -> \"top\", \"downRight\" -> \"bottom\"\n  // extract the first positional word from anchorPosition:\n  // starts at the beginning (\" ^ \") of anchorPosition and\n  // captures all of the characters (\" (.*?) \") until the\n  // first capital letter (\" [A-Z] \") is encountered\n  var _anchorPosition$match = anchorPosition.match(/^(.*?)[A-Z]/),\n      _anchorPosition$match2 = _slicedToArray(_anchorPosition$match, 2),\n      primaryPosition = _anchorPosition$match2[1];\n\n  return anchorPositionToPopoverPositionMap[primaryPosition];\n}\n\nfunction getPopoverAlignFromAnchorPosition(anchorPosition) {\n  // maps the gravity to the matching popover position\n  // e.g. \"upLeft\" -> \"left\", \"rightDown\" -> \"bottom\"\n  // extract the second positional word from anchorPosition:\n  // starts a capture group at the first capital letter\n  // and includes everything after it\n  var _anchorPosition$match3 = anchorPosition.match(/([A-Z].*)/),\n      _anchorPosition$match4 = _slicedToArray(_anchorPosition$match3, 2),\n      align = _anchorPosition$match4[1]; // this performs two tasks:\n  // 1. normalizes the align position by lowercasing it\n  // 2. `center` doesn't exist in the lookup map which converts it to `undefined` meaning no align\n\n\n  return anchorPositionToPopoverPositionMap[align.toLowerCase()];\n}\n\nvar anchorPositionToClassNameMap = {\n  upCenter: 'euiPopover--anchorUpCenter',\n  upLeft: 'euiPopover--anchorUpLeft',\n  upRight: 'euiPopover--anchorUpRight',\n  downCenter: 'euiPopover--anchorDownCenter',\n  downLeft: 'euiPopover--anchorDownLeft',\n  downRight: 'euiPopover--anchorDownRight',\n  leftCenter: 'euiPopover--anchorLeftCenter',\n  leftUp: 'euiPopover--anchorLeftUp',\n  leftDown: 'euiPopover--anchorLeftDown',\n  rightCenter: 'euiPopover--anchorRightCenter',\n  rightUp: 'euiPopover--anchorRightUp',\n  rightDown: 'euiPopover--anchorRightDown'\n};\nvar ANCHOR_POSITIONS = Object.keys(anchorPositionToClassNameMap);\nexports.ANCHOR_POSITIONS = ANCHOR_POSITIONS;\nvar displayToClassNameMap = {\n  inlineBlock: undefined,\n  block: 'euiPopover--displayBlock'\n};\nvar DISPLAY = Object.keys(displayToClassNameMap);\nexports.DISPLAY = DISPLAY;\nvar DEFAULT_POPOVER_STYLES = {\n  top: 50,\n  left: 50\n};\n\nfunction getElementFromInitialFocus(initialFocus) {\n  var initialFocusType = _typeof(initialFocus);\n\n  if (initialFocusType === 'string') return document.querySelector(initialFocus);\n  if (initialFocusType === 'function') return initialFocus();\n  return initialFocus;\n}\n\nvar EuiPopover =\n/*#__PURE__*/\nfunction (_Component) {\n  _inherits(EuiPopover, _Component);\n\n  _createClass(EuiPopover, null, [{\n    key: \"getDerivedStateFromProps\",\n    value: function getDerivedStateFromProps(nextProps, prevState) {\n      if (prevState.prevProps.isOpen && !nextProps.isOpen) {\n        return {\n          prevProps: {\n            isOpen: nextProps.isOpen\n          },\n          isClosing: true,\n          isOpening: false\n        };\n      }\n\n      if (prevState.prevProps.isOpen !== nextProps.isOpen) {\n        return {\n          prevProps: {\n            isOpen: nextProps.isOpen\n          }\n        };\n      }\n\n      return null;\n    }\n  }]);\n\n  function EuiPopover(props) {\n    var _this;\n\n    _classCallCheck(this, EuiPopover);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(EuiPopover).call(this, props));\n\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"onKeyDown\", function (e) {\n      if (e.keyCode === _services.cascadingMenuKeyCodes.ESCAPE) {\n        if (_this.state.isOpenStable || _this.state.isOpening) {\n          e.preventDefault();\n          e.stopPropagation();\n\n          _this.props.closePopover();\n        }\n      }\n    });\n\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"onMutation\", function (records) {\n      var waitDuration = (0, _services.getWaitDuration)(records);\n\n      _this.positionPopoverFixed();\n\n      (0, _services.performOnFrame)(waitDuration, _this.positionPopoverFixed);\n    });\n\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"positionPopover\", function (allowEnforcePosition) {\n      if (_this.button == null || _this.panel == null) return;\n      var position = getPopoverPositionFromAnchorPosition(_this.props.anchorPosition);\n      var forcePosition = null;\n\n      if (allowEnforcePosition && _this.state.isOpenStable && _this.state.openPosition != null) {\n        position = _this.state.openPosition;\n        forcePosition = true;\n      }\n\n      var _findPopoverPosition = (0, _popover_positioning.findPopoverPosition)({\n        container: _this.props.container,\n        position: position,\n        forcePosition: forcePosition,\n        align: getPopoverAlignFromAnchorPosition(_this.props.anchorPosition),\n        anchor: _this.button,\n        popover: _this.panel,\n        offset: !_this.props.attachToAnchor && _this.props.hasArrow ? 16 : 8,\n        arrowConfig: {\n          arrowWidth: 24,\n          arrowBuffer: 10\n        },\n        returnBoundingBox: _this.props.attachToAnchor\n      }),\n          top = _findPopoverPosition.top,\n          left = _findPopoverPosition.left,\n          foundPosition = _findPopoverPosition.position,\n          arrow = _findPopoverPosition.arrow,\n          anchorBoundingBox = _findPopoverPosition.anchorBoundingBox; // the popover's z-index must inherit from the button\n      // this keeps a button's popover under a flyout that would cover the button\n      // but a popover triggered inside a flyout will appear over that flyout\n\n\n      var zIndexProp = _this.props.zIndex;\n      var zIndex = zIndexProp == null ? (0, _popover_positioning.getElementZIndex)(_this.button, _this.panel) : zIndexProp;\n      var popoverStyles = {\n        top: top,\n        left: _this.props.attachToAnchor ? anchorBoundingBox.left : left,\n        zIndex: zIndex\n      };\n      var willRenderArrow = !_this.props.attachToAnchor && _this.props.hasArrow;\n      var arrowStyles = willRenderArrow ? arrow : null;\n      var arrowPosition = foundPosition;\n\n      _this.setState({\n        popoverStyles: popoverStyles,\n        arrowStyles: arrowStyles,\n        arrowPosition: arrowPosition,\n        openPosition: foundPosition\n      });\n    });\n\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"positionPopoverFixed\", function () {\n      _this.positionPopover(true);\n    });\n\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"positionPopoverFluid\", function () {\n      _this.positionPopover(false);\n    });\n\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"panelRef\", function (node) {\n      _this.panel = node;\n      _this.props.panelRef && _this.props.panelRef(node);\n\n      if (node == null) {\n        // panel has unmounted, restore the state defaults\n        _this.setState({\n          popoverStyles: DEFAULT_POPOVER_STYLES,\n          arrowStyles: {},\n          arrowPosition: null,\n          openPosition: null,\n          isOpenStable: false\n        });\n\n        window.removeEventListener('resize', _this.positionPopoverFluid);\n      } else {\n        // panel is coming into existence\n        _this.positionPopoverFluid();\n\n        window.addEventListener('resize', _this.positionPopoverFluid);\n      }\n    });\n\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"buttonRef\", function (node) {\n      _this.button = node;\n      _this.props.buttonRef && _this.props.buttonRef(node);\n    });\n\n    _this.closingTransitionTimeout = undefined;\n    _this.button = null;\n    _this.state = {\n      prevProps: {\n        isOpen: props.isOpen\n      },\n      suppressingPopover: _this.props.isOpen,\n      // only suppress if created with isOpen=true\n      isClosing: false,\n      isOpening: false,\n      popoverStyles: DEFAULT_POPOVER_STYLES,\n      arrowStyles: {},\n      arrowPosition: null,\n      openPosition: null,\n      // once a stable position has been found, keep the contents on that side\n      isOpenStable: false // wait for any initial opening transitions to finish before marking as stable\n\n    };\n    return _this;\n  }\n\n  _createClass(EuiPopover, [{\n    key: \"updateFocus\",\n    value: function updateFocus() {\n      var _this2 = this;\n\n      // Wait for the DOM to update.\n      window.requestAnimationFrame(function () {\n        if (!_this2.props.ownFocus || !_this2.panel) {\n          return;\n        } // If we've already focused on something inside the panel, everything's fine.\n\n\n        if (_this2.panel.contains(document.activeElement)) {\n          return;\n        } // Otherwise let's focus the first tabbable item and expedite input from the user.\n\n\n        var focusTarget;\n\n        if (_this2.props.initialFocus != null) {\n          focusTarget = getElementFromInitialFocus(_this2.props.initialFocus); // there's a race condition between the popover content becoming visible and this function call\n          // if the element isn't visible yet (due to css styling) then it can't accept focus\n          // so wait for another render and try again\n\n          var visibility = window.getComputedStyle(focusTarget).visibility;\n\n          if (visibility === 'hidden') {\n            _this2.updateFocus();\n          }\n        } else {\n          var tabbableItems = (0, _tabbable.default)(_this2.panel);\n\n          if (tabbableItems.length) {\n            focusTarget = tabbableItems[0];\n          }\n        }\n\n        if (focusTarget != null) focusTarget.focus();\n      });\n    }\n  }, {\n    key: \"componentDidMount\",\n    value: function componentDidMount() {\n      if (this.state.suppressingPopover) {\n        // component was created with isOpen=true; now that it's mounted\n        // stop suppressing and start opening\n        this.setState({\n          suppressingPopover: false,\n          isOpening: true\n        }); // eslint-disable-line react/no-did-mount-set-state\n      }\n\n      if (this.props.repositionOnScroll) {\n        window.addEventListener('scroll', this.positionPopoverFixed);\n      }\n\n      this.updateFocus();\n    }\n  }, {\n    key: \"componentDidUpdate\",\n    value: function componentDidUpdate(prevProps) {\n      var _this3 = this;\n\n      // The popover is being opened.\n      if (!prevProps.isOpen && this.props.isOpen) {\n        clearTimeout(this.closingTransitionTimeout); // We need to set this state a beat after the render takes place, so that the CSS\n        // transition can take effect.\n\n        window.requestAnimationFrame(function () {\n          _this3.setState({\n            isOpening: true\n          });\n        }); // for each child element of `this.panel`, find any transition duration we should wait for before stabilizing\n\n        var _Array$prototype$slic = Array.prototype.slice.call(this.panel.children).reduce(function (_ref, element) {\n          var durationMatch = _ref.durationMatch,\n              delayMatch = _ref.delayMatch;\n          var transitionTimings = (0, _services.getTransitionTimings)(element);\n          return {\n            durationMatch: Math.max(durationMatch, transitionTimings.durationMatch),\n            delayMatch: Math.max(delayMatch, transitionTimings.delayMatch)\n          };\n        }, {\n          durationMatch: 0,\n          delayMatch: 0\n        }),\n            durationMatch = _Array$prototype$slic.durationMatch,\n            delayMatch = _Array$prototype$slic.delayMatch;\n\n        setTimeout(function () {\n          _this3.setState({\n            isOpenStable: true\n          }, function () {\n            _this3.positionPopoverFixed();\n\n            _this3.updateFocus();\n          });\n        }, durationMatch + delayMatch);\n      } // update scroll listener\n\n\n      if (prevProps.repositionOnScroll !== this.props.repositionOnScroll) {\n        if (this.props.repositionOnScroll) {\n          window.addEventListener('scroll', this.positionPopoverFixed);\n        } else {\n          window.removeEventListener('scroll', this.positionPopoverFixed);\n        }\n      } // The popover is being closed.\n\n\n      if (prevProps.isOpen && !this.props.isOpen) {\n        // If the user has just closed the popover, queue up the removal of the content after the\n        // transition is complete.\n        this.closingTransitionTimeout = setTimeout(function () {\n          _this3.setState({\n            isClosing: false\n          });\n        }, 250);\n      }\n    }\n  }, {\n    key: \"componentWillUnmount\",\n    value: function componentWillUnmount() {\n      window.removeEventListener('scroll', this.positionPopoverFixed);\n      clearTimeout(this.closingTransitionTimeout);\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      var _this4 = this;\n\n      var _this$props = this.props,\n          anchorClassName = _this$props.anchorClassName,\n          anchorPosition = _this$props.anchorPosition,\n          button = _this$props.button,\n          buttonRef = _this$props.buttonRef,\n          insert = _this$props.insert,\n          isOpen = _this$props.isOpen,\n          ownFocus = _this$props.ownFocus,\n          withTitle = _this$props.withTitle,\n          children = _this$props.children,\n          className = _this$props.className,\n          closePopover = _this$props.closePopover,\n          panelClassName = _this$props.panelClassName,\n          panelPaddingSize = _this$props.panelPaddingSize,\n          panelRef = _this$props.panelRef,\n          popoverRef = _this$props.popoverRef,\n          hasArrow = _this$props.hasArrow,\n          repositionOnScroll = _this$props.repositionOnScroll,\n          zIndex = _this$props.zIndex,\n          initialFocus = _this$props.initialFocus,\n          attachToAnchor = _this$props.attachToAnchor,\n          display = _this$props.display,\n          rest = _objectWithoutProperties(_this$props, [\"anchorClassName\", \"anchorPosition\", \"button\", \"buttonRef\", \"insert\", \"isOpen\", \"ownFocus\", \"withTitle\", \"children\", \"className\", \"closePopover\", \"panelClassName\", \"panelPaddingSize\", \"panelRef\", \"popoverRef\", \"hasArrow\", \"repositionOnScroll\", \"zIndex\", \"initialFocus\", \"attachToAnchor\", \"display\"]);\n\n      var classes = (0, _classnames.default)('euiPopover', anchorPositionToClassNameMap[anchorPosition], displayToClassNameMap[display], {\n        'euiPopover-isOpen': this.state.isOpening,\n        'euiPopover--withTitle': withTitle\n      }, className);\n      var anchorClasses = (0, _classnames.default)('euiPopover__anchor', anchorClassName);\n      var panelClasses = (0, _classnames.default)('euiPopover__panel', \"euiPopover__panel--\".concat(this.state.arrowPosition), {\n        'euiPopover__panel-isOpen': this.state.isOpening\n      }, {\n        'euiPopover__panel-withTitle': withTitle\n      }, {\n        'euiPopover__panel-noArrow': !hasArrow || attachToAnchor\n      }, {\n        'euiPopover__panel-isAttached': attachToAnchor\n      }, panelClassName);\n      var panel;\n\n      if (!this.state.suppressingPopover && (isOpen || this.state.isClosing)) {\n        var tabIndex;\n\n        var _initialFocus;\n\n        var ariaLive;\n\n        if (ownFocus) {\n          tabIndex = '0';\n          ariaLive = 'off';\n\n          _initialFocus = function _initialFocus() {\n            return _this4.panel;\n          };\n        } else {\n          ariaLive = 'assertive';\n        }\n\n        var focusTrapScreenReaderText;\n\n        if (ownFocus) {\n          focusTrapScreenReaderText = _react.default.createElement(_accessibility.EuiScreenReaderOnly, null, _react.default.createElement(\"p\", {\n            role: \"alert\"\n          }, _react.default.createElement(_i18n.EuiI18n, {\n            token: \"euiPopover.screenReaderAnnouncement\",\n            default: \"You are in a popup. To exit this popup, hit escape.\"\n          })));\n        }\n\n        var arrowClassNames = (0, _classnames.default)('euiPopover__panelArrow', \"euiPopover__panelArrow--\".concat(this.state.arrowPosition));\n        panel = _react.default.createElement(_portal.EuiPortal, {\n          insert: insert\n        }, _react.default.createElement(_focus_trap.EuiFocusTrap, {\n          returnFocus: !this.state.isOpening // Ignore temporary state of indecisive focus\n          ,\n          clickOutsideDisables: true,\n          initialFocus: _initialFocus,\n          disabled: !ownFocus\n        }, focusTrapScreenReaderText, _react.default.createElement(_panel.EuiPanel, {\n          panelRef: this.panelRef,\n          className: panelClasses,\n          paddingSize: panelPaddingSize,\n          tabIndex: tabIndex,\n          \"aria-live\": ariaLive,\n          style: this.state.popoverStyles\n        }, _react.default.createElement(\"div\", {\n          className: arrowClassNames,\n          style: this.state.arrowStyles\n        }), _react.default.createElement(_mutation_observer.EuiMutationObserver, {\n          observerOptions: {\n            attributes: true,\n            // element attribute changes\n            childList: true,\n            // added/removed elements\n            characterData: true,\n            // text changes\n            subtree: true // watch all child elements\n\n          },\n          onMutation: this.onMutation\n        }, function (mutationRef) {\n          return _react.default.createElement(\"div\", {\n            ref: mutationRef\n          }, children);\n        }))));\n      }\n\n      return _react.default.createElement(_outside_click_detector.EuiOutsideClickDetector, {\n        isDisabled: !isOpen,\n        onOutsideClick: closePopover\n      }, _react.default.createElement(\"div\", _extends({\n        className: classes,\n        onKeyDown: this.onKeyDown,\n        ref: popoverRef\n      }, rest), _react.default.createElement(\"div\", {\n        className: anchorClasses,\n        ref: this.buttonRef\n      }, button instanceof HTMLElement ? null : button), panel));\n    }\n  }]);\n\n  return EuiPopover;\n}(_react.Component);\n\nexports.EuiPopover = EuiPopover;\nvar EuiPopoverPropTypes = {\n  anchorClassName: _propTypes.default.string,\n  anchorPosition: _propTypes.default.oneOf(ANCHOR_POSITIONS),\n  isOpen: _propTypes.default.bool,\n  ownFocus: _propTypes.default.bool,\n  withTitle: _propTypes.default.bool,\n  closePopover: _propTypes.default.func.isRequired,\n  button: _propTypes.default.node.isRequired,\n  buttonRef: _propTypes.default.func,\n  children: _propTypes.default.node,\n  panelClassName: _propTypes.default.string,\n  panelPaddingSize: _propTypes.default.oneOf(_panel.SIZES),\n  panelRef: _propTypes.default.func,\n  popoverRef: _propTypes.default.func,\n  hasArrow: _propTypes.default.bool,\n  container: _propTypes.default.instanceOf(HTMLElement),\n\n  /** When `true`, the popover's position is re-calculated when the user scrolls, this supports having fixed-position popover anchors. */\n  repositionOnScroll: _propTypes.default.bool,\n\n  /** By default, popover content inherits the z-index of the anchor component; pass zIndex to override */\n  zIndex: _propTypes.default.number,\n\n  /** specifies what element should initially have focus; Can be a DOM node, or a selector string (which will be passed to document.querySelector() to find the DOM node), or a function that returns a DOM node. */\n  initialFocus: _propTypes.default.oneOfType([_propTypes.default.instanceOf(HTMLElement), _propTypes.default.func, _propTypes.default.string]),\n\n  /** Passed directly to EuiPortal for DOM positioning. Both properties are required if prop is specified **/\n  insert: _propTypes.default.shape({\n    sibling: _propTypes.default.instanceOf(HTMLElement),\n    position: _propTypes.default.oneOf(['before', 'after'])\n  }),\n\n  /** Style and position alteration for arrow-less, left-aligned attachment. Intended for use with inputs as anchors, à la EuiColorPicker */\n  attachToAnchor: _propTypes.default.bool,\n\n  /** CSS display type for both the popover and anchor */\n  display: _propTypes.default.oneOf(DISPLAY)\n};\nexports.EuiPopoverPropTypes = EuiPopoverPropTypes;\nEuiPopover.propTypes = EuiPopoverPropTypes;\nEuiPopover.defaultProps = {\n  isOpen: false,\n  ownFocus: false,\n  anchorPosition: 'downCenter',\n  panelPaddingSize: 'm',\n  hasArrow: true,\n  display: 'inlineBlock'\n};\nEuiPopover.__docgenInfo = {\n  \"description\": \"\",\n  \"methods\": [{\n    \"name\": \"getDerivedStateFromProps\",\n    \"docblock\": null,\n    \"modifiers\": [\"static\"],\n    \"params\": [{\n      \"name\": \"nextProps\",\n      \"type\": null\n    }, {\n      \"name\": \"prevState\",\n      \"type\": null\n    }],\n    \"returns\": null\n  }, {\n    \"name\": \"onKeyDown\",\n    \"docblock\": null,\n    \"modifiers\": [],\n    \"params\": [{\n      \"name\": \"e\",\n      \"type\": null\n    }],\n    \"returns\": null\n  }, {\n    \"name\": \"updateFocus\",\n    \"docblock\": null,\n    \"modifiers\": [],\n    \"params\": [],\n    \"returns\": null\n  }, {\n    \"name\": \"onMutation\",\n    \"docblock\": null,\n    \"modifiers\": [],\n    \"params\": [{\n      \"name\": \"records\",\n      \"type\": null\n    }],\n    \"returns\": null\n  }, {\n    \"name\": \"positionPopover\",\n    \"docblock\": null,\n    \"modifiers\": [],\n    \"params\": [{\n      \"name\": \"allowEnforcePosition\",\n      \"type\": null\n    }],\n    \"returns\": null\n  }, {\n    \"name\": \"positionPopoverFixed\",\n    \"docblock\": null,\n    \"modifiers\": [],\n    \"params\": [],\n    \"returns\": null\n  }, {\n    \"name\": \"positionPopoverFluid\",\n    \"docblock\": null,\n    \"modifiers\": [],\n    \"params\": [],\n    \"returns\": null\n  }, {\n    \"name\": \"panelRef\",\n    \"docblock\": null,\n    \"modifiers\": [],\n    \"params\": [{\n      \"name\": \"node\",\n      \"type\": null\n    }],\n    \"returns\": null\n  }, {\n    \"name\": \"buttonRef\",\n    \"docblock\": null,\n    \"modifiers\": [],\n    \"params\": [{\n      \"name\": \"node\",\n      \"type\": null\n    }],\n    \"returns\": null\n  }],\n  \"displayName\": \"EuiPopover\",\n  \"props\": {\n    \"isOpen\": {\n      \"defaultValue\": {\n        \"value\": \"false\",\n        \"computed\": false\n      },\n      \"type\": {\n        \"name\": \"bool\"\n      },\n      \"required\": false,\n      \"description\": \"\"\n    },\n    \"ownFocus\": {\n      \"defaultValue\": {\n        \"value\": \"false\",\n        \"computed\": false\n      },\n      \"type\": {\n        \"name\": \"bool\"\n      },\n      \"required\": false,\n      \"description\": \"\"\n    },\n    \"anchorPosition\": {\n      \"defaultValue\": {\n        \"value\": \"'downCenter'\",\n        \"computed\": false\n      },\n      \"type\": {\n        \"name\": \"enum\",\n        \"value\": [{\n          \"value\": \"\\\"upCenter\\\"\",\n          \"computed\": false\n        }, {\n          \"value\": \"\\\"upLeft\\\"\",\n          \"computed\": false\n        }, {\n          \"value\": \"\\\"upRight\\\"\",\n          \"computed\": false\n        }, {\n          \"value\": \"\\\"downCenter\\\"\",\n          \"computed\": false\n        }, {\n          \"value\": \"\\\"downLeft\\\"\",\n          \"computed\": false\n        }, {\n          \"value\": \"\\\"downRight\\\"\",\n          \"computed\": false\n        }, {\n          \"value\": \"\\\"leftCenter\\\"\",\n          \"computed\": false\n        }, {\n          \"value\": \"\\\"leftUp\\\"\",\n          \"computed\": false\n        }, {\n          \"value\": \"\\\"leftDown\\\"\",\n          \"computed\": false\n        }, {\n          \"value\": \"\\\"rightCenter\\\"\",\n          \"computed\": false\n        }, {\n          \"value\": \"\\\"rightUp\\\"\",\n          \"computed\": false\n        }, {\n          \"value\": \"\\\"rightDown\\\"\",\n          \"computed\": false\n        }]\n      },\n      \"required\": false,\n      \"description\": \"\"\n    },\n    \"panelPaddingSize\": {\n      \"defaultValue\": {\n        \"value\": \"'m'\",\n        \"computed\": false\n      },\n      \"type\": {\n        \"name\": \"enum\",\n        \"computed\": true,\n        \"value\": \"SIZES\"\n      },\n      \"required\": false,\n      \"description\": \"\"\n    },\n    \"hasArrow\": {\n      \"defaultValue\": {\n        \"value\": \"true\",\n        \"computed\": false\n      },\n      \"type\": {\n        \"name\": \"bool\"\n      },\n      \"required\": false,\n      \"description\": \"\"\n    },\n    \"display\": {\n      \"defaultValue\": {\n        \"value\": \"'inlineBlock'\",\n        \"computed\": false\n      },\n      \"type\": {\n        \"name\": \"enum\",\n        \"value\": [{\n          \"value\": \"\\\"inlineBlock\\\"\",\n          \"computed\": false\n        }, {\n          \"value\": \"\\\"block\\\"\",\n          \"computed\": false\n        }]\n      },\n      \"required\": false,\n      \"description\": \"CSS display type for both the popover and anchor\"\n    },\n    \"anchorClassName\": {\n      \"type\": {\n        \"name\": \"string\"\n      },\n      \"required\": false,\n      \"description\": \"\"\n    },\n    \"withTitle\": {\n      \"type\": {\n        \"name\": \"bool\"\n      },\n      \"required\": false,\n      \"description\": \"\"\n    },\n    \"closePopover\": {\n      \"type\": {\n        \"name\": \"func\"\n      },\n      \"required\": true,\n      \"description\": \"\"\n    },\n    \"button\": {\n      \"type\": {\n        \"name\": \"node\"\n      },\n      \"required\": true,\n      \"description\": \"\"\n    },\n    \"buttonRef\": {\n      \"type\": {\n        \"name\": \"func\"\n      },\n      \"required\": false,\n      \"description\": \"\"\n    },\n    \"children\": {\n      \"type\": {\n        \"name\": \"node\"\n      },\n      \"required\": false,\n      \"description\": \"\"\n    },\n    \"panelClassName\": {\n      \"type\": {\n        \"name\": \"string\"\n      },\n      \"required\": false,\n      \"description\": \"\"\n    },\n    \"panelRef\": {\n      \"type\": {\n        \"name\": \"func\"\n      },\n      \"required\": false,\n      \"description\": \"\"\n    },\n    \"popoverRef\": {\n      \"type\": {\n        \"name\": \"func\"\n      },\n      \"required\": false,\n      \"description\": \"\"\n    },\n    \"container\": {\n      \"type\": {\n        \"name\": \"instanceOf\",\n        \"value\": \"HTMLElement\"\n      },\n      \"required\": false,\n      \"description\": \"\"\n    },\n    \"repositionOnScroll\": {\n      \"type\": {\n        \"name\": \"bool\"\n      },\n      \"required\": false,\n      \"description\": \"When `true`, the popover's position is re-calculated when the user scrolls, this supports having fixed-position popover anchors.\"\n    },\n    \"zIndex\": {\n      \"type\": {\n        \"name\": \"number\"\n      },\n      \"required\": false,\n      \"description\": \"By default, popover content inherits the z-index of the anchor component; pass zIndex to override\"\n    },\n    \"initialFocus\": {\n      \"type\": {\n        \"name\": \"union\",\n        \"value\": [{\n          \"name\": \"instanceOf\",\n          \"value\": \"HTMLElement\"\n        }, {\n          \"name\": \"func\"\n        }, {\n          \"name\": \"string\"\n        }]\n      },\n      \"required\": false,\n      \"description\": \"specifies what element should initially have focus; Can be a DOM node, or a selector string (which will be passed to document.querySelector() to find the DOM node), or a function that returns a DOM node.\"\n    },\n    \"insert\": {\n      \"type\": {\n        \"name\": \"shape\",\n        \"value\": {\n          \"sibling\": {\n            \"name\": \"instanceOf\",\n            \"value\": \"HTMLElement\",\n            \"required\": false\n          },\n          \"position\": {\n            \"name\": \"enum\",\n            \"value\": [{\n              \"value\": \"'before'\",\n              \"computed\": false\n            }, {\n              \"value\": \"'after'\",\n              \"computed\": false\n            }],\n            \"required\": false\n          }\n        }\n      },\n      \"required\": false,\n      \"description\": \"Passed directly to EuiPortal for DOM positioning. Both properties are required if prop is specified *\"\n    },\n    \"attachToAnchor\": {\n      \"type\": {\n        \"name\": \"bool\"\n      },\n      \"required\": false,\n      \"description\": \"Style and position alteration for arrow-less, left-aligned attachment. Intended for use with inputs as anchors, \\xE0 la EuiColorPicker\"\n    }\n  }\n};",{"version":3,"sources":["/Users/chanderprall/projects/eui/src/components/popover/popover.js"],"names":["anchorPositionToPopoverPositionMap","up","right","down","left","getPopoverPositionFromAnchorPosition","anchorPosition","match","primaryPosition","getPopoverAlignFromAnchorPosition","align","toLowerCase","anchorPositionToClassNameMap","upCenter","upLeft","upRight","downCenter","downLeft","downRight","leftCenter","leftUp","leftDown","rightCenter","rightUp","rightDown","ANCHOR_POSITIONS","Object","keys","displayToClassNameMap","inlineBlock","undefined","block","DISPLAY","DEFAULT_POPOVER_STYLES","top","getElementFromInitialFocus","initialFocus","initialFocusType","document","querySelector","EuiPopover","nextProps","prevState","prevProps","isOpen","isClosing","isOpening","props","e","keyCode","cascadingMenuKeyCodes","ESCAPE","state","isOpenStable","preventDefault","stopPropagation","closePopover","records","waitDuration","positionPopoverFixed","allowEnforcePosition","button","panel","position","forcePosition","openPosition","container","anchor","popover","offset","attachToAnchor","hasArrow","arrowConfig","arrowWidth","arrowBuffer","returnBoundingBox","foundPosition","arrow","anchorBoundingBox","zIndexProp","zIndex","popoverStyles","willRenderArrow","arrowStyles","arrowPosition","setState","positionPopover","node","panelRef","window","removeEventListener","positionPopoverFluid","addEventListener","buttonRef","closingTransitionTimeout","suppressingPopover","requestAnimationFrame","ownFocus","contains","activeElement","focusTarget","visibility","getComputedStyle","updateFocus","tabbableItems","length","focus","repositionOnScroll","clearTimeout","Array","prototype","slice","call","children","reduce","element","durationMatch","delayMatch","transitionTimings","Math","max","setTimeout","anchorClassName","insert","withTitle","className","panelClassName","panelPaddingSize","popoverRef","display","rest","classes","anchorClasses","panelClasses","tabIndex","ariaLive","focusTrapScreenReaderText","arrowClassNames","attributes","childList","characterData","subtree","onMutation","mutationRef","onKeyDown","HTMLElement","Component","EuiPopoverPropTypes","PropTypes","string","oneOf","bool","func","isRequired","SIZES","instanceOf","number","oneOfType","shape","sibling","propTypes","defaultProps"],"mappings":"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","sourcesContent":["import React, { Component } from 'react';\nimport PropTypes from 'prop-types';\nimport classNames from 'classnames';\nimport tabbable from 'tabbable';\n\nimport {\n  cascadingMenuKeyCodes,\n  getTransitionTimings,\n  getWaitDuration,\n  performOnFrame,\n} from '../../services';\n\nimport { EuiFocusTrap } from '../focus_trap';\n\nimport { EuiOutsideClickDetector } from '../outside_click_detector';\n\nimport { EuiScreenReaderOnly } from '../accessibility';\n\nimport { EuiPanel, SIZES } from '../panel';\n\nimport { EuiPortal } from '../portal';\n\nimport { EuiMutationObserver } from '../observer/mutation_observer';\n\nimport {\n  findPopoverPosition,\n  getElementZIndex,\n} from '../../services/popover/popover_positioning';\nimport { EuiI18n } from '../i18n';\n\nconst anchorPositionToPopoverPositionMap = {\n  up: 'top',\n  right: 'right',\n  down: 'bottom',\n  left: 'left',\n};\nexport function getPopoverPositionFromAnchorPosition(anchorPosition) {\n  // maps the anchor position to the matching popover position\n  // e.g. \"upLeft\" -> \"top\", \"downRight\" -> \"bottom\"\n\n  // extract the first positional word from anchorPosition:\n  // starts at the beginning (\" ^ \") of anchorPosition and\n  // captures all of the characters (\" (.*?) \") until the\n  // first capital letter (\" [A-Z] \") is encountered\n  const [, primaryPosition] = anchorPosition.match(/^(.*?)[A-Z]/);\n  return anchorPositionToPopoverPositionMap[primaryPosition];\n}\nexport function getPopoverAlignFromAnchorPosition(anchorPosition) {\n  // maps the gravity to the matching popover position\n  // e.g. \"upLeft\" -> \"left\", \"rightDown\" -> \"bottom\"\n\n  // extract the second positional word from anchorPosition:\n  // starts a capture group at the first capital letter\n  // and includes everything after it\n  const [, align] = anchorPosition.match(/([A-Z].*)/);\n\n  // this performs two tasks:\n  // 1. normalizes the align position by lowercasing it\n  // 2. `center` doesn't exist in the lookup map which converts it to `undefined` meaning no align\n  return anchorPositionToPopoverPositionMap[align.toLowerCase()];\n}\n\nconst anchorPositionToClassNameMap = {\n  upCenter: 'euiPopover--anchorUpCenter',\n  upLeft: 'euiPopover--anchorUpLeft',\n  upRight: 'euiPopover--anchorUpRight',\n  downCenter: 'euiPopover--anchorDownCenter',\n  downLeft: 'euiPopover--anchorDownLeft',\n  downRight: 'euiPopover--anchorDownRight',\n  leftCenter: 'euiPopover--anchorLeftCenter',\n  leftUp: 'euiPopover--anchorLeftUp',\n  leftDown: 'euiPopover--anchorLeftDown',\n  rightCenter: 'euiPopover--anchorRightCenter',\n  rightUp: 'euiPopover--anchorRightUp',\n  rightDown: 'euiPopover--anchorRightDown',\n};\n\nexport const ANCHOR_POSITIONS = Object.keys(anchorPositionToClassNameMap);\n\nconst displayToClassNameMap = {\n  inlineBlock: undefined,\n  block: 'euiPopover--displayBlock',\n};\n\nexport const DISPLAY = Object.keys(displayToClassNameMap);\n\nconst DEFAULT_POPOVER_STYLES = {\n  top: 50,\n  left: 50,\n};\n\nfunction getElementFromInitialFocus(initialFocus) {\n  const initialFocusType = typeof initialFocus;\n  if (initialFocusType === 'string')\n    return document.querySelector(initialFocus);\n  if (initialFocusType === 'function') return initialFocus();\n  return initialFocus;\n}\n\nexport class EuiPopover extends Component {\n  static getDerivedStateFromProps(nextProps, prevState) {\n    if (prevState.prevProps.isOpen && !nextProps.isOpen) {\n      return {\n        prevProps: {\n          isOpen: nextProps.isOpen,\n        },\n        isClosing: true,\n        isOpening: false,\n      };\n    }\n\n    if (prevState.prevProps.isOpen !== nextProps.isOpen) {\n      return {\n        prevProps: {\n          isOpen: nextProps.isOpen,\n        },\n      };\n    }\n\n    return null;\n  }\n\n  constructor(props) {\n    super(props);\n\n    this.closingTransitionTimeout = undefined;\n    this.button = null;\n\n    this.state = {\n      prevProps: {\n        isOpen: props.isOpen,\n      },\n      suppressingPopover: this.props.isOpen, // only suppress if created with isOpen=true\n      isClosing: false,\n      isOpening: false,\n      popoverStyles: DEFAULT_POPOVER_STYLES,\n      arrowStyles: {},\n      arrowPosition: null,\n      openPosition: null, // once a stable position has been found, keep the contents on that side\n      isOpenStable: false, // wait for any initial opening transitions to finish before marking as stable\n    };\n  }\n\n  onKeyDown = e => {\n    if (e.keyCode === cascadingMenuKeyCodes.ESCAPE) {\n      if (this.state.isOpenStable || this.state.isOpening) {\n        e.preventDefault();\n        e.stopPropagation();\n        this.props.closePopover();\n      }\n    }\n  };\n\n  updateFocus() {\n    // Wait for the DOM to update.\n    window.requestAnimationFrame(() => {\n      if (!this.props.ownFocus || !this.panel) {\n        return;\n      }\n\n      // If we've already focused on something inside the panel, everything's fine.\n      if (this.panel.contains(document.activeElement)) {\n        return;\n      }\n\n      // Otherwise let's focus the first tabbable item and expedite input from the user.\n      let focusTarget;\n\n      if (this.props.initialFocus != null) {\n        focusTarget = getElementFromInitialFocus(this.props.initialFocus);\n        // there's a race condition between the popover content becoming visible and this function call\n        // if the element isn't visible yet (due to css styling) then it can't accept focus\n        // so wait for another render and try again\n        const visibility = window.getComputedStyle(focusTarget).visibility;\n        if (visibility === 'hidden') {\n          this.updateFocus();\n        }\n      } else {\n        const tabbableItems = tabbable(this.panel);\n        if (tabbableItems.length) {\n          focusTarget = tabbableItems[0];\n        }\n      }\n\n      if (focusTarget != null) focusTarget.focus();\n    });\n  }\n\n  componentDidMount() {\n    if (this.state.suppressingPopover) {\n      // component was created with isOpen=true; now that it's mounted\n      // stop suppressing and start opening\n      this.setState({ suppressingPopover: false, isOpening: true }); // eslint-disable-line react/no-did-mount-set-state\n    }\n\n    if (this.props.repositionOnScroll) {\n      window.addEventListener('scroll', this.positionPopoverFixed);\n    }\n\n    this.updateFocus();\n  }\n\n  componentDidUpdate(prevProps) {\n    // The popover is being opened.\n    if (!prevProps.isOpen && this.props.isOpen) {\n      clearTimeout(this.closingTransitionTimeout);\n      // We need to set this state a beat after the render takes place, so that the CSS\n      // transition can take effect.\n      window.requestAnimationFrame(() => {\n        this.setState({\n          isOpening: true,\n        });\n      });\n\n      // for each child element of `this.panel`, find any transition duration we should wait for before stabilizing\n      const { durationMatch, delayMatch } = Array.prototype.slice\n        .call(this.panel.children)\n        .reduce(\n          ({ durationMatch, delayMatch }, element) => {\n            const transitionTimings = getTransitionTimings(element);\n\n            return {\n              durationMatch: Math.max(\n                durationMatch,\n                transitionTimings.durationMatch\n              ),\n              delayMatch: Math.max(delayMatch, transitionTimings.delayMatch),\n            };\n          },\n          { durationMatch: 0, delayMatch: 0 }\n        );\n\n      setTimeout(() => {\n        this.setState({ isOpenStable: true }, () => {\n          this.positionPopoverFixed();\n          this.updateFocus();\n        });\n      }, durationMatch + delayMatch);\n    }\n\n    // update scroll listener\n    if (prevProps.repositionOnScroll !== this.props.repositionOnScroll) {\n      if (this.props.repositionOnScroll) {\n        window.addEventListener('scroll', this.positionPopoverFixed);\n      } else {\n        window.removeEventListener('scroll', this.positionPopoverFixed);\n      }\n    }\n\n    // The popover is being closed.\n    if (prevProps.isOpen && !this.props.isOpen) {\n      // If the user has just closed the popover, queue up the removal of the content after the\n      // transition is complete.\n      this.closingTransitionTimeout = setTimeout(() => {\n        this.setState({\n          isClosing: false,\n        });\n      }, 250);\n    }\n  }\n\n  componentWillUnmount() {\n    window.removeEventListener('scroll', this.positionPopoverFixed);\n    clearTimeout(this.closingTransitionTimeout);\n  }\n\n  onMutation = records => {\n    const waitDuration = getWaitDuration(records);\n    this.positionPopoverFixed();\n\n    performOnFrame(waitDuration, this.positionPopoverFixed);\n  };\n\n  positionPopover = allowEnforcePosition => {\n    if (this.button == null || this.panel == null) return;\n\n    let position = getPopoverPositionFromAnchorPosition(\n      this.props.anchorPosition\n    );\n    let forcePosition = null;\n    if (\n      allowEnforcePosition &&\n      this.state.isOpenStable &&\n      this.state.openPosition != null\n    ) {\n      position = this.state.openPosition;\n      forcePosition = true;\n    }\n\n    const {\n      top,\n      left,\n      position: foundPosition,\n      arrow,\n      anchorBoundingBox,\n    } = findPopoverPosition({\n      container: this.props.container,\n      position,\n      forcePosition,\n      align: getPopoverAlignFromAnchorPosition(this.props.anchorPosition),\n      anchor: this.button,\n      popover: this.panel,\n      offset: !this.props.attachToAnchor && this.props.hasArrow ? 16 : 8,\n      arrowConfig: {\n        arrowWidth: 24,\n        arrowBuffer: 10,\n      },\n      returnBoundingBox: this.props.attachToAnchor,\n    });\n\n    // the popover's z-index must inherit from the button\n    // this keeps a button's popover under a flyout that would cover the button\n    // but a popover triggered inside a flyout will appear over that flyout\n    const { zIndex: zIndexProp } = this.props;\n    const zIndex =\n      zIndexProp == null\n        ? getElementZIndex(this.button, this.panel)\n        : zIndexProp;\n\n    const popoverStyles = {\n      top,\n      left: this.props.attachToAnchor ? anchorBoundingBox.left : left,\n      zIndex,\n    };\n\n    const willRenderArrow = !this.props.attachToAnchor && this.props.hasArrow;\n    const arrowStyles = willRenderArrow ? arrow : null;\n    const arrowPosition = foundPosition;\n\n    this.setState({\n      popoverStyles,\n      arrowStyles,\n      arrowPosition,\n      openPosition: foundPosition,\n    });\n  };\n\n  positionPopoverFixed = () => {\n    this.positionPopover(true);\n  };\n\n  positionPopoverFluid = () => {\n    this.positionPopover(false);\n  };\n\n  panelRef = node => {\n    this.panel = node;\n    this.props.panelRef && this.props.panelRef(node);\n\n    if (node == null) {\n      // panel has unmounted, restore the state defaults\n      this.setState({\n        popoverStyles: DEFAULT_POPOVER_STYLES,\n        arrowStyles: {},\n        arrowPosition: null,\n        openPosition: null,\n        isOpenStable: false,\n      });\n      window.removeEventListener('resize', this.positionPopoverFluid);\n    } else {\n      // panel is coming into existence\n      this.positionPopoverFluid();\n      window.addEventListener('resize', this.positionPopoverFluid);\n    }\n  };\n\n  buttonRef = node => {\n    this.button = node;\n    this.props.buttonRef && this.props.buttonRef(node);\n  };\n\n  render() {\n    const {\n      anchorClassName,\n      anchorPosition,\n      button,\n      buttonRef,\n      insert,\n      isOpen,\n      ownFocus,\n      withTitle,\n      children,\n      className,\n      closePopover,\n      panelClassName,\n      panelPaddingSize,\n      panelRef,\n      popoverRef,\n      hasArrow,\n      repositionOnScroll,\n      zIndex,\n      initialFocus,\n      attachToAnchor,\n      display,\n      ...rest\n    } = this.props;\n\n    const classes = classNames(\n      'euiPopover',\n      anchorPositionToClassNameMap[anchorPosition],\n      displayToClassNameMap[display],\n      {\n        'euiPopover-isOpen': this.state.isOpening,\n        'euiPopover--withTitle': withTitle,\n      },\n      className\n    );\n\n    const anchorClasses = classNames('euiPopover__anchor', anchorClassName);\n\n    const panelClasses = classNames(\n      'euiPopover__panel',\n      `euiPopover__panel--${this.state.arrowPosition}`,\n      { 'euiPopover__panel-isOpen': this.state.isOpening },\n      { 'euiPopover__panel-withTitle': withTitle },\n      { 'euiPopover__panel-noArrow': !hasArrow || attachToAnchor },\n      { 'euiPopover__panel-isAttached': attachToAnchor },\n      panelClassName\n    );\n\n    let panel;\n\n    if (!this.state.suppressingPopover && (isOpen || this.state.isClosing)) {\n      let tabIndex;\n      let initialFocus;\n      let ariaLive;\n\n      if (ownFocus) {\n        tabIndex = '0';\n        ariaLive = 'off';\n\n        initialFocus = () => this.panel;\n      } else {\n        ariaLive = 'assertive';\n      }\n\n      let focusTrapScreenReaderText;\n      if (ownFocus) {\n        focusTrapScreenReaderText = (\n          <EuiScreenReaderOnly>\n            <p role=\"alert\">\n              <EuiI18n\n                token=\"euiPopover.screenReaderAnnouncement\"\n                default=\"You are in a popup. To exit this popup, hit escape.\"\n              />\n            </p>\n          </EuiScreenReaderOnly>\n        );\n      }\n\n      const arrowClassNames = classNames(\n        'euiPopover__panelArrow',\n        `euiPopover__panelArrow--${this.state.arrowPosition}`\n      );\n\n      panel = (\n        <EuiPortal insert={insert}>\n          <EuiFocusTrap\n            returnFocus={!this.state.isOpening} // Ignore temporary state of indecisive focus\n            clickOutsideDisables={true}\n            initialFocus={initialFocus}\n            disabled={!ownFocus}>\n            {focusTrapScreenReaderText}\n            <EuiPanel\n              panelRef={this.panelRef}\n              className={panelClasses}\n              paddingSize={panelPaddingSize}\n              tabIndex={tabIndex}\n              aria-live={ariaLive}\n              style={this.state.popoverStyles}>\n              <div className={arrowClassNames} style={this.state.arrowStyles} />\n              <EuiMutationObserver\n                observerOptions={{\n                  attributes: true, // element attribute changes\n                  childList: true, // added/removed elements\n                  characterData: true, // text changes\n                  subtree: true, // watch all child elements\n                }}\n                onMutation={this.onMutation}>\n                {mutationRef => <div ref={mutationRef}>{children}</div>}\n              </EuiMutationObserver>\n            </EuiPanel>\n          </EuiFocusTrap>\n        </EuiPortal>\n      );\n    }\n\n    return (\n      <EuiOutsideClickDetector\n        isDisabled={!isOpen}\n        onOutsideClick={closePopover}>\n        <div\n          className={classes}\n          onKeyDown={this.onKeyDown}\n          ref={popoverRef}\n          {...rest}>\n          <div className={anchorClasses} ref={this.buttonRef}>\n            {button instanceof HTMLElement ? null : button}\n          </div>\n          {panel}\n        </div>\n      </EuiOutsideClickDetector>\n    );\n  }\n}\n\nexport const EuiPopoverPropTypes = {\n  anchorClassName: PropTypes.string,\n  anchorPosition: PropTypes.oneOf(ANCHOR_POSITIONS),\n  isOpen: PropTypes.bool,\n  ownFocus: PropTypes.bool,\n  withTitle: PropTypes.bool,\n  closePopover: PropTypes.func.isRequired,\n  button: PropTypes.node.isRequired,\n  buttonRef: PropTypes.func,\n  children: PropTypes.node,\n  panelClassName: PropTypes.string,\n  panelPaddingSize: PropTypes.oneOf(SIZES),\n  panelRef: PropTypes.func,\n  popoverRef: PropTypes.func,\n  hasArrow: PropTypes.bool,\n  container: PropTypes.instanceOf(HTMLElement),\n  /** When `true`, the popover's position is re-calculated when the user scrolls, this supports having fixed-position popover anchors. */\n  repositionOnScroll: PropTypes.bool,\n  /** By default, popover content inherits the z-index of the anchor component; pass zIndex to override */\n  zIndex: PropTypes.number,\n  /** specifies what element should initially have focus; Can be a DOM node, or a selector string (which will be passed to document.querySelector() to find the DOM node), or a function that returns a DOM node. */\n  initialFocus: PropTypes.oneOfType([\n    PropTypes.instanceOf(HTMLElement),\n    PropTypes.func,\n    PropTypes.string,\n  ]),\n  /** Passed directly to EuiPortal for DOM positioning. Both properties are required if prop is specified **/\n  insert: PropTypes.shape({\n    sibling: PropTypes.instanceOf(HTMLElement),\n    position: PropTypes.oneOf(['before', 'after']),\n  }),\n  /** Style and position alteration for arrow-less, left-aligned attachment. Intended for use with inputs as anchors, à la EuiColorPicker */\n  attachToAnchor: PropTypes.bool,\n  /** CSS display type for both the popover and anchor */\n  display: PropTypes.oneOf(DISPLAY),\n};\n\nEuiPopover.propTypes = EuiPopoverPropTypes;\n\nEuiPopover.defaultProps = {\n  isOpen: false,\n  ownFocus: false,\n  anchorPosition: 'downCenter',\n  panelPaddingSize: 'm',\n  hasArrow: true,\n  display: 'inlineBlock',\n};\n"]}]}