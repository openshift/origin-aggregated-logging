{"remainingRequest":"/Users/chanderprall/projects/eui/node_modules/babel-loader/lib/index.js!/Users/chanderprall/projects/eui/src/services/popover/calculate_popover_position.ts","dependencies":[{"path":"/Users/chanderprall/projects/eui/src/services/popover/calculate_popover_position.ts","mtime":1565204170071},{"path":"/Users/chanderprall/projects/eui/.babelrc.js","mtime":1565204168946},{"path":"/Users/chanderprall/projects/eui/node_modules/cache-loader/dist/cjs.js","mtime":1555436064329},{"path":"/Users/chanderprall/projects/eui/node_modules/babel-loader/lib/index.js","mtime":1543517280769}],"contextDependencies":[],"result":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.calculatePopoverPosition = calculatePopoverPosition;\n\nrequire(\"core-js/modules/es6.array.iterator\");\n\nrequire(\"core-js/modules/es6.object.keys\");\n\nrequire(\"core-js/modules/web.dom.iterable\");\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nvar getVisibleArea = function getVisibleArea(bounds, windowWidth, windowHeight) {\n  var left = bounds.left,\n      top = bounds.top,\n      width = bounds.width,\n      height = bounds.height; // This is a common algorithm for finding the intersected area among two rectangles.\n\n  var dx = Math.min(left + width, windowWidth) - Math.max(left, 0);\n  var dy = Math.min(top + height, windowHeight) - Math.max(top, 0);\n  return dx * dy;\n};\n\nvar positionAtTop = function positionAtTop(anchorBounds, width, height, buffer) {\n  var widthDifference = width - anchorBounds.width;\n  var left = anchorBounds.left - widthDifference * 0.5;\n  var top = anchorBounds.top - height - buffer;\n  return {\n    left: left,\n    top: top,\n    width: width,\n    height: height\n  };\n};\n\nvar positionAtRight = function positionAtRight(anchorBounds, width, height, buffer) {\n  var left = anchorBounds.right + buffer;\n  var heightDifference = height - anchorBounds.height;\n  var top = anchorBounds.top - heightDifference * 0.5;\n  return {\n    left: left,\n    top: top,\n    width: width,\n    height: height\n  };\n};\n\nvar positionAtBottom = function positionAtBottom(anchorBounds, width, height, buffer) {\n  var widthDifference = width - anchorBounds.width;\n  var left = anchorBounds.left - widthDifference * 0.5;\n  var top = anchorBounds.bottom + buffer;\n  return {\n    left: left,\n    top: top,\n    width: width,\n    height: height\n  };\n};\n\nvar positionAtLeft = function positionAtLeft(anchorBounds, width, height, buffer) {\n  var left = anchorBounds.left - width - buffer;\n  var heightDifference = height - anchorBounds.height;\n  var top = anchorBounds.top - heightDifference * 0.5;\n  return {\n    left: left,\n    top: top,\n    width: width,\n    height: height\n  };\n};\n\nvar positionToPositionerMap = {\n  top: positionAtTop,\n  right: positionAtRight,\n  bottom: positionAtBottom,\n  left: positionAtLeft\n};\n/**\n * Determine the best position for a popover that avoids clipping by the window view port.\n *\n * @param {Object} anchorBounds - getBoundingClientRect() of the node the popover is tethered to (e.g. a button).\n * @param {Object} popoverBounds - getBoundingClientRect() of the popover node (e.g. the tooltip).\n * @param {string} requestedPosition - Position the user wants. One of [\"top\", \"right\", \"bottom\", \"left\"]\n * @param {number} buffer - The space between the wrapper and the popover. Also the minimum space between the\n * popover and the window.\n * @param {Array} positions - List of acceptable positions. Defaults to [\"top\", \"right\", \"bottom\", \"left\"].\n *\n * @returns {Object} With properties position (one of [\"top\", \"right\", \"bottom\", \"left\"]), left, top, width, and height.\n */\n\nfunction calculatePopoverPosition(anchorBounds, popoverBounds, requestedPosition) {\n  var buffer = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 16;\n  var positions = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : ['top', 'right', 'bottom', 'left'];\n\n  if (typeof buffer !== 'number') {\n    throw new Error(\"calculatePopoverPosition received a buffer argument of \".concat(buffer, \"' but expected a number\"));\n  }\n\n  var windowWidth = window.innerWidth;\n  var windowHeight = window.innerHeight;\n  var popoverWidth = popoverBounds.width,\n      popoverHeight = popoverBounds.height;\n  var positionToBoundsMap = {};\n  var positionToVisibleAreaMap = {};\n  positions.forEach(function (position) {\n    var bounds = positionToPositionerMap[position](anchorBounds, popoverWidth, popoverHeight, buffer);\n    positionToBoundsMap[position] = bounds; // Calculate how much area of the popover is visible at each position.\n\n    positionToVisibleAreaMap[position] = getVisibleArea(bounds, windowWidth, windowHeight);\n  }); // If the requested position clips the popover, find the position which clips the popover the least.\n  // Default to use the requested position.\n\n  var calculatedPopoverPosition = positions.reduce(function (mostVisiblePosition, position) {\n    if (positionToVisibleAreaMap[position] > positionToVisibleAreaMap[mostVisiblePosition]) {\n      return position;\n    }\n\n    return mostVisiblePosition;\n  }, requestedPosition);\n  return _objectSpread({\n    position: calculatedPopoverPosition\n  }, positionToBoundsMap[calculatedPopoverPosition]);\n}",{"version":3,"sources":["/Users/chanderprall/projects/eui/src/services/popover/calculate_popover_position.ts"],"names":["getVisibleArea","bounds","windowWidth","windowHeight","left","top","width","height","dx","Math","min","max","dy","positionAtTop","anchorBounds","buffer","widthDifference","positionAtRight","right","heightDifference","positionAtBottom","bottom","positionAtLeft","positionToPositionerMap","calculatePopoverPosition","popoverBounds","requestedPosition","positions","Error","window","innerWidth","innerHeight","popoverWidth","popoverHeight","positionToBoundsMap","positionToVisibleAreaMap","forEach","position","calculatedPopoverPosition","reduce","mostVisiblePosition"],"mappings":"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","sourcesContent":["import { EuiPopoverPosition } from './types';\n\ninterface EuiPopoverBoundingBox {\n  top: number;\n  left: number;\n  width: number;\n  height: number;\n}\n\ninterface EuiPopoverAnchorRect extends EuiPopoverBoundingBox {\n  right: number;\n  bottom: number;\n}\n\ninterface EuiPopoverDimensions {\n  width: number;\n  height: number;\n}\n\ninterface EuiPopoverPositionedBox extends EuiPopoverBoundingBox {\n  position: EuiPopoverPosition;\n}\n\nconst getVisibleArea = (\n  bounds: EuiPopoverBoundingBox,\n  windowWidth: number,\n  windowHeight: number\n): number => {\n  const { left, top, width, height } = bounds;\n  // This is a common algorithm for finding the intersected area among two rectangles.\n  const dx = Math.min(left + width, windowWidth) - Math.max(left, 0);\n  const dy = Math.min(top + height, windowHeight) - Math.max(top, 0);\n  return dx * dy;\n};\n\ntype Positioner = (\n  bounds: EuiPopoverAnchorRect,\n  width: number,\n  height: number,\n  buffer: number\n) => EuiPopoverBoundingBox;\n\nconst positionAtTop: Positioner = (anchorBounds, width, height, buffer) => {\n  const widthDifference = width - anchorBounds.width;\n  const left = anchorBounds.left - widthDifference * 0.5;\n  const top = anchorBounds.top - height - buffer;\n  return { left, top, width, height };\n};\n\nconst positionAtRight: Positioner = (anchorBounds, width, height, buffer) => {\n  const left = anchorBounds.right + buffer;\n  const heightDifference = height - anchorBounds.height;\n  const top = anchorBounds.top - heightDifference * 0.5;\n  return { left, top, width, height };\n};\n\nconst positionAtBottom: Positioner = (anchorBounds, width, height, buffer) => {\n  const widthDifference = width - anchorBounds.width;\n  const left = anchorBounds.left - widthDifference * 0.5;\n  const top = anchorBounds.bottom + buffer;\n  return { left, top, width, height };\n};\n\nconst positionAtLeft: Positioner = (anchorBounds, width, height, buffer) => {\n  const left = anchorBounds.left - width - buffer;\n  const heightDifference = height - anchorBounds.height;\n  const top = anchorBounds.top - heightDifference * 0.5;\n  return { left, top, width, height };\n};\n\nconst positionToPositionerMap: { [position: string]: Positioner } = {\n  top: positionAtTop,\n  right: positionAtRight,\n  bottom: positionAtBottom,\n  left: positionAtLeft,\n};\n\n/**\n * Determine the best position for a popover that avoids clipping by the window view port.\n *\n * @param {Object} anchorBounds - getBoundingClientRect() of the node the popover is tethered to (e.g. a button).\n * @param {Object} popoverBounds - getBoundingClientRect() of the popover node (e.g. the tooltip).\n * @param {string} requestedPosition - Position the user wants. One of [\"top\", \"right\", \"bottom\", \"left\"]\n * @param {number} buffer - The space between the wrapper and the popover. Also the minimum space between the\n * popover and the window.\n * @param {Array} positions - List of acceptable positions. Defaults to [\"top\", \"right\", \"bottom\", \"left\"].\n *\n * @returns {Object} With properties position (one of [\"top\", \"right\", \"bottom\", \"left\"]), left, top, width, and height.\n */\nexport function calculatePopoverPosition(\n  anchorBounds: EuiPopoverAnchorRect,\n  popoverBounds: EuiPopoverDimensions,\n  requestedPosition: EuiPopoverPosition,\n  buffer: number = 16,\n  positions: EuiPopoverPosition[] = ['top', 'right', 'bottom', 'left']\n): EuiPopoverPositionedBox {\n  if (typeof buffer !== 'number') {\n    throw new Error(\n      `calculatePopoverPosition received a buffer argument of ${buffer}' but expected a number`\n    );\n  }\n\n  const windowWidth = window.innerWidth;\n  const windowHeight = window.innerHeight;\n  const { width: popoverWidth, height: popoverHeight } = popoverBounds;\n\n  const positionToBoundsMap: { [position: string]: EuiPopoverBoundingBox } = {};\n  const positionToVisibleAreaMap: { [positon: string]: number } = {};\n\n  positions.forEach(position => {\n    const bounds = positionToPositionerMap[position](\n      anchorBounds,\n      popoverWidth,\n      popoverHeight,\n      buffer\n    );\n    positionToBoundsMap[position] = bounds;\n\n    // Calculate how much area of the popover is visible at each position.\n    positionToVisibleAreaMap[position] = getVisibleArea(\n      bounds,\n      windowWidth,\n      windowHeight\n    );\n  });\n\n  // If the requested position clips the popover, find the position which clips the popover the least.\n  // Default to use the requested position.\n  const calculatedPopoverPosition = positions.reduce(\n    (mostVisiblePosition, position) => {\n      if (\n        positionToVisibleAreaMap[position] >\n        positionToVisibleAreaMap[mostVisiblePosition]\n      ) {\n        return position;\n      }\n      return mostVisiblePosition;\n    },\n    requestedPosition\n  );\n\n  return {\n    position: calculatedPopoverPosition,\n    ...positionToBoundsMap[calculatedPopoverPosition],\n  };\n}\n"]}]}