{"remainingRequest":"/Users/chanderprall/projects/eui/node_modules/babel-loader/lib/index.js!/Users/chanderprall/projects/eui/src/components/i18n/i18n_util.tsx","dependencies":[{"path":"/Users/chanderprall/projects/eui/src/components/i18n/i18n_util.tsx","mtime":1565204169771},{"path":"/Users/chanderprall/projects/eui/.babelrc.js","mtime":1565204168946},{"path":"/Users/chanderprall/projects/eui/node_modules/cache-loader/dist/cjs.js","mtime":1555436064329},{"path":"/Users/chanderprall/projects/eui/node_modules/babel-loader/lib/index.js","mtime":1543517280769}],"contextDependencies":[],"result":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.processStringToChildren = processStringToChildren;\n\nrequire(\"core-js/modules/es7.symbol.async-iterator\");\n\nrequire(\"core-js/modules/es6.symbol\");\n\nvar _react = require(\"react\");\n\nvar _lodash_predicates = require(\"../../services/predicate/lodash_predicates\");\n\nvar _reactIs = require(\"react-is\");\n\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction isPrimitive(value) {\n  return (0, _lodash_predicates.isBoolean)(value) || (0, _lodash_predicates.isString)(value) || (0, _lodash_predicates.isNumber)(value);\n}\n\nfunction hasPropName(child) {\n  return _typeof(child) === 'object' && child.hasOwnProperty('propName');\n}\n/**\n * Replaces placeholder values in `input` with their matching value in `values`\n * e.g. input:'Hello, {name}' will replace `{name}` with `values[name]`\n * @param {string} input\n * @param {RenderableValues} values\n * @param {Function} i18nMappingFunc\n * @returns {string | React.ReactChild[]}\n */\n\n\nfunction processStringToChildren(input, values, i18nMappingFunc) {\n  var children = [];\n  var child;\n\n  function appendCharToChild(char) {\n    if (child === undefined) {\n      // starting a new string literal\n      child = char;\n    } else if (typeof child === 'string') {\n      // existing string literal\n      child = child + char;\n    } else if (hasPropName(child)) {\n      // adding to the propName of a values lookup\n      child.propName = child.propName + char;\n    }\n  }\n\n  function appendValueToChildren(value) {\n    if (value === undefined) {\n      return;\n    } else if ((0, _reactIs.isElement)(value)) {\n      // an array with any ReactElements will be kept as an array\n      // so they need to be assigned a key\n      children.push((0, _react.cloneElement)(value, {\n        key: children.length\n      }));\n    } else if (hasPropName(value)) {// this won't be called, propName children are converted to a ReactChild before calling this\n    } else {\n      // everything else can go straight in\n      if (i18nMappingFunc !== undefined && typeof value === 'string') {\n        value = i18nMappingFunc(value);\n      }\n\n      children.push(value);\n    }\n  } // if we don't encounter a non-primitive\n  // then `children` can be concatenated together at the end\n\n\n  var encounteredNonPrimitive = false; // tslint:disable-next-line:prefer-for-of\n\n  for (var i = 0; i < input.length; i++) {\n    var char = input[i];\n\n    if (char === '\\\\') {\n      // peek at the next character to know if this is an escape\n      var nextChar = input[i + 1];\n      var charToAdd = char; // if this isn't an escape sequence then we will add the backslash\n\n      if (nextChar === '{' || nextChar === '}') {\n        // escaping a brace\n        i += 1; // advance passed the brace\n\n        charToAdd = input[i];\n      }\n\n      appendCharToChild(charToAdd);\n    } else if (char === '{') {\n      appendValueToChildren(child);\n      child = {\n        propName: ''\n      };\n    } else if (char === '}') {\n      var _propName = child.propName;\n\n      if (!values.hasOwnProperty(_propName)) {\n        throw new Error(\"Key \\\"\".concat(_propName, \"\\\" not found in \").concat(JSON.stringify(values, null, 2)));\n      }\n\n      var propValue = values[_propName];\n      encounteredNonPrimitive = encounteredNonPrimitive || !isPrimitive(propValue);\n      appendValueToChildren(propValue);\n      child = undefined;\n    } else {\n      appendCharToChild(char);\n    }\n  } // include any remaining child value\n\n\n  appendValueToChildren(child);\n  return encounteredNonPrimitive ? children : children.join('');\n}",{"version":3,"sources":["/Users/chanderprall/projects/eui/src/components/i18n/i18n_util.tsx"],"names":["isPrimitive","value","hasPropName","child","hasOwnProperty","processStringToChildren","input","values","i18nMappingFunc","children","appendCharToChild","char","undefined","propName","appendValueToChildren","push","key","length","encounteredNonPrimitive","i","nextChar","charToAdd","Error","JSON","stringify","propValue","join"],"mappings":"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","sourcesContent":["import { cloneElement, ReactChild } from 'react';\nimport {\n  isBoolean,\n  isString,\n  isNumber,\n} from '../../services/predicate/lodash_predicates';\nimport { isElement } from 'react-is';\nimport { RenderableValues } from '../context/context';\n\nfunction isPrimitive(value: ReactChild) {\n  return isBoolean(value) || isString(value) || isNumber(value);\n}\n\ntype Child = string | { propName: string } | ReactChild | undefined;\n\nfunction hasPropName(child: Child): child is { propName: string } {\n  return typeof child === 'object' && child.hasOwnProperty('propName');\n}\n\n/**\n * Replaces placeholder values in `input` with their matching value in `values`\n * e.g. input:'Hello, {name}' will replace `{name}` with `values[name]`\n * @param {string} input\n * @param {RenderableValues} values\n * @param {Function} i18nMappingFunc\n * @returns {string | React.ReactChild[]}\n */\nexport function processStringToChildren(\n  input: string,\n  values: RenderableValues,\n  i18nMappingFunc?: (token: string) => string\n): string | ReactChild[] {\n  const children: ReactChild[] = [];\n\n  let child: Child;\n\n  function appendCharToChild(char: string) {\n    if (child === undefined) {\n      // starting a new string literal\n      child = char;\n    } else if (typeof child === 'string') {\n      // existing string literal\n      child = child + char;\n    } else if (hasPropName(child)) {\n      // adding to the propName of a values lookup\n      child.propName = child.propName + char;\n    }\n  }\n\n  function appendValueToChildren(value: Child) {\n    if (value === undefined) {\n      return;\n    } else if (isElement(value)) {\n      // an array with any ReactElements will be kept as an array\n      // so they need to be assigned a key\n      children.push(cloneElement(value, { key: children.length }));\n    } else if (hasPropName(value)) {\n      // this won't be called, propName children are converted to a ReactChild before calling this\n    } else {\n      // everything else can go straight in\n      if (i18nMappingFunc !== undefined && typeof value === 'string') {\n        value = i18nMappingFunc(value);\n      }\n      children.push(value);\n    }\n  }\n\n  // if we don't encounter a non-primitive\n  // then `children` can be concatenated together at the end\n  let encounteredNonPrimitive = false;\n  // tslint:disable-next-line:prefer-for-of\n  for (let i = 0; i < input.length; i++) {\n    const char = input[i];\n\n    if (char === '\\\\') {\n      // peek at the next character to know if this is an escape\n      const nextChar = input[i + 1];\n      let charToAdd = char; // if this isn't an escape sequence then we will add the backslash\n\n      if (nextChar === '{' || nextChar === '}') {\n        // escaping a brace\n        i += 1; // advance passed the brace\n        charToAdd = input[i];\n      }\n      appendCharToChild(charToAdd);\n    } else if (char === '{') {\n      appendValueToChildren(child);\n      child = { propName: '' };\n    } else if (char === '}') {\n      const propName = (child as { propName: string }).propName;\n      if (!values.hasOwnProperty(propName)) {\n        throw new Error(\n          `Key \"${propName}\" not found in ${JSON.stringify(values, null, 2)}`\n        );\n      }\n      const propValue = values[propName];\n      encounteredNonPrimitive =\n        encounteredNonPrimitive || !isPrimitive(propValue);\n      appendValueToChildren(propValue);\n      child = undefined;\n    } else {\n      appendCharToChild(char);\n    }\n  }\n\n  // include any remaining child value\n  appendValueToChildren(child);\n\n  return encounteredNonPrimitive ? children : children.join('');\n}\n"]}]}