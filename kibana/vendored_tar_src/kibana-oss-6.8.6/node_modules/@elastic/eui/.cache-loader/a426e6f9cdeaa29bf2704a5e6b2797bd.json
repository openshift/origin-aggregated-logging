{"remainingRequest":"/Users/chanderprall/projects/eui/node_modules/babel-loader/lib/index.js!/Users/chanderprall/projects/eui/src/components/search_bar/query/ast_to_es_query_string.js","dependencies":[{"path":"/Users/chanderprall/projects/eui/src/components/search_bar/query/ast_to_es_query_string.js","mtime":1565204169984},{"path":"/Users/chanderprall/projects/eui/.babelrc.js","mtime":1565204168946},{"path":"/Users/chanderprall/projects/eui/node_modules/cache-loader/dist/cjs.js","mtime":1555436064329},{"path":"/Users/chanderprall/projects/eui/node_modules/babel-loader/lib/index.js","mtime":1543517280769}],"contextDependencies":[],"result":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.astToEsQueryString = void 0;\n\nrequire(\"core-js/modules/es6.regexp.match\");\n\nvar _date_format = require(\"./date_format\");\n\nvar _date_value = require(\"./date_value\");\n\nvar _ast = require(\"./ast\");\n\nvar _predicate = require(\"../../../services/predicate\");\n\nvar emitMatch = function emitMatch(match) {\n  if (!match) {\n    return '';\n  }\n\n  return _ast.AST.Match.isMust(match) ? '+' : '-';\n};\n\nvar emitFieldDateLikeClause = function emitFieldDateLikeClause(field, value, operator, match) {\n  var matchOp = emitMatch(match);\n\n  switch (operator) {\n    case _ast.Operator.EQ:\n      return \"\".concat(matchOp).concat(field, \":\").concat((0, _date_format.printIso8601)(value));\n\n    case _ast.Operator.GT:\n      return \"\".concat(matchOp).concat(field, \":>\").concat((0, _date_format.printIso8601)(value));\n\n    case _ast.Operator.GTE:\n      return \"\".concat(matchOp).concat(field, \":>=\").concat((0, _date_format.printIso8601)(value));\n\n    case _ast.Operator.LT:\n      return \"\".concat(matchOp).concat(field, \":<\").concat((0, _date_format.printIso8601)(value));\n\n    case _ast.Operator.LTE:\n      return \"\".concat(matchOp).concat(field, \":<=\").concat((0, _date_format.printIso8601)(value));\n\n    default:\n      throw new Error(\"unknown operator [\".concat(operator, \"]\"));\n  }\n};\n\nvar emitFieldDateValueClause = function emitFieldDateValueClause(field, value, operator, match) {\n  var matchOp = emitMatch(match);\n  var granularity = value.granularity,\n      resolve = value.resolve;\n  var date = resolve();\n\n  if (granularity) {\n    switch (operator) {\n      case _ast.Operator.EQ:\n        var gte = granularity.iso8601(granularity.start(date));\n        var lt = granularity.iso8601(granularity.startOfNext(date));\n        return \"\".concat(matchOp).concat(field, \":(>=\").concat(gte, \" AND <\").concat(lt, \")\");\n\n      case _ast.Operator.GT:\n        return \"\".concat(matchOp).concat(field, \":>=\").concat(granularity.iso8601(granularity.startOfNext(date)));\n\n      case _ast.Operator.GTE:\n        return \"\".concat(matchOp).concat(field, \":>=\").concat(granularity.iso8601(granularity.start(date)));\n\n      case _ast.Operator.LT:\n        return \"\".concat(matchOp).concat(field, \":<\").concat(granularity.iso8601(granularity.start(date)));\n\n      case _ast.Operator.LTE:\n        return \"\".concat(matchOp).concat(field, \":<\").concat(granularity.iso8601(granularity.startOfNext(date)));\n\n      default:\n        throw new Error(\"unknown operator [\".concat(operator, \"]\"));\n    }\n  }\n\n  return emitFieldDateLikeClause(field, date, operator, match);\n};\n\nvar emitFieldNumericClause = function emitFieldNumericClause(field, value, operator, match) {\n  var matchOp = emitMatch(match);\n\n  switch (operator) {\n    case _ast.Operator.EQ:\n      return \"\".concat(matchOp).concat(field, \":\").concat(value);\n\n    case _ast.Operator.GT:\n      return \"\".concat(matchOp).concat(field, \":>\").concat(value);\n\n    case _ast.Operator.GTE:\n      return \"\".concat(matchOp).concat(field, \":>=\").concat(value);\n\n    case _ast.Operator.LT:\n      return \"\".concat(matchOp).concat(field, \":<\").concat(value);\n\n    case _ast.Operator.LTE:\n      return \"\".concat(matchOp).concat(field, \":<=\").concat(value);\n\n    default:\n      throw new Error(\"unknown operator [\".concat(operator, \"]\"));\n  }\n};\n\nvar emitFieldStringClause = function emitFieldStringClause(field, value, match) {\n  var matchOp = emitMatch(match);\n\n  if (value.match(/\\s/)) {\n    return \"\".concat(matchOp).concat(field, \":\\\"\").concat(value, \"\\\"\");\n  }\n\n  return \"\".concat(matchOp).concat(field, \":\").concat(value);\n};\n\nvar emitFieldBooleanClause = function emitFieldBooleanClause(field, value, match) {\n  var matchOp = emitMatch(match);\n  return \"\".concat(matchOp).concat(field, \":\").concat(value);\n};\n\nvar emitFieldSingleValueClause = function emitFieldSingleValueClause(field, value, operator, match) {\n  if ((0, _date_value.isDateValue)(value)) {\n    return emitFieldDateValueClause(field, value, operator, match);\n  }\n\n  if ((0, _predicate.isDateLike)(value)) {\n    return emitFieldDateLikeClause(field, value, operator, match);\n  }\n\n  if ((0, _predicate.isString)(value)) {\n    return emitFieldStringClause(field, value, match);\n  }\n\n  if ((0, _predicate.isNumber)(value)) {\n    return emitFieldNumericClause(field, value, operator, match);\n  }\n\n  if ((0, _predicate.isBoolean)(value)) {\n    return emitFieldBooleanClause(field, value, match);\n  }\n\n  throw new Error(\"unknown type of field value [\".concat(value, \"]\"));\n};\n\nvar emitFieldClause = function emitFieldClause(clause, isGroupMember) {\n  var field = clause.field,\n      value = clause.value,\n      operator = clause.operator;\n  var match = clause.match;\n  if (isGroupMember && _ast.AST.Match.isMust(match)) match = null;\n\n  if (!(0, _predicate.isArray)(value)) {\n    return emitFieldSingleValueClause(field, value, operator, match);\n  }\n\n  var matchOp = emitMatch(match);\n  var clauses = value.map(function (v) {\n    return emitFieldSingleValueClause(field, v, operator);\n  }).join(' OR ');\n  return \"\".concat(matchOp, \"(\").concat(clauses, \")\");\n};\n\nvar emitTermClause = function emitTermClause(clause, isGroupMember) {\n  var value = clause.value;\n  var match = clause.match;\n  if (isGroupMember && _ast.AST.Match.isMust(match)) match = null;\n  var matchOp = emitMatch(match);\n  return \"\".concat(matchOp).concat(value);\n};\n\nvar emitIsClause = function emitIsClause(clause, isGroupMember) {\n  var flag = clause.flag,\n      match = clause.match;\n  var matchOp = isGroupMember ? '' : '+';\n\n  var flagValue = _ast.AST.Match.isMust(match);\n\n  return \"\".concat(matchOp).concat(flag, \":\").concat(flagValue);\n};\n\nvar emitGroupClause = function emitGroupClause(clause) {\n  var value = clause.value;\n  var formattedValues = value.map(function (clause) {\n    return emitClause(clause, true);\n  });\n  return \"+(\".concat(formattedValues.join(' '), \")\");\n};\n\nfunction emitClause(clause) {\n  var isGroupMember = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n  if (_ast.AST.Field.isInstance(clause)) {\n    return emitFieldClause(clause, isGroupMember);\n  }\n\n  if (_ast.AST.Term.isInstance(clause)) {\n    return emitTermClause(clause, isGroupMember);\n  }\n\n  if (_ast.AST.Is.isInstance(clause)) {\n    return emitIsClause(clause, isGroupMember);\n  }\n\n  if (_ast.AST.Group.isInstance(clause)) {\n    return emitGroupClause(clause, isGroupMember);\n  }\n\n  throw new Error(\"unknown clause type [\".concat(JSON.stringify(clause), \"]\"));\n}\n\nvar astToEsQueryString = function astToEsQueryString(ast) {\n  if (ast.clauses.length === 0) {\n    return '*';\n  }\n\n  return ast.clauses.map(function (clause) {\n    return emitClause(clause);\n  }).join(' ');\n};\n\nexports.astToEsQueryString = astToEsQueryString;",{"version":3,"sources":["/Users/chanderprall/projects/eui/src/components/search_bar/query/ast_to_es_query_string.js"],"names":["emitMatch","match","AST","Match","isMust","emitFieldDateLikeClause","field","value","operator","matchOp","Operator","EQ","GT","GTE","LT","LTE","Error","emitFieldDateValueClause","granularity","resolve","date","gte","iso8601","start","lt","startOfNext","emitFieldNumericClause","emitFieldStringClause","emitFieldBooleanClause","emitFieldSingleValueClause","emitFieldClause","clause","isGroupMember","clauses","map","v","join","emitTermClause","emitIsClause","flag","flagValue","emitGroupClause","formattedValues","emitClause","Field","isInstance","Term","Is","Group","JSON","stringify","astToEsQueryString","ast","length"],"mappings":"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","sourcesContent":["import { printIso8601 } from './date_format';\nimport { isDateValue } from './date_value';\nimport { AST, Operator } from './ast';\nimport {\n  isArray,\n  isDateLike,\n  isString,\n  isBoolean,\n  isNumber,\n} from '../../../services/predicate';\n\nconst emitMatch = match => {\n  if (!match) {\n    return '';\n  }\n  return AST.Match.isMust(match) ? '+' : '-';\n};\n\nconst emitFieldDateLikeClause = (field, value, operator, match) => {\n  const matchOp = emitMatch(match);\n  switch (operator) {\n    case Operator.EQ:\n      return `${matchOp}${field}:${printIso8601(value)}`;\n    case Operator.GT:\n      return `${matchOp}${field}:>${printIso8601(value)}`;\n    case Operator.GTE:\n      return `${matchOp}${field}:>=${printIso8601(value)}`;\n    case Operator.LT:\n      return `${matchOp}${field}:<${printIso8601(value)}`;\n    case Operator.LTE:\n      return `${matchOp}${field}:<=${printIso8601(value)}`;\n    default:\n      throw new Error(`unknown operator [${operator}]`);\n  }\n};\n\nconst emitFieldDateValueClause = (field, value, operator, match) => {\n  const matchOp = emitMatch(match);\n  const { granularity, resolve } = value;\n  const date = resolve();\n  if (granularity) {\n    switch (operator) {\n      case Operator.EQ:\n        const gte = granularity.iso8601(granularity.start(date));\n        const lt = granularity.iso8601(granularity.startOfNext(date));\n        return `${matchOp}${field}:(>=${gte} AND <${lt})`;\n      case Operator.GT:\n        return `${matchOp}${field}:>=${granularity.iso8601(\n          granularity.startOfNext(date)\n        )}`;\n      case Operator.GTE:\n        return `${matchOp}${field}:>=${granularity.iso8601(\n          granularity.start(date)\n        )}`;\n      case Operator.LT:\n        return `${matchOp}${field}:<${granularity.iso8601(\n          granularity.start(date)\n        )}`;\n      case Operator.LTE:\n        return `${matchOp}${field}:<${granularity.iso8601(\n          granularity.startOfNext(date)\n        )}`;\n      default:\n        throw new Error(`unknown operator [${operator}]`);\n    }\n  }\n  return emitFieldDateLikeClause(field, date, operator, match);\n};\n\nconst emitFieldNumericClause = (field, value, operator, match) => {\n  const matchOp = emitMatch(match);\n  switch (operator) {\n    case Operator.EQ:\n      return `${matchOp}${field}:${value}`;\n    case Operator.GT:\n      return `${matchOp}${field}:>${value}`;\n    case Operator.GTE:\n      return `${matchOp}${field}:>=${value}`;\n    case Operator.LT:\n      return `${matchOp}${field}:<${value}`;\n    case Operator.LTE:\n      return `${matchOp}${field}:<=${value}`;\n    default:\n      throw new Error(`unknown operator [${operator}]`);\n  }\n};\n\nconst emitFieldStringClause = (field, value, match) => {\n  const matchOp = emitMatch(match);\n  if (value.match(/\\s/)) {\n    return `${matchOp}${field}:\"${value}\"`;\n  }\n  return `${matchOp}${field}:${value}`;\n};\n\nconst emitFieldBooleanClause = (field, value, match) => {\n  const matchOp = emitMatch(match);\n  return `${matchOp}${field}:${value}`;\n};\n\nconst emitFieldSingleValueClause = (field, value, operator, match) => {\n  if (isDateValue(value)) {\n    return emitFieldDateValueClause(field, value, operator, match);\n  }\n  if (isDateLike(value)) {\n    return emitFieldDateLikeClause(field, value, operator, match);\n  }\n  if (isString(value)) {\n    return emitFieldStringClause(field, value, match);\n  }\n  if (isNumber(value)) {\n    return emitFieldNumericClause(field, value, operator, match);\n  }\n  if (isBoolean(value)) {\n    return emitFieldBooleanClause(field, value, match);\n  }\n  throw new Error(`unknown type of field value [${value}]`);\n};\n\nconst emitFieldClause = (clause, isGroupMember) => {\n  const { field, value, operator } = clause;\n  let { match } = clause;\n  if (isGroupMember && AST.Match.isMust(match)) match = null;\n\n  if (!isArray(value)) {\n    return emitFieldSingleValueClause(field, value, operator, match);\n  }\n  const matchOp = emitMatch(match);\n  const clauses = value\n    .map(v => emitFieldSingleValueClause(field, v, operator))\n    .join(' OR ');\n  return `${matchOp}(${clauses})`;\n};\n\nconst emitTermClause = (clause, isGroupMember) => {\n  const { value } = clause;\n  let { match } = clause;\n  if (isGroupMember && AST.Match.isMust(match)) match = null;\n\n  const matchOp = emitMatch(match);\n  return `${matchOp}${value}`;\n};\n\nconst emitIsClause = (clause, isGroupMember) => {\n  const { flag, match } = clause;\n  const matchOp = isGroupMember ? '' : '+';\n  const flagValue = AST.Match.isMust(match);\n  return `${matchOp}${flag}:${flagValue}`;\n};\n\nconst emitGroupClause = clause => {\n  const { value } = clause;\n  const formattedValues = value.map(clause => {\n    return emitClause(clause, true);\n  });\n  return `+(${formattedValues.join(' ')})`;\n};\n\nfunction emitClause(clause, isGroupMember = false) {\n  if (AST.Field.isInstance(clause)) {\n    return emitFieldClause(clause, isGroupMember);\n  }\n  if (AST.Term.isInstance(clause)) {\n    return emitTermClause(clause, isGroupMember);\n  }\n  if (AST.Is.isInstance(clause)) {\n    return emitIsClause(clause, isGroupMember);\n  }\n  if (AST.Group.isInstance(clause)) {\n    return emitGroupClause(clause, isGroupMember);\n  }\n  throw new Error(`unknown clause type [${JSON.stringify(clause)}]`);\n}\n\nexport const astToEsQueryString = ast => {\n  if (ast.clauses.length === 0) {\n    return '*';\n  }\n\n  return ast.clauses.map(clause => emitClause(clause)).join(' ');\n};\n"]}]}