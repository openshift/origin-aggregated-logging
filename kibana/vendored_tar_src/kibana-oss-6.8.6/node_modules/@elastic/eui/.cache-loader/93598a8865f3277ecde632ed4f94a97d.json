{"remainingRequest":"/Users/chanderprall/projects/eui/node_modules/babel-loader/lib/index.js!/Users/chanderprall/projects/eui/src/services/sort/sortable_properties.ts","dependencies":[{"path":"/Users/chanderprall/projects/eui/src/services/sort/sortable_properties.ts","mtime":1565204170077},{"path":"/Users/chanderprall/projects/eui/.babelrc.js","mtime":1565204168946},{"path":"/Users/chanderprall/projects/eui/node_modules/cache-loader/dist/cjs.js","mtime":1555436064329},{"path":"/Users/chanderprall/projects/eui/node_modules/babel-loader/lib/index.js","mtime":1543517280769}],"contextDependencies":[],"result":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.SortableProperties = void 0;\n\nrequire(\"core-js/modules/es6.string.iterator\");\n\nrequire(\"core-js/modules/es6.array.from\");\n\nrequire(\"core-js/modules/es6.regexp.to-string\");\n\nrequire(\"core-js/modules/es7.symbol.async-iterator\");\n\nrequire(\"core-js/modules/es6.symbol\");\n\nrequire(\"core-js/modules/web.dom.iterable\");\n\nrequire(\"core-js/modules/es6.function.name\");\n\nrequire(\"core-js/modules/es6.array.find\");\n\nrequire(\"core-js/modules/es6.array.sort\");\n\nvar _comparators = require(\"./comparators\");\n\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }\n\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance\"); }\n\nfunction _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === \"[object Arguments]\") return Array.from(iter); }\n\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n/**\n * @typedef {Object} SortableProperty\n * @property {string} sortableProperty.name - Name of the property.\n * @property {function} sortableProperty.getValue - A function that takes in an object and returns a value to sort\n * by.\n * @property {boolean} sortableProperty.isAscending - The direction of the last sort by this property. Used to preserve\n * past sort orders.\n */\n\n/**\n * Stores sort information for a set of SortableProperties, including which property is currently being sorted on, as\n * well as the last sort order for each property.\n */\nvar SortableProperties =\n/*#__PURE__*/\nfunction () {\n  /**\n   * @param {Array<SortableProperty>} sortableProperties - a set of sortable properties.\n   * @param {string} initialSortablePropertyName - Which sort property should be sorted on by default.\n   */\n  function SortableProperties(sortableProperties, initialSortablePropertyName) {\n    _classCallCheck(this, SortableProperties);\n\n    _defineProperty(this, \"sortableProperties\", void 0);\n\n    _defineProperty(this, \"currentSortedProperty\", void 0);\n\n    this.sortableProperties = sortableProperties;\n    /**\n     * The current property that is being sorted on.\n     * @type {SortableProperty}\n     */\n\n    var currentSortedProperty = this.getSortablePropertyByName(initialSortablePropertyName);\n\n    if (!currentSortedProperty) {\n      throw new Error(\"No property with the name \".concat(initialSortablePropertyName));\n    }\n\n    this.currentSortedProperty = currentSortedProperty;\n  }\n  /**\n   * @returns {SortableProperty} The current property that is being sorted on. Undefined if no sort order is applied.\n   */\n\n\n  _createClass(SortableProperties, [{\n    key: \"getSortedProperty\",\n    value: function getSortedProperty() {\n      return this.currentSortedProperty;\n    }\n    /**\n     * Sorts the items passed in and returns a newly sorted array.\n     * @param items {Array.<Object>}\n     * @returns {Array.<Object>} sorted array of items, based off the sort properties.\n     */\n\n  }, {\n    key: \"sortItems\",\n    value: function sortItems(items) {\n      var copy = _toConsumableArray(items);\n\n      var comparator = _comparators.Comparators.value(this.getSortedProperty().getValue);\n\n      if (!this.isCurrentSortAscending()) {\n        comparator = _comparators.Comparators.reverse(comparator);\n      }\n\n      copy.sort(comparator);\n      return copy;\n    }\n    /**\n     * Returns the SortProperty with the given name, if found.\n     * @param {String} propertyName\n     * @returns {SortableProperty|undefined}\n     */\n\n  }, {\n    key: \"getSortablePropertyByName\",\n    value: function getSortablePropertyByName(propertyName) {\n      return this.sortableProperties.find(function (property) {\n        return property.name === propertyName;\n      });\n    }\n    /**\n     * Updates the sort property, potentially flipping the sort order based on whether the same\n     * property was already being sorted.\n     * @param propertyName {String}\n     */\n\n  }, {\n    key: \"sortOn\",\n    value: function sortOn(propertyName) {\n      var newSortedProperty = this.getSortablePropertyByName(propertyName);\n\n      if (!newSortedProperty) {\n        throw new Error(\"No property with the name \".concat(propertyName));\n      }\n\n      var sortedProperty = this.getSortedProperty();\n\n      if (sortedProperty.name === newSortedProperty.name) {\n        this.flipCurrentSortOrder();\n      } else {\n        this.currentSortedProperty = newSortedProperty;\n      }\n    }\n    /**\n     * @returns {boolean} True if the current sortable property is sorted in ascending order.\n     */\n\n  }, {\n    key: \"isCurrentSortAscending\",\n    value: function isCurrentSortAscending() {\n      var sortedProperty = this.getSortedProperty();\n      return sortedProperty ? this.isAscendingByName(sortedProperty.name) : false;\n    }\n    /**\n     * @param {string} propertyName\n     * @returns {boolean} True if the given sort property is sorted in ascending order.\n     */\n\n  }, {\n    key: \"isAscendingByName\",\n    value: function isAscendingByName(propertyName) {\n      var sortedProperty = this.getSortablePropertyByName(propertyName);\n      return sortedProperty ? sortedProperty.isAscending : false;\n    }\n    /**\n     * Flips the current sorted property sort order.\n     */\n\n  }, {\n    key: \"flipCurrentSortOrder\",\n    value: function flipCurrentSortOrder() {\n      this.currentSortedProperty.isAscending = !this.currentSortedProperty.isAscending;\n    }\n  }]);\n\n  return SortableProperties;\n}();\n\nexports.SortableProperties = SortableProperties;",{"version":3,"sources":["/Users/chanderprall/projects/eui/src/services/sort/sortable_properties.ts"],"names":["SortableProperties","sortableProperties","initialSortablePropertyName","currentSortedProperty","getSortablePropertyByName","Error","items","copy","comparator","Comparators","value","getSortedProperty","getValue","isCurrentSortAscending","reverse","sort","propertyName","find","property","name","newSortedProperty","sortedProperty","flipCurrentSortOrder","isAscendingByName","isAscending"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;AAAA;;;;;;;;;;;;;;;;;;AAQA;;;;;;;;;AASA;;;;IAIaA,kB;;;AAIX;;;;AAIA,8BACEC,kBADF,EAEEC,2BAFF,EAGE;AAAA;;AAAA;;AAAA;;AACA,SAAKD,kBAAL,GAA0BA,kBAA1B;AACA;;;;;AAIA,QAAME,qBAAqB,GAAG,KAAKC,yBAAL,CAC5BF,2BAD4B,CAA9B;;AAGA,QAAI,CAACC,qBAAL,EAA4B;AAC1B,YAAM,IAAIE,KAAJ,qCACyBH,2BADzB,EAAN;AAGD;;AAED,SAAKC,qBAAL,GAA6BA,qBAA7B;AACD;AAED;;;;;;;wCAGoB;AAClB,aAAO,KAAKA,qBAAZ;AACD;AAED;;;;;;;;8BAKUG,K,EAAiB;AACzB,UAAMC,IAAI,sBAAOD,KAAP,CAAV;;AACA,UAAIE,UAAU,GAAGC,yBAAYC,KAAZ,CAAkB,KAAKC,iBAAL,GAAyBC,QAA3C,CAAjB;;AACA,UAAI,CAAC,KAAKC,sBAAL,EAAL,EAAoC;AAClCL,QAAAA,UAAU,GAAGC,yBAAYK,OAAZ,CAAoBN,UAApB,CAAb;AACD;;AACDD,MAAAA,IAAI,CAACQ,IAAL,CAAUP,UAAV;AACA,aAAOD,IAAP;AACD;AAED;;;;;;;;8CAK0BS,Y,EAAsB;AAC9C,aAAO,KAAKf,kBAAL,CAAwBgB,IAAxB,CACL,UAAAC,QAAQ;AAAA,eAAIA,QAAQ,CAACC,IAAT,KAAkBH,YAAtB;AAAA,OADH,CAAP;AAGD;AAED;;;;;;;;2BAKOA,Y,EAAsB;AAC3B,UAAMI,iBAAiB,GAAG,KAAKhB,yBAAL,CAA+BY,YAA/B,CAA1B;;AACA,UAAI,CAACI,iBAAL,EAAwB;AACtB,cAAM,IAAIf,KAAJ,qCAAuCW,YAAvC,EAAN;AACD;;AACD,UAAMK,cAAc,GAAG,KAAKV,iBAAL,EAAvB;;AACA,UAAIU,cAAc,CAACF,IAAf,KAAwBC,iBAAiB,CAACD,IAA9C,EAAoD;AAClD,aAAKG,oBAAL;AACD,OAFD,MAEO;AACL,aAAKnB,qBAAL,GAA6BiB,iBAA7B;AACD;AACF;AAED;;;;;;6CAGyB;AACvB,UAAMC,cAAc,GAAG,KAAKV,iBAAL,EAAvB;AACA,aAAOU,cAAc,GAAG,KAAKE,iBAAL,CAAuBF,cAAc,CAACF,IAAtC,CAAH,GAAiD,KAAtE;AACD;AAED;;;;;;;sCAIkBH,Y,EAAsB;AACtC,UAAMK,cAAc,GAAG,KAAKjB,yBAAL,CAA+BY,YAA/B,CAAvB;AACA,aAAOK,cAAc,GAAGA,cAAc,CAACG,WAAlB,GAAgC,KAArD;AACD;AAED;;;;;;2CAGuB;AACrB,WAAKrB,qBAAL,CAA2BqB,WAA3B,GAAyC,CAAC,KAAKrB,qBAAL,CACvCqB,WADH;AAED","sourcesContent":["import { Comparators, Primitive } from './comparators';\n\nexport interface SortableProperty<T> {\n  name: string;\n  getValue: (obj: T) => Primitive;\n  isAscending: boolean;\n}\n\n/**\n * @typedef {Object} SortableProperty\n * @property {string} sortableProperty.name - Name of the property.\n * @property {function} sortableProperty.getValue - A function that takes in an object and returns a value to sort\n * by.\n * @property {boolean} sortableProperty.isAscending - The direction of the last sort by this property. Used to preserve\n * past sort orders.\n */\n\n/**\n * Stores sort information for a set of SortableProperties, including which property is currently being sorted on, as\n * well as the last sort order for each property.\n */\nexport class SortableProperties<T> {\n  sortableProperties: Array<SortableProperty<T>>;\n  currentSortedProperty: SortableProperty<T>;\n\n  /**\n   * @param {Array<SortableProperty>} sortableProperties - a set of sortable properties.\n   * @param {string} initialSortablePropertyName - Which sort property should be sorted on by default.\n   */\n  constructor(\n    sortableProperties: Array<SortableProperty<T>>,\n    initialSortablePropertyName: string\n  ) {\n    this.sortableProperties = sortableProperties;\n    /**\n     * The current property that is being sorted on.\n     * @type {SortableProperty}\n     */\n    const currentSortedProperty = this.getSortablePropertyByName(\n      initialSortablePropertyName\n    );\n    if (!currentSortedProperty) {\n      throw new Error(\n        `No property with the name ${initialSortablePropertyName}`\n      );\n    }\n\n    this.currentSortedProperty = currentSortedProperty;\n  }\n\n  /**\n   * @returns {SortableProperty} The current property that is being sorted on. Undefined if no sort order is applied.\n   */\n  getSortedProperty() {\n    return this.currentSortedProperty;\n  }\n\n  /**\n   * Sorts the items passed in and returns a newly sorted array.\n   * @param items {Array.<Object>}\n   * @returns {Array.<Object>} sorted array of items, based off the sort properties.\n   */\n  sortItems(items: T[]): T[] {\n    const copy = [...items];\n    let comparator = Comparators.value(this.getSortedProperty().getValue);\n    if (!this.isCurrentSortAscending()) {\n      comparator = Comparators.reverse(comparator);\n    }\n    copy.sort(comparator);\n    return copy;\n  }\n\n  /**\n   * Returns the SortProperty with the given name, if found.\n   * @param {String} propertyName\n   * @returns {SortableProperty|undefined}\n   */\n  getSortablePropertyByName(propertyName: string) {\n    return this.sortableProperties.find(\n      property => property.name === propertyName\n    );\n  }\n\n  /**\n   * Updates the sort property, potentially flipping the sort order based on whether the same\n   * property was already being sorted.\n   * @param propertyName {String}\n   */\n  sortOn(propertyName: string) {\n    const newSortedProperty = this.getSortablePropertyByName(propertyName);\n    if (!newSortedProperty) {\n      throw new Error(`No property with the name ${propertyName}`);\n    }\n    const sortedProperty = this.getSortedProperty();\n    if (sortedProperty.name === newSortedProperty.name) {\n      this.flipCurrentSortOrder();\n    } else {\n      this.currentSortedProperty = newSortedProperty;\n    }\n  }\n\n  /**\n   * @returns {boolean} True if the current sortable property is sorted in ascending order.\n   */\n  isCurrentSortAscending() {\n    const sortedProperty = this.getSortedProperty();\n    return sortedProperty ? this.isAscendingByName(sortedProperty.name) : false;\n  }\n\n  /**\n   * @param {string} propertyName\n   * @returns {boolean} True if the given sort property is sorted in ascending order.\n   */\n  isAscendingByName(propertyName: string) {\n    const sortedProperty = this.getSortablePropertyByName(propertyName);\n    return sortedProperty ? sortedProperty.isAscending : false;\n  }\n\n  /**\n   * Flips the current sorted property sort order.\n   */\n  flipCurrentSortOrder() {\n    this.currentSortedProperty.isAscending = !this.currentSortedProperty\n      .isAscending;\n  }\n}\n"]}]}